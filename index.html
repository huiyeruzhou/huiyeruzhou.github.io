<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huiyeruzhou.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="辉夜的博客">
<meta property="og:url" content="http://huiyeruzhou.github.io/index.html">
<meta property="og:site_name" content="辉夜的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="辉夜">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://huiyeruzhou.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>辉夜的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">辉夜的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">繁花似锦，辉夜如昼</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/08/%E5%85%AC%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E5%85%AC%E5%91%8A/" class="post-title-link" itemprop="url">公告</a>
        </h2>

        <div class="post-meta">
          
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-08 22:27:25" itemprop="dateCreated datePublished" datetime="2023-03-08T22:27:25+08:00">2023-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 23:20:32" itemprop="dateModified" datetime="2023-05-26T23:20:32+08:00">2023-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一条置顶公告。<br>如果要查阅专门为软件构造课程写的博客，请点击“标签”并在其中选择 <code>#软件构造</code>。<br>我强烈推荐您阅读“关于表示泄露-2”，这篇文章描述了浅拷贝和public final字段造成的表示泄露，是很微妙的细节。<br>为了复习期末考试，考试前一天晚上编写了很多用于加强记忆的文章，也一并放在这里了。截止时间之后的忽略就好，不过仍然给他们打上TAG，主要是便于管理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/09/17/INTEL-%E6%8C%87%E4%BB%A4%E9%9B%86%E6%89%8B%E5%86%8C-x86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/17/INTEL-%E6%8C%87%E4%BB%A4%E9%9B%86%E6%89%8B%E5%86%8C-x86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">INTEL 指令集手册-x86体系结构概览</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-17 09:45:55" itemprop="dateCreated datePublished" datetime="2023-09-17T09:45:55+08:00">2023-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-18 00:39:29" itemprop="dateModified" datetime="2023-09-18T00:39:29+08:00">2023-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="INTEL指令集手册笔记-x86体系结构概览"><a href="#INTEL指令集手册笔记-x86体系结构概览" class="headerlink" title="INTEL指令集手册笔记-x86体系结构概览"></a>INTEL指令集手册笔记-x86体系结构概览</h1><!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#intel%E6%8C%87%E4%BB%A4%E9%9B%86%E6%89%8B%E5%86%8C%E7%AC%94%E8%AE%B0-x86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88">INTEL指令集手册笔记-x86体系结构概览</a><ul>
<li><a href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%BC%80%E5%A7%8B">写在最开始</a><ul>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%A8%A1%E5%BC%8F">关于“模式”</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">关于“地址空间”</a></li>
</ul>
</li>
<li><a href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88">体系结构概览</a><ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">系统级寄存器和数据结构</a><ul>
<li><a href="#1-%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8gdt%E5%92%8C%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8ldt">1. 全局描述符表（GDT）和局部描述符表（LDT）</a></li>
<li><a href="#2%E7%B3%BB%E7%BB%9F%E6%AE%B5%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E9%97%A8">2.系统段，段描述符和门</a></li>
<li><a href="#3%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5task-state-segment%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%97%A8task-gates">3.任务状态段（Task-State Segment）和任务门（Task Gates）</a></li>
<li><a href="#4%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">4.中断和异常处理</a></li>
<li><a href="#5%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">5.内存管理</a></li>
<li><a href="#6%E7%B3%BB%E7%BB%9F%E5%AF%84%E5%AD%98%E5%99%A8">6.系统寄存器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->




<h2 id="写在最开始"><a href="#写在最开始" class="headerlink" title="写在最开始"></a>写在最开始</h2><p>本文是基于IA-32架构软件开发者手册（第三卷）的阅读笔记。作为软件开发者，这或许是我们所必须掌握的知识中最接近底层的一部分。在这里，我们将会看到计算机是如何工作的，以及我们的程序是如何被计算机执行的。</p>
<p>这些内容十分的抽象、晦涩、冗杂，包含了大量的细节和术语。因此，我将会尽量使用简单的语言来描述这些内容。</p>
<p>大多数时候，我使用无序列表来展示一些重要的概念，以期尽量精简的展示系统的结构。在开头和结尾，总是会有概括性的文字对于这部分内容进行概述和总结。对于特别重要或特别复杂的部分，我才会使用成段的文字展开讨论。我从不罗列内容，例如EFLAGS每个位置的含义，而只用文字解释图片中没有的信息。不过，我仍然会列出重要的几点供读者强化记忆。</p>
<p>为了更好的理解这部分知识，我们首先需要对一些关键的术语（主要是中文术语）进行辨析，理清这些内容，对于我们理解之后的内容有很大帮助。下面的内容假设读者具有一定的汇编和体系结构方面的知识（比如学习过CSAPP）。</p>
<h3 id="关于“模式”"><a href="#关于“模式”" class="headerlink" title="关于“模式”"></a>关于“模式”</h3><p>在Intel处理器中，存在许多的“模式”。我们将会看到，这些模式对应不同的寻址方式和内存布局。文中出现的模式大概有以下几种：</p>
<ul>
<li><p>实模式：最早的模式，也是（目前）所有处理器启动时的默认模式。这种情况下，表示为<code>CS:IP</code>的地址值为<code>CS&lt;&lt;4 + IP</code>。至多管理1MB的内存。</p>
<blockquote>
<p>这是8086 16位体系结构的无奈之举，用这种方式配合20位地址总线，编程空间得以从令人难以忍受的64KB扩展到1MB。</p>
</blockquote>
</li>
<li><p>IA32（保护模式）：从80386开始启用的模式，这种情况下，可以用平坦分段管理至多4GB的内存</p>
</li>
<li><p>IA32e（长模式）：支持64位的体系结构。提供至多48位的地址空间，并提供兼容32位OS和软件的“兼容模式”。不再使用段寄存器，段选择子固定为GDT，几乎完全采用页式地址管理。</p>
</li>
</ul>
<p>值得注意的是，IA32e与IA64并不相同。前者是我们熟知的x86-64（有时也称为x64）体系结构的一部分，是目前主流的64位体系结构。而IA64则是一种激进的不兼容IA32的64位架构，由Intel与HP合作开发，目前已经被抛弃。</p>
<h3 id="关于“地址空间”"><a href="#关于“地址空间”" class="headerlink" title="关于“地址空间”"></a>关于“地址空间”</h3><p>我们知道，在计算机界为人津津乐道的（八股文）术语之一就是地址空间，逻辑地址、线性地址、虚拟地址、物理地址成为无数求职者和学子的噩梦。</p>
<ul>
<li><p>物理地址（Physical Address，PA）：这个术语常常表示数据在物理内存条中的位置。在现代系统中，物理地址是由MMU（内存管理单元）通过页表变换得到的。</p>
</li>
<li><p>线性地址（linear address）：这个术语通常用来描述理想状态下的连续地址空间。<br>  当我说“线性地址”时，我总是指的是CPU使用的地址。</p>
<blockquote>
<p>维基百科：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linear_address_space">线性地址</a></p>
</blockquote>
</li>
<li><p>逻辑地址（logical address）：这个术语通常用来描述“分段模式下”的<code>段基址：偏移量</code>形式的地址。不过，它的本意实际上是“编程时使用的地址”。从这个角度来说，逻辑地址其实等同于线性地址。</p>
<blockquote>
<p>维基百科：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_address">地址空间</a></p>
</blockquote>
</li>
<li><p>虚拟地址（Virtual Address，VA）：这个术语常常表示进程所看到的内存空间。由于保护模式和长模式的现代系统总是使用页表基址提供给进程一个完整的连续地址空间，虚拟地址也就等同于线性地址。</p>
<p>  对于实模式而言，很难谈论虚拟地址，有人认为虚拟地址等于段偏移量，有人认为虚拟地址等于逻辑地址，但这其实没有意义。</p>
<blockquote>
<p>MSDB: <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/memory/virtual-address-space?redirectedfrom=MSDN">虚拟地址</a></p>
</blockquote>
</li>
</ul>
<p>以上的讨论仅限于本文，如果面试的时候被问到，请回答“逻辑地址经过段式变换得到线性地址，进程看到的线性地址（通过页表管理的线性地址）就是虚拟地址，虚拟地址经过页式变换得到物理地址”。</p>
<h2 id="体系结构概览"><a href="#体系结构概览" class="headerlink" title="体系结构概览"></a>体系结构概览</h2><p>本章中，我们将关注系统的寄存器结构以及操作这些寄存器的系统指令。理解寻址、内存、中断处理、任务管理的机制以及其中的重要数据结构。并且看到计算机是如何从实模式切换到保护模式的。</p>
<h3 id="系统级寄存器和数据结构"><a href="#系统级寄存器和数据结构" class="headerlink" title="系统级寄存器和数据结构"></a>系统级寄存器和数据结构</h3><p>下图展示了保护模式和长模式下的系统寄存器和数据结构。其中：</p>
<ul>
<li>左上角的部分展示了寄存器，包括标志寄存器、控制寄存器、任务寄存器和其他通用寄存器</li>
<li>TODO：</li>
<li>底部展示了页表将线性地址映射到物理地址的方式</li>
</ul>
<div style="display: flex; justify-content: space-between;">
    <div class="image">
        <img src="INTEL-%E6%8C%87%E4%BB%A4%E9%9B%86%E6%89%8B%E5%86%8C-x86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/image-1.png"
        alt="Image 1" width="500" height="400">
    </div>
    <div class="image">
        <img src="INTEL-%E6%8C%87%E4%BB%A4%E9%9B%86%E6%89%8B%E5%86%8C-x86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/image.png"
        alt="Image 2" width="500" height="400">
</div>

</div>
<p style="text-align: center;"><strong><small>左：保护模式（IA32）下的系统寄存器和数据结构<br>右：长模式（IA32e）下的系统寄存器和数据结构</small></strong></p>

<h4 id="1-全局描述符表（GDT）和局部描述符表（LDT）"><a href="#1-全局描述符表（GDT）和局部描述符表（LDT）" class="headerlink" title="1. 全局描述符表（GDT）和局部描述符表（LDT）"></a>1. 全局描述符表（GDT）和局部描述符表（LDT）</h4><p>在保护模式下，所有访存都是通过描述符表——GDT和LDT完成的。</p>
<ul>
<li><p>描述符表（Descriptor Table，DT）：用于内存、中断、任务管理的重要数据结构。</p>
</li>
<li><p>段描述符（Segment descriptors）：描述符表的表项。定义了段的起始地址、访问权限（读写执行）和使用信息。</p>
</li>
<li><p>段选择子（Segment Selector）：用来在GDT或LDT中定位段描述符。包含相对于DT基址的偏移量，一个全局&#x2F;局部标志位，以及特权级。</p>
</li>
<li><p>描述附表寄存器（Descriptor Table Register，DTR）：用来存储DT的线性地址基址。</p>
<blockquote>
<p>当前特权级（Current privilege level，CPL）：当前正在执行的代码所在的特权级。通常，特权级别从0~3，0表示内核态（完全权限），3表示用户态（最低权限）。</p>
</blockquote>
</li>
</ul>
<p>通过段选择子查询DT可以访问代码、数据、栈等段，其中的权限标志会阻止不合法的访问。</p>
<blockquote>
<p>长模式下描述符扩展为16字节，兼容模式下不进行这种扩展</p>
</blockquote>
<p>描述符机制是段式地址管理在现代系统中的实现，这种机制方便了内存的管理，并且提供了访问权限的控制。实模式下，总是直接访问物理地址，而保护模式下则至少要经过描述符的转换。从这个角度上来说，“实”指的是直接访问物理地址，“保护”指的是通过描述符表进行访问权限的保护。</p>
<h4 id="2-系统段，段描述符和门"><a href="#2-系统段，段描述符和门" class="headerlink" title="2.系统段，段描述符和门"></a>2.系统段，段描述符和门</h4><ul>
<li><p>系统段：TSS（Task-state Segment）和LDT，称为系统段。其余的则是运行时环境包含的代码、数据、栈这等段。GDT不视作系统段因为其不通过段选择子访问。</p>
</li>
<li><p>门（Gate）：特殊的段选择子，通过门进行的调用可以进行特权级别的转换。包含过程调用、中断、陷阱、任务等。</p>
<blockquote>
<ul>
<li>调用门：可以执行更高特权级别的代码，还可用于16-32位代码段的相互访问。</li>
</ul>
</blockquote>
</li>
</ul>
<p>长模式下，调用门可以用于64位和32位模式的代码段的相互访问。任务切换门被设置为NULL，其余门（包括TSS选择子和LDT选择子）被扩展为16字节。不过，页表中的特权控制很大程度上代替了门的特权控制功能。如同之前一样，段描述符和门都是在保护中重要，而在长模式中不再重要的概念。</p>
<p>门的使用方式和段选择子类似，通过门选择子查询GDT或LDT中的门描述符以获取基址，然后结合偏移量访问对应的数据。不过，门提供了特权级别的转换甚至是字长模式的转换，因而是一种特殊的段描述符。</p>
<p>系统段，称其为“系统”，是相对于“应用”而言的。系统段的存在是为了支持操作系统的运行，包括任务上下文保存、地址管理、中断处理等。</p>
<h4 id="3-任务状态段（Task-State-Segment）和任务门（Task-Gates）"><a href="#3-任务状态段（Task-State-Segment）和任务门（Task-Gates）" class="headerlink" title="3.任务状态段（Task-State Segment）和任务门（Task Gates）"></a>3.任务状态段（Task-State Segment）和任务门（Task Gates）</h4><p>任务状态段包含了一个任务所需的上下文：</p>
<ul>
<li>通用寄存器</li>
<li>条件码：EFLAGS</li>
<li>程序计数器：EIP</li>
<li>堆栈指针（3个特权级各一个）</li>
<li>页表基址寄存器（CR3）</li>
<li>局部描述符表选择子</li>
</ul>
<p>每次任务切换，操作系统都要保存状态，通过GDT选择新TSS并加载状态。</p>
<p>任务状态段要么通过TSSs（任务状态段选择子）访问，要么通过任务门访问，后者可以提供特权控制。</p>
<p>长模式下，不再能通过硬件切换任务，因此任务门不再有效。不过TSS仍然保留，且TSSs设置为指向TSS基址。</p>
<p>任务状态段的存在是为了支持任务切换，而任务切换是为了支持多道程序。一个TSS保存的内容就是一个完整的上下文，包括当前的数据、状态、执行位置等基础信息，还包含其地址空间信息（页表基址寄存器和LDT选择子）。</p>
<h4 id="4-中断和异常处理"><a href="#4-中断和异常处理" class="headerlink" title="4.中断和异常处理"></a>4.中断和异常处理</h4><p>外部中断（指外设引发的异步中断），软件中断和异常都通过中断描述符表（IDT）进行管理。</p>
<ul>
<li>中断描述符：IDT中的表项，都是门描述符，包含了中断处理程序的地址、特权级别等信息，也可以是一个任务门。</li>
<li>中断描述符表寄存器（IDTR）：用来存储IDT的地址基址。</li>
<li>中断向量：中断描述符的索引，通过中断向量查询IDT中的门描述符。</li>
</ul>
<p>外设、处理器、软件都可以引发中断。软件中断使用INT系列或BOUND指令。三种形式的中断例如：键盘中断、浮点异常、系统调用。</p>
<p>中断和陷阱会的处理等效于通过调用门调用处理函数，而指向任务门的中断向量会通过任务切换调用相应的处理函数。</p>
<h4 id="5-内存管理"><a href="#5-内存管理" class="headerlink" title="5.内存管理"></a>5.内存管理</h4><p>处理器支持物理地址或虚拟地址两种模式。分页启动时，所有的访存都是通过页表完成的。</p>
<ul>
<li>分页（Paging）：一种地址管理方式，将线性地址按照一定大小（通常是4K）映射到物理地址。这个映射往往是乱序的。</li>
<li>页表（Page Table）：管理线性地址到物理地址的映射关系的数据结构。</li>
<li>页帧（Page Frame）：物理内存中的页大小的连续区域。</li>
<li>页表基址寄存器：用来存储页表的地址基址，是一个控制寄存器（Control Register，CR），即CR3。</li>
<li>页表条目：包含页或下一级页表的基址，以及访问权限等信息。</li>
</ul>
<p>长模式下的页表分为4级，每级512个条目，每个条目8字节，每个页表恰好占用4K。页表基址寄存器指向最顶级页表的<strong>物理</strong>地址基址。</p>
<h4 id="6-系统寄存器"><a href="#6-系统寄存器" class="headerlink" title="6.系统寄存器"></a>6.系统寄存器</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-git%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-git%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">软件构造-git和软件版本管理</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-26 23:54:03" itemprop="dateCreated datePublished" datetime="2023-05-26T23:54:03+08:00">2023-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-27 02:51:00" itemprop="dateModified" datetime="2023-05-27T02:51:00+08:00">2023-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GIT的项目结构"><a href="#GIT的项目结构" class="headerlink" title="GIT的项目结构"></a>GIT的项目结构</h2><p>git的项目由工作区&#x2F;暂存区&#x2F;本地仓库&#x2F;远程仓库几部分组成, 各部分之间通过下列指令进行文件的传输.<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-git%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git.png" alt="git"></p>
<p>git内部将commit表示为一张图,每个commit都指向它的父commit.一个commit可以有0个(最初的commit),1个(一般情况),2个(merge)父commit,同样一个commit也可以由0个(最后的commit),1个(一般情况),2个(branch分叉点)子commit</p>
<p><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-git%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/commit.png" alt="commit"></p>
<p>一个分支就是一个指向某个commit的指针,HEAD指向当前分支,当commit时,HEAD指向新的commit,分支指针不变.一个分支指针总是指向当前分支的最新提交,合并后,被合并的分支不再继续”前进”,除非它又进行了新的提交.</p>
<p>git是以文件为单位进行存储的,而是以文件为单位进行存储的,不同的文件存储一份,如果之后不发生改变,就不在下一个commit中存储,而是直接指向之前的文件记录.</p>
<p><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-git%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/file.png" alt="file"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">软件构造-软件构造的模型</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-26 23:20:57 / 修改时间：23:53:00" itemprop="dateCreated datePublished" datetime="2023-05-26T23:20:57+08:00">2023-05-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="软件构造的传统模型及其阶段"><a href="#软件构造的传统模型及其阶段" class="headerlink" title="软件构造的传统模型及其阶段"></a>软件构造的传统模型及其阶段</h2><p>软件构造的模型，就是指对软件构造的流程的一个抽象概括。每个模型包含许多阶段，各阶段完成一定的任务，按照模型的顺序进行各阶段的任务，就能推进软件的构造，实现软件的开发和维护。</p>
<h3 id="瀑布过程"><a href="#瀑布过程" class="headerlink" title="瀑布过程"></a>瀑布过程</h3><p>瀑布模型是一种线性模型，不进行迭代。按照需求-设计-实现-验证-维护5各阶段一次推进，管理简单，但难以适应需求变化。</p>
<p><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/2023-05-26-23-23-17.png" alt="waterfall"></p>
<h3 id="增量过程"><a href="#增量过程" class="headerlink" title="增量过程"></a>增量过程</h3><p>增量过程是一种线性模型，它同样不进行迭代，但是通过将原先的“大瀑布”拆分成数个“小瀑布”，逐步地完成软件开发，增强了对变化需求的支持性。增量开发的五个阶段分别是沟通、计划、模型化、构建、部署。</p>
<p><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/incremental.png" alt="incremental"></p>
<h3 id="V字模型"><a href="#V字模型" class="headerlink" title="V字模型"></a>V字模型</h3><p>V字模型可以被视为是瀑布模型的一种扩展，它不是线性结构，而是在完成逐级构建之后，又通过逐步测试“上升”到开发阶段。V字模型突出了测试阶段和开发阶段的一一对应关系。V字模型的左侧是项目定义阶段，包含操作概念界定、需求和架构分析、细节设计。底部是代码实现。右侧是测试和集成阶段，包括集成与测试、系统验证、操作和维护。<br>V字模型从左到右是时间上的逐步完善，从下到上是设计上的逐步抽象。当进行到最右上时，经由反馈，重新回到最左上。<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/VModel.png" alt="VModel"></p>
<h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>原型模型包括分析、原型实现、设计、实现、测试、维护6个阶段，在瀑布中加入了一个原型阶段，该阶段将反复根据客户的需求进行迭代。<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/proto.png" alt="proto"></p>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型是瀑布阶段和原型模式的结合，在一次螺旋中完成一个瀑布，产出一个原型，然后经过对原型的测试进入下一个阶段。螺旋模型的四个阶段分别是需求分析、风险分析、开发和测试、计划下一次迭代。<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/spiral.png" alt="spiral"></p>
<h2 id="敏捷开发与极限编程"><a href="#敏捷开发与极限编程" class="headerlink" title="敏捷开发与极限编程"></a>敏捷开发与极限编程</h2><p>敏捷开发就是指通过快速迭代和小规模增量以快速适应变化，一次敏捷开发的迭代持续1~4周，进行迭代计划、测试和增量开发、迭代评审、迭代回顾、更新产品活动。<br>敏捷开发的核心是迭代和反馈，迭代是指在一次迭代中完成一次小规模的增量开发，反馈是指在迭代过程中，通过评审和回顾，及时发现问题，及时进行调整。<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/agile.png" alt="agile"></p>
<p>极限编程包括极限的用户参与，极限的小步迭代，极限的测试与验证。概括来说，就是对敏捷开发思想的提炼。<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9A%84%E6%A8%A1%E5%9E%8B/XP.png" alt="XP"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-3%E7%BB%B4%E5%BA%A68%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%BD%AF%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%90%86%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-3%E7%BB%B4%E5%BA%A68%E8%A7%86%E5%9B%BE%E5%8F%8A%E8%BD%AF%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%90%86%E5%BF%B5/" class="post-title-link" itemprop="url">软件构造-3维度8视图及软构基本理念</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-26 22:37:03 / 修改时间：23:17:19" itemprop="dateCreated datePublished" datetime="2023-05-26T22:37:03+08:00">2023-05-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="软件三维度八视图"><a href="#软件三维度八视图" class="headerlink" title="软件三维度八视图"></a>软件三维度八视图</h2><p>软件描述的三个维度分别是：Code&#x2F;Component, Run-time&#x2F;Build-time, Moment&#x2F;Period<br>分别对应于空间、时间、状态。从局部代码的角度来看能看到软件的内容，从整体组件的角度来看能看到代码的结构。一个软件可以是静态的程序，也可以是动态的应用。一个软件具有某一时刻的状态，在一段时间内具有一定的行为模式，这就构成了基本的三个维度。</p>
<!-- 表格-->
<table>
<!-- 第一行 -->
<tr>
    <td rowspan="2"></td>
    <td colspan="2">Period</td>
    <td colspan="2">Moment</td>
</tr>
<!-- 第二行 -->
<tr>
    <td>Code</td>
    <td>Component</td>
    <td>Code</td>
    <td>Component</td>
</tr>
<!-- 第三行 -->
<tr>
    <td>Build-time</td>
    <td>Source code, AST</td>
    <td>Package, File, Test case, Build Script</td>
    <td>Code Churn</td>
    <td>Configuration Item, Version</td>
</tr>
<!-- 第四行 -->
<tr>
    <td rowspan="2">Run-time</td>
    <td rowspan="2">Code Snap, Memory</td>
    <td rowspan="2">Package, Dynamic Linking, Network, Hardware</td>
    <td >Execution Trace, Multi-Thread</td>
    <td >Event log, Multi-Process</td>
</tr>
<!-- 第五行 -->
<tr>
    <td colspan="2">Sequence Diagram</td>
</tr>
</table>

<h2 id="各象限的内容浅析"><a href="#各象限的内容浅析" class="headerlink" title="各象限的内容浅析"></a>各象限的内容浅析</h2><h3 id="构建时，代码视角，时间点：源码、AST、语意"><a href="#构建时，代码视角，时间点：源码、AST、语意" class="headerlink" title="构建时，代码视角，时间点：源码、AST、语意"></a>构建时，代码视角，时间点：源码、AST、语意</h3><p>代码是程序的最基本内容，一个代码经过词法分析和语法分析得到抽象语法树，进而对应某种机器的形式化操作。而原始的源代码对应的功能，即语意，则是程序员希望达到的目标。</p>
<h3 id="构建时，组件视角，时间段：包、文件、测试用例、构建脚本"><a href="#构建时，组件视角，时间段：包、文件、测试用例、构建脚本" class="headerlink" title="构建时，组件视角，时间段：包、文件、测试用例、构建脚本"></a>构建时，组件视角，时间段：包、文件、测试用例、构建脚本</h3><p>一个程序要想构建起来，仅有源代码是不够的。程序必须按照一定的规则组织成包、模块、编译单元等编译系统支持的结构，配合依赖的库文件，经过构建脚本的处理，才能得到可执行的程序。静态链接和运行测试用例也是在构建时进行的。</p>
<h3 id="构建时，代码视角，时间段：代码变更"><a href="#构建时，代码视角，时间段：代码变更" class="headerlink" title="构建时，代码视角，时间段：代码变更"></a>构建时，代码视角，时间段：代码变更</h3><p>代码变更是以行为单位的增、删、改，是代码的最小变更单位。代码变更的频率和代码的质量有很大的关系，代码变更的频率越高，说明代码的质量相对较差，需要不断的改bug或改需求。</p>
<h3 id="构建时，组件视角，时间段：配置项、版本"><a href="#构建时，组件视角，时间段：配置项、版本" class="headerlink" title="构建时，组件视角，时间段：配置项、版本"></a>构建时，组件视角，时间段：配置项、版本</h3><p>软件配置项是更宏观的软件管理单位，例如Git将文件作为软件配置项。软件版本则是特定时间下所有软件配置项的综合体，是软件的一个快照。软件版本管理通过记录软件配置项的变更，并维护软件版本中的软件配置项的内容，来实现记录软件开发的历史。</p>
<h3 id="运行时，代码视角，时间点：代码快照、内存"><a href="#运行时，代码视角，时间点：代码快照、内存" class="headerlink" title="运行时，代码视角，时间点：代码快照、内存"></a>运行时，代码视角，时间点：代码快照、内存</h3><p>运行时的代码快照图是对代码当前引用和对象内容的一个抽象展示，体现出引用和对象是否可变，包含哪些内容，经历过哪些变化。内存则包含代码运行时的具体数据。</p>
<h3 id="运行时，组件视角，时间段：包、动态链接、网络、硬件"><a href="#运行时，组件视角，时间段：包、动态链接、网络、硬件" class="headerlink" title="运行时，组件视角，时间段：包、动态链接、网络、硬件"></a>运行时，组件视角，时间段：包、动态链接、网络、硬件</h3><p>部署图展示了软件在运行时如何进行机器间的业务交互，通常是展示了包含网络通讯和远程服务的情况下，各中间节点机器的OS、软件支持、代码模块、代码逻辑，以及他们之间的数据链路。</p>
<h3 id="运行时，代码视角，时间段：栈追踪、多线程"><a href="#运行时，代码视角，时间段：栈追踪、多线程" class="headerlink" title="运行时，代码视角，时间段：栈追踪、多线程"></a>运行时，代码视角，时间段：栈追踪、多线程</h3><p>代码中的调用栈信息可以展示出代码是如何一步步地进入当前函数的，常用于调试。</p>
<h3 id="运行时，模块视角，时间段：事件日志、多进程"><a href="#运行时，模块视角，时间段：事件日志、多进程" class="headerlink" title="运行时，模块视角，时间段：事件日志、多进程"></a>运行时，模块视角，时间段：事件日志、多进程</h3><p>事件日志提供了宏观视角下的软件运行情况，可以用于分析软件的性能瓶颈和问题原因。</p>
<h2 id="软件构造的阶段"><a href="#软件构造的阶段" class="headerlink" title="软件构造的阶段"></a>软件构造的阶段</h2><p>1.从无到代码：程序员设计代码<br>2.从代码到模块：程序员设计软件结构<br>3.从构建到运行：程序员将软件部署在设备上<br>4.从时间点到时间段：运行软件，获取结果和日志</p>
<h2 id="软件设计的五个核心维度"><a href="#软件设计的五个核心维度" class="headerlink" title="软件设计的五个核心维度"></a>软件设计的五个核心维度</h2><p>核心：</p>
<ul>
<li><p>避免错误</p>
</li>
<li><p>易于理解</p>
</li>
<li><p>便于修改</p>
</li>
<li><p>其余：</p>
</li>
<li><p>高效开发</p>
</li>
<li><p>高效运行</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-OOP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%85%B3%E8%81%94-%E4%BE%9D%E8%B5%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-OOP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%85%B3%E8%81%94-%E4%BE%9D%E8%B5%96/" class="post-title-link" itemprop="url">软件构造-OOP中类的关系关联/依赖</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-26 20:53:43 / 修改时间：21:10:25" itemprop="dateCreated datePublished" datetime="2023-05-26T20:53:43+08:00">2023-05-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OOP中对象的关系"><a href="#OOP中对象的关系" class="headerlink" title="OOP中对象的关系"></a>OOP中对象的关系</h2><p>在面向对象编程（Object-Oriented Programming，OOP）中，”delegation”（委托）、”association”（关联）、”composition”（组合）和”aggregation”（聚合）是几个重要的概念，用于描述对象之间的关系。</p>
<p>委托（Delegation, A uses B）：<br>委托是一种对象之间的关系，其中一个对象将某些任务委托给另一个对象来完成。在委托关系中，一个对象将一部分功能交给另一个对象处理，通过委托可以实现代码的复用和模块化。委托关系通常是动态的，可以在运行时进行修改。</p>
<p>依赖关系（Dependency, A uses B）:<br>依赖关系表示A的某些方法依赖于B的行为。在使用依赖实现的委托中，A接受一个B类型的参数，并将行为委托给B：<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-OOP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%85%B3%E8%81%94-%E4%BE%9D%E8%B5%96/2023-05-26-21-09-27.png"></p>
<p>关联（Association, A has B）：<br>关联是对象之间的一种关系，表示对象之间的连接或联系。关联关系可以是单向或双向的，可以是一对一、一对多或多对多的。关联关系通常用于描述对象之间的交互关系。<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-OOP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%85%B3%E8%81%94-%E4%BE%9D%E8%B5%96/2023-05-26-21-07-02.png" alt="ass"></p>
<p>组合（Composition, B is part of A）：<br>组合是一种强关联的关系，表示一个对象是由其他对象组成的整体，对象之间具有“整体-部分”的关系。在组合关系中，部分对象无法独立存在，它们的生命周期与整体对象相互依赖。如果整体对象被销毁，部分对象也会被销毁。<br>通常表现为静态初始化的字段, 不可通过外部方法更改.<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-OOP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%85%B3%E8%81%94-%E4%BE%9D%E8%B5%96/2023-05-26-21-02-43.png" alt="comp"></p>
<p>聚合（Aggregation, A owns B）：<br>聚合是一种弱关联的关系，表示一个对象包含其他对象，但被包含对象可以独立存在。聚合关系中，包含对象与被包含对象之间没有强依赖关系，被包含对象可以从一个包含对象中脱离出来，继续存在。聚合关系通常用于表示整体与部分之间的关系，但部分对象的生命周期不受整体对象控制。<br>通常表现为动态初始化的字段, 可通过外部方法更改.<br><img src="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-OOP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%85%B3%E8%81%94-%E4%BE%9D%E8%B5%96/2023-05-26-21-02-16.png" alt="agg"></p>
<h2 id="委托-x2F-关联-x2F-依赖的关系"><a href="#委托-x2F-关联-x2F-依赖的关系" class="headerlink" title="委托&#x2F;关联&#x2F;依赖的关系"></a>委托&#x2F;关联&#x2F;依赖的关系</h2><ul>
<li>委托和关联&#x2F;依赖的关系:在委托（Delegation）中，一个对象（委托者）将任务的执行委托给另一个对象（委托对象）。<br>  委托对象负责执行特定的任务，而委托者可以通过调用委托对象的方法来触发任务的执行。在这种情况下，委托者需要持有委托对象的引用，以便能够调用其方法。这种关联关系要么通过<br>  参数传递来实现, 通过字段（属性）保存委托对象的引用来实现。<br>  前者构成依赖关系,后者构成关联关系</li>
<li>关联和聚合&#x2F;组合的关系: 组合和聚合是关联的两种具体形式<br>  组合是一种比聚合更强的关系，它表示整体对象包含部分对象，并且部分对象无法独立存在。<br>  聚合是一种弱关系，表示整体对象包含部分对象，但部分对象可以独立存在。</li>
</ul>
<h2 id="小结和讨论"><a href="#小结和讨论" class="headerlink" title="小结和讨论"></a>小结和讨论</h2><p>综上所述:</p>
<ul>
<li>委托是一种设计模式, 将任务的执行委托给另一个对象.</li>
<li>通过参数进行的委托使类之间存在依赖关系.</li>
<li>通过引用进行的委托使类之间存在关联关系.<ul>
<li>组合是一种强关系，同生共死, 通常在构造函数中创建,在析构函数中销毁</li>
<li>聚合是一种弱关系, 仅持有引用. 通常在外部创建,通过调用public方法保存到rep里,在外部某处销毁.</li>
</ul>
</li>
</ul>
<p>讨论:</p>
<ul>
<li>委托关系的强弱? 依赖 &lt; 聚合 &lt; 关联 &lt; 组合, 越强, 越不容易修改, 越发生在类的内部. 反之, 则容易修改, 并且可以发生在类的外部.<br>所以依赖关系是最方便修改的, 组合关系是最难修改的.</li>
<li>临时委托VS永久委托？ 依赖关系的委托是临时的，因为没有任何信息记录委托对象。而关联关系的委托是永久的，因为委托对象通过字段的形式保存了下来。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%80%81-Java%E5%92%8CC%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B.md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%80%81-Java%E5%92%8CC%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B.md/" class="post-title-link" itemprop="url">软件构造-关于多态-Java和C++中的子类与泛型</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-26 16:43:59 / 修改时间：17:00:58" itemprop="dateCreated datePublished" datetime="2023-05-26T16:43:59+08:00">2023-05-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态指的是同一个接口可以在不同的条件下表现出不同的行为。多态通常包括三种形式：参数多态（重载、可变参数）、子类多态（重写）、泛型多态（泛型类、模板类）。<br>参数多态指的是一个函数可以接受不同类型的参数并做出对应的反应，在OOP语言中，这通常通过称之为“重载（overload）”的技术实现，该技术会为函数生成一个包含参数信息的签名（这个过程称之为mangle），然后在编译或解释时，根据参数信息在已存在的签名中进行匹配，如果匹配到合适的函数，就进行调用，否则就是一个编译错误。<br>子类多态指的是一个子类可以使用和父类同名的方法，但是执行与父类不同的行为。这是通过称之为重写（override）的技术实现的，在子类上调用函数时，编译器或解释器优先选择子类的函数执行，而非父类。一个更常见的用法是用一个父类或抽象类引用存储一个对象，然后调用他的某个方法。该方法会在不同的具体类型上进行不同的操作。<br>泛型多态指的是某种算法、操作、数据结构可以应用在不同的类型上，这通常是使用泛型类的技术实现的，泛型类接收一个类型参数，并对参数做某种限制（比如要求它必须是可比较的），使用这个类型参数声明一些方法或变量，以实现针对任意满足条件的类型进行相同的操作。<br>下面我们就来看看Java和C++的具体技术。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>java和C++的重载都是通过在编译时进行mangle并解析函数调用完成的。不同的是，C++中的函数声明具有类作用域，换言之，子类不能重载父类的方法。这被称之为“覆盖”。如果子类声明了一个和父类名称相同但参数不同的方法，将不能通过子类调用父类的该方法。解决方法是使用using关键字将父类方法的在子类作用域内声明，这样处于同一个作用域的方法就可以构成重载关系了。<br>而在Java中，子类可以重载父类型的方法，无需特殊操作，也不会覆盖父类型方法。</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>java和C++都支持子类任意的重写父类型的方法，并且都要求返回协变的类型，都不支持逆协变参数的解析。不过这里有一个微妙的区别：动态绑定和静态绑定。在C++中，使用父类引用调用方法并不会自动的调用子类方法。只有使用子类引用才能访问子类的方法。解决办法是给函数增加virtual关键字，这将让编译器生成一张虚函数表。在调用时，在虚函数表中访问对应的函数指针进行调用，子类的虚函数比父类优先级更高，因此如果子类重写了方法，就会调用子类的方法。这被称之为“动态绑定”。<br>在Java中，会自动进行动态绑定。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>java使用类型擦除的技术实现泛型，即生成一个泛型类，在类内将所有泛型参数转换为Object类型（或规定的父类）。而C++的模板使用展开替换技术实现泛型，即生成许多模板特化，针对不同的类型调用不同的模板。对于Java而言，一个原始的泛型（没有类型参数的泛型）和所有的泛型实例化都具有相同的类型。而对于C++而言，未特化的模板和全特化的模板是完全不同的类型。<br>为了在C++中能实现泛型多态，即java中List&lt;?&gt;这样的操作，可以让模板类继承一个普通类。由于所有模板类的特化都会继承这个普通类，就可以用这个普通类的引用访问任何模板类了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/" class="post-title-link" itemprop="url">软件构造-李氏原则漫谈"</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 16:19:20" itemprop="dateCreated datePublished" datetime="2023-04-26T16:19:20+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 16:42:12" itemprop="dateModified" datetime="2023-05-26T16:42:12+08:00">2023-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="李氏原则"><a href="#李氏原则" class="headerlink" title="李氏原则"></a>李氏原则</h2><p>李氏原则的核心思想就是：所有父类出现的地方，子类都可以出现。<br>在解释这句话的含义之前，我想请读者回忆一下C标准中的类似表述：一个整形表达式可以出现在任何整形字面量可以出现的地方。可以说，这种表述就是定义了行为的完全兼容性。<br>这句话的含义有五个方面：</p>
<p><img src="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/2023-05-26-16-32-35.png" alt="1"></p>
<p>概括来说，就是规定了子类型的函数规约和函数签名应当满足的条件。函数规约应该保持或加强，而函数签名应该兼容。<br>具体而言，子类型的返回值应当是父类型返回值的子类，子类型的参数应当是父类型的参数的父类，子类型不应抛出新的必检异常，可以抛出原先的必检异常及其子类。下面是Java对于重写的语法要求：</p>
<p><img src="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/2023-05-26-16-30-52.png" alt="2"></p>
<p>可以看到，基本的思路是一致的，不过由于java中不同的函数签名被视为不同的函数，所以“参数逆协变”的行为子类重写被视为重载。也是因为如此，java不会检查子类方法是逆协变的还是协变的。但为了编写一个行为子类，我们需要手动的保证这点。</p>
<p><img src="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/2023-05-26-16-41-55.png" alt="3"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/22/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B22-%E8%BF%9B%E9%98%B6%E4%BD%93%E4%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B22-%E8%BF%9B%E9%98%B6%E4%BD%93%E4%BC%9A/" class="post-title-link" itemprop="url">软件构造-关于表示泄露2-进阶体会</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 17:45:55" itemprop="dateCreated datePublished" datetime="2023-03-22T17:45:55+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 16:39:08" itemprop="dateModified" datetime="2023-05-26T16:39:08+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们上次讨论了关于表示泄露的三种基本形式：访问权限、getter传递引用、constructor接收引用，这次来讨论更加细节的内容</p>
<blockquote>
<p>原创性声明：每一个字都是我手敲的。</p>
</blockquote>
</blockquote>
<h2 id="更加间接的表示泄露-来自浅拷贝"><a href="#更加间接的表示泄露-来自浅拷贝" class="headerlink" title="更加间接的表示泄露-来自浅拷贝"></a>更加间接的表示泄露-来自浅拷贝</h2><p>我们对一个引用类型（对象）进行拷贝时，有三种做法。</p>
<ol>
<li>引用拷贝， 通常通过<code>=</code>运算符实现。两个引用变量将指向同一个内存地址。</li>
<li>浅拷贝，一些方法提供了浅拷贝。我们把一个对象的<strong>字段值</strong>全部拷贝到另一个对象里，然后把这个对象的引用赋值给新的引用</li>
<li>深拷贝，一些方法提供了深拷贝，通常需要手动实现。对于基本数据类型字段，我们把值拷贝到另一个对象；对于引用类型字段，我们<br>把这个字段深拷贝到另一个对象的这个字段中，最后把新的对象的引用赋值给新的引用。</li>
</ol>
<p>这三个概念有些抽象，我们必须结合一些例子来进行讲解。但是我们可以先注意一点：引用拷贝是一次赋值，浅拷贝对字段遍历赋值，深拷贝是对字段递归地赋值。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36828822/article/details/129692916#:~:text=%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%98%AF%E7%9B%B4%E6%8E%A5,%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%82">参考这篇文章</a></p>
<p>如果防御性拷贝只是浅拷贝，那么依然存在风险，考虑如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">qaq</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;waw&gt; a = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; </span><br><span class="line">    qaq(Stirng name)&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(waw w)</span></span>&#123;a.add(w);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;waw&gt; <span class="title">getA</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;waw&gt;(a);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">waw</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> label;</span><br><span class="line">    waw(<span class="keyword">int</span> label)&#123;<span class="keyword">this</span>.label = label;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(<span class="keyword">int</span> label)</span></span>&#123;<span class="keyword">this</span>.label = label;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和如下的客户端程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    qaq q = <span class="keyword">new</span> qaq(<span class="string">&quot;qaq&quot;</span>);</span><br><span class="line">    q.add(<span class="keyword">new</span> waw(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//浅拷贝</span></span><br><span class="line">    qaq.getA().get(<span class="number">0</span>).setLabel(<span class="number">2</span>);</span><br><span class="line">    System.out.println(qaq.getA().get(<span class="number">0</span>).getLabel())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，q中的a字段的第零个元素的label还会是1嘛？答案是否定的。<br>究其原因，是因为 qaq.getA()返回的是对LinkedList类型的浅拷贝，这个类型中存放的内容是waw，一个可变引用类型。<br>因此，当我们对浅拷贝（对应<code>qaq.getA()</code>）调用getter（对应<code>get</code>）获取一个可变引用，再对这个引用调用mutator（对应<code>setLabel</code>）<br>时，就会把拷贝的母本中的对象也修改！<br>再次体会一下这个逻辑：母本中的内容是一个引用，我们通过浅拷贝获取了这个引用，修改了引用对应的对象，于是母本的内容虽然没有改变，但是母本的内容指向的对象却发生了改变。<br>这已经很抽象了！为了避免这个方法，对于任何可变类型的List，Map等，在拷贝时要特别注意深浅。如果是List<String>，可以不用深拷贝，因为即使浅拷贝获得了母本的内容，也不能通过这个内容修改对象的值。</p>
<h2 id="一些探讨-public-final会导致rep-exposure吗？"><a href="#一些探讨-public-final会导致rep-exposure吗？" class="headerlink" title="一些探讨-public final会导致rep exposure吗？"></a>一些探讨-public final会导致rep exposure吗？</h2><p>MIT的课件中说表示泄露“meaning that code outside the class can modify the representation directly.”，<br>不过我认为这是不准确的，即使不能修改ADT的表示，而仅仅能够获取ADT的内部结构，客户端也足以让ADT的抽象性泄露。<br>我们考虑下面这个数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Represents an immutable right triangle. */</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">RightTriangle</span> </span>&#123;</span><br><span class="line"><span class="comment">/*A*/</span>     <span class="keyword">private</span> <span class="keyword">double</span>[] sides;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// sides[0] and sides[1] are the two legs,</span></span><br><span class="line">          <span class="comment">// and sides[2] is the hypotenuse, so declare it to avoid having a</span></span><br><span class="line">          <span class="comment">// magic number in the code:</span></span><br><span class="line"><span class="comment">/*B*/</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HYPOTENUSE = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，HYPOTENUSE被定义为是public static final int，因此它是作为一个不可变类属性。然而，其访问权限是public，这<br>意味着用户将有可能使用这个特殊的成员。比如说，编写一些依赖于HYPOTENUSE的代码，而一旦这个值改变，那么这些代码都需要进行修改！<br>要注意，“斜边存储在边数组的哪个位置”完全不是这个ADT应该暴露出来的东西，因此，尽管它是不可被修改的，但是它依然会导致表示泄露。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/16/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B21-%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/16/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B21-%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">软件构造-关于表示泄露1-基本内容</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-16 22:12:17" itemprop="dateCreated datePublished" datetime="2023-03-16T22:12:17+08:00">2023-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 17:19:31" itemprop="dateModified" datetime="2023-05-26T17:19:31+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们将讨论表示泄露的几种情况，以及如何防止表示泄露<br>原创性声明：每一个字（除了代码和引用）都是我手敲的。</p>
</blockquote>
<h2 id="表示泄露的定义"><a href="#表示泄露的定义" class="headerlink" title="表示泄露的定义"></a>表示泄露的定义</h2><p>表示泄露，即Representation Exposure，指的是client端程序可以通过某种手段<br>查询、访问、修改ADT的<strong>内部结构</strong>。<br>我们将通过一些例子来感受这个定义。</p>
<h2 id="最基本的表示泄露-来自访问权限"><a href="#最基本的表示泄露-来自访问权限" class="headerlink" title="最基本的表示泄露-来自访问权限"></a>最基本的表示泄露-来自访问权限</h2><p>在java的设计中，一个字段的访问权限有四种。<br><img src="/2023/03/16/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B21-%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/2023-03-22-16-57-49.png" alt="访问权限"><br>为了避免表示泄露，<strong>如果一个字段可以是private，那么它就应当是private</strong>。<br>下面我们来看一个因为访问权限导致表示泄露的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This immutable data type represents a tweet from Twitter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String author;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line">    <span class="keyword">public</span> Date timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make a Tweet.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个结构，我们在创建之后可以任意访问修改它的字段，因为字段被声明为public：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tweet t = <span class="keyword">new</span> Tweet(<span class="string">&quot;justinbieber&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;Thanks to all those beliebers out there inspiring me every day&quot;</span>, </span><br><span class="line">                    <span class="keyword">new</span> Date());</span><br><span class="line">t.author = <span class="string">&quot;rbmllr&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>你可能会想：为什么改变一个对象的字段被认为是一种“泄露”呢？我们从软件构造的3个角度来回答:</p>
<ol>
<li>safe from bug: 通过赋值改变一个字段可能会导致错误，例如赋值不匹配的类型或无意义的类型。</li>
<li>esay to understand： 赋值一个字段的行为可能是令人困惑的，尤其是当各个字段的含义并不是那么清楚的时候。</li>
<li>ready for change：一旦对象的内部表示发生变化，所有的赋值都必须手动重写。如果用方法进行赋值，则可以很方便的重构。</li>
</ol>
<p>此外，随意修改变量使得我们不能构造“immutable”的对象，这将让我们的程序充满了危险，我们不得不非常小心的应对每一次方法调用，<br>我们不知道返回之后的对象是否保持它原来的样子，这真是太可怕了！（译制腔）</p>
<p>为此，一个常见的方法是将所有字段声明为private， 并且如果要构建immutable对象的话，声明为private final.</p>
<h2 id="稍微间接一点的表示泄露-来自传递引用"><a href="#稍微间接一点的表示泄露-来自传递引用" class="headerlink" title="稍微间接一点的表示泄露-来自传递引用"></a>稍微间接一点的表示泄露-来自传递引用</h2><p>当我们把所有字段设置为私有，你可能松了口气：现在我的数据类型是安全的了。但还没结束——客户端总是需要了解ADT的“属性”，除非<br>这个ADT是一个纯粹的功能类（比如Math）。既然如此，我们必须为客户端服务，把ADT的内部表示转换为客户端感兴趣的属性。大部分情况下，属性和内部表示的对应关系是比较简单的，例如我们为Tweet类型增加获取作者、内容、发送时间的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> Twitter user who wrote the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> text of the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> date/time when the tweet was sent */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去没什么问题，客户端不能直接访问我们的内部表示，因此如果我们要修改内部表示，例如把text分为title和content，我们只需要重写getText，比如返回title + content，而无需客户端做任何改动。</p>
<p>但是还存在这样的一种情况：客户端拿到了这个属性之后，又修改了这个属性，这会发生什么呢？<br>考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a tweet that retweets t, one hour later*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tweet <span class="title">retweetLater</span><span class="params">(Tweet t)</span> </span>&#123;</span><br><span class="line">    Date d = t.getTimestamp();</span><br><span class="line">    d.setHours(d.getHours()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tweet(<span class="string">&quot;rbmllr&quot;</span>, t.getText(), d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端获取了发推时间后，把时间加了一个小时，又用这个时间创建了新的Tweet。这里的<code>d</code>是通过<code>getTimestamp()</code>获得的，而在d上调用了<br><code>setHours()</code>方法将会改变d的值！因此结果是，t和新创建的Tweet现在都指向了一小时后的时间。<br><img src="/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-17-14-39.png" alt="表示泄露-来自传递引用"><br>这个例子中，我们的getter传递了一个引用类型<code>Date</code>，一个可变数据类型。因此，在引用d上调用mutator导致了表示泄露。<br>我们该怎样修改这个代码？通过一种称之为“防御性拷贝”的方式，创建引用的一个副本。这样对返回值的修改便不会影响到对象本身。具体来讲：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就避免了getter（observor的一种）造成的访问泄露。对于所有的observor方法（返回值非空），我们都需要做如下的检查：只要返回的值不是基本数据类型，并且是可变数据类型，那么就要进行防御式拷贝。反之，如果返回值是基本数据类型或者是不可边类型，则可以直接返回。</p>
<h2 id="稍微间接一点的表示泄露-来自接收引用"><a href="#稍微间接一点的表示泄露-来自接收引用" class="headerlink" title="稍微间接一点的表示泄露-来自接收引用"></a>稍微间接一点的表示泄露-来自接收引用</h2><p>引用类型始终是危险的：ADT内部的引用类型也可能被外部的客户端程序持有，这时一旦外部引用调用了mutator，ADT的内部表示也将同步发生变化。我们来看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a list of 24 inspiring tweets, one per hour today */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Tweet&gt; <span class="title">tweetEveryHourToday</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Tweet&gt; list = <span class="keyword">new</span> ArrayList&lt;Tweet&gt;(); </span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">        date.setHours(i);</span><br><span class="line">        list.add(<span class="keyword">new</span> Tweet(<span class="string">&quot;rbmllr&quot;</span>, <span class="string">&quot;keep it up! you can do it&quot;</span>, date));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们试图创建24个Tweet，间隔1小时。然而，我们的构造器方法会直接将时间戳赋值给内部属性，因此当我们在循环中调用<code>setHours</code>时，所有Tweet内部的timestamp都将同步变化。最终，我们得到了24个时间相同的Tweet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a Tweet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-17-21-50.png" alt="表示泄露-接收引用"></p>
<p>为此，我们在接收引用时也要使用防御式拷贝。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，对基本数据类型和不可边数据类型，如String，不需要进行防御式拷贝。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是MIT课件中关于表示泄露的内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="辉夜"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">辉夜</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">辉夜</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
