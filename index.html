<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huiyeruzhou.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="辉夜的博客">
<meta property="og:url" content="http://huiyeruzhou.github.io/index.html">
<meta property="og:site_name" content="辉夜的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="辉夜">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://huiyeruzhou.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>辉夜的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">辉夜的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">繁花似锦，辉夜如昼</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/08/%E5%85%AC%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E5%85%AC%E5%91%8A/" class="post-title-link" itemprop="url">公告</a>
        </h2>

        <div class="post-meta">
          
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-08 22:27:25" itemprop="dateCreated datePublished" datetime="2023-03-08T22:27:25+08:00">2023-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 16:39:46" itemprop="dateModified" datetime="2023-05-26T16:39:46+08:00">2023-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一条置顶公告。<br>如果要查阅专门为软件构造课程写的博客，请点击“标签”并在其中选择 <code>#软件构造</code>。<br>我强烈推荐您阅读“关于表示泄露-2”，这篇文章描述了浅拷贝和public final字段造成的表示泄露，是很微妙的细节。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%80%81-Java%E5%92%8CC%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B.md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%80%81-Java%E5%92%8CC%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E4%B8%8E%E6%B3%9B%E5%9E%8B.md/" class="post-title-link" itemprop="url">软件构造-关于多态-Java和C++中的子类与泛型</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-26 16:43:59 / 修改时间：17:00:58" itemprop="dateCreated datePublished" datetime="2023-05-26T16:43:59+08:00">2023-05-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态指的是同一个接口可以在不同的条件下表现出不同的行为。多态通常包括三种形式：参数多态（重载、可变参数）、子类多态（重写）、泛型多态（泛型类、模板类）。<br>参数多态指的是一个函数可以接受不同类型的参数并做出对应的反应，在OOP语言中，这通常通过称之为“重载（overload）”的技术实现，该技术会为函数生成一个包含参数信息的签名（这个过程称之为mangle），然后在编译或解释时，根据参数信息在已存在的签名中进行匹配，如果匹配到合适的函数，就进行调用，否则就是一个编译错误。<br>子类多态指的是一个子类可以使用和父类同名的方法，但是执行与父类不同的行为。这是通过称之为重写（override）的技术实现的，在子类上调用函数时，编译器或解释器优先选择子类的函数执行，而非父类。一个更常见的用法是用一个父类或抽象类引用存储一个对象，然后调用他的某个方法。该方法会在不同的具体类型上进行不同的操作。<br>泛型多态指的是某种算法、操作、数据结构可以应用在不同的类型上，这通常是使用泛型类的技术实现的，泛型类接收一个类型参数，并对参数做某种限制（比如要求它必须是可比较的），使用这个类型参数声明一些方法或变量，以实现针对任意满足条件的类型进行相同的操作。<br>下面我们就来看看Java和C++的具体技术。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>java和C++的重载都是通过在编译时进行mangle并解析函数调用完成的。不同的是，C++中的函数声明具有类作用域，换言之，子类不能重载父类的方法。这被称之为“覆盖”。如果子类声明了一个和父类名称相同但参数不同的方法，将不能通过子类调用父类的该方法。解决方法是使用using关键字将父类方法的在子类作用域内声明，这样处于同一个作用域的方法就可以构成重载关系了。<br>而在Java中，子类可以重载父类型的方法，无需特殊操作，也不会覆盖父类型方法。</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>java和C++都支持子类任意的重写父类型的方法，并且都要求返回协变的类型，都不支持逆协变参数的解析。不过这里有一个微妙的区别：动态绑定和静态绑定。在C++中，使用父类引用调用方法并不会自动的调用子类方法。只有使用子类引用才能访问子类的方法。解决办法是给函数增加virtual关键字，这将让编译器生成一张虚函数表。在调用时，在虚函数表中访问对应的函数指针进行调用，子类的虚函数比父类优先级更高，因此如果子类重写了方法，就会调用子类的方法。这被称之为“动态绑定”。<br>在Java中，会自动进行动态绑定。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>java使用类型擦除的技术实现泛型，即生成一个泛型类，在类内将所有泛型参数转换为Object类型（或规定的父类）。而C++的模板使用展开替换技术实现泛型，即生成许多模板特化，针对不同的类型调用不同的模板。对于Java而言，一个原始的泛型（没有类型参数的泛型）和所有的泛型实例化都具有相同的类型。而对于C++而言，未特化的模板和全特化的模板是完全不同的类型。<br>为了在C++中能实现泛型多态，即java中List&lt;?&gt;这样的操作，可以让模板类继承一个普通类。由于所有模板类的特化都会继承这个普通类，就可以用这个普通类的引用访问任何模板类了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/" class="post-title-link" itemprop="url">软件构造-李氏原则漫谈"</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 16:19:20" itemprop="dateCreated datePublished" datetime="2023-04-26T16:19:20+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 16:42:12" itemprop="dateModified" datetime="2023-05-26T16:42:12+08:00">2023-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="李氏原则"><a href="#李氏原则" class="headerlink" title="李氏原则"></a>李氏原则</h2><p>李氏原则的核心思想就是：所有父类出现的地方，子类都可以出现。<br>在解释这句话的含义之前，我想请读者回忆一下C标准中的类似表述：一个整形表达式可以出现在任何整形字面量可以出现的地方。可以说，这种表述就是定义了行为的完全兼容性。<br>这句话的含义有五个方面：</p>
<p><img src="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/2023-05-26-16-32-35.png" alt="1"></p>
<p>概括来说，就是规定了子类型的函数规约和函数签名应当满足的条件。函数规约应该保持或加强，而函数签名应该兼容。<br>具体而言，子类型的返回值应当是父类型返回值的子类，子类型的参数应当是父类型的参数的父类，子类型不应抛出新的必检异常，可以抛出原先的必检异常及其子类。下面是Java对于重写的语法要求：</p>
<p><img src="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/2023-05-26-16-30-52.png" alt="2"></p>
<p>可以看到，基本的思路是一致的，不过由于java中不同的函数签名被视为不同的函数，所以“参数逆协变”的行为子类重写被视为重载。也是因为如此，java不会检查子类方法是逆协变的还是协变的。但为了编写一个行为子类，我们需要手动的保证这点。</p>
<p><img src="/2023/04/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E6%9D%8E%E6%B0%8F%E5%8E%9F%E5%88%99%E6%BC%AB%E8%B0%88/2023-05-26-16-41-55.png" alt="3"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/22/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B22-%E8%BF%9B%E9%98%B6%E4%BD%93%E4%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B22-%E8%BF%9B%E9%98%B6%E4%BD%93%E4%BC%9A/" class="post-title-link" itemprop="url">软件构造-关于表示泄露2-进阶体会</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 17:45:55" itemprop="dateCreated datePublished" datetime="2023-03-22T17:45:55+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 16:39:08" itemprop="dateModified" datetime="2023-05-26T16:39:08+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们上次讨论了关于表示泄露的三种基本形式：访问权限、getter传递引用、constructor接收引用，这次来讨论更加细节的内容</p>
<blockquote>
<p>原创性声明：每一个字都是我手敲的。</p>
</blockquote>
</blockquote>
<h2 id="更加间接的表示泄露-来自浅拷贝"><a href="#更加间接的表示泄露-来自浅拷贝" class="headerlink" title="更加间接的表示泄露-来自浅拷贝"></a>更加间接的表示泄露-来自浅拷贝</h2><p>我们对一个引用类型（对象）进行拷贝时，有三种做法。</p>
<ol>
<li>引用拷贝， 通常通过<code>=</code>运算符实现。两个引用变量将指向同一个内存地址。</li>
<li>浅拷贝，一些方法提供了浅拷贝。我们把一个对象的<strong>字段值</strong>全部拷贝到另一个对象里，然后把这个对象的引用赋值给新的引用</li>
<li>深拷贝，一些方法提供了深拷贝，通常需要手动实现。对于基本数据类型字段，我们把值拷贝到另一个对象；对于引用类型字段，我们<br>把这个字段深拷贝到另一个对象的这个字段中，最后把新的对象的引用赋值给新的引用。</li>
</ol>
<p>这三个概念有些抽象，我们必须结合一些例子来进行讲解。但是我们可以先注意一点：引用拷贝是一次赋值，浅拷贝对字段遍历赋值，深拷贝是对字段递归地赋值。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36828822/article/details/129692916#:~:text=%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%98%AF%E7%9B%B4%E6%8E%A5,%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%82">参考这篇文章</a></p>
<p>如果防御性拷贝只是浅拷贝，那么依然存在风险，考虑如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">qaq</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;waw&gt; a = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name; </span><br><span class="line">    qaq(Stirng name)&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(waw w)</span></span>&#123;a.add(w);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;waw&gt; <span class="title">getA</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;waw&gt;(a);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">waw</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> label;</span><br><span class="line">    waw(<span class="keyword">int</span> label)&#123;<span class="keyword">this</span>.label = label;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(<span class="keyword">int</span> label)</span></span>&#123;<span class="keyword">this</span>.label = label;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和如下的客户端程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    qaq q = <span class="keyword">new</span> qaq(<span class="string">&quot;qaq&quot;</span>);</span><br><span class="line">    q.add(<span class="keyword">new</span> waw(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//浅拷贝</span></span><br><span class="line">    qaq.getA().get(<span class="number">0</span>).setLabel(<span class="number">2</span>);</span><br><span class="line">    System.out.println(qaq.getA().get(<span class="number">0</span>).getLabel())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，q中的a字段的第零个元素的label还会是1嘛？答案是否定的。<br>究其原因，是因为 qaq.getA()返回的是对LinkedList类型的浅拷贝，这个类型中存放的内容是waw，一个可变引用类型。<br>因此，当我们对浅拷贝（对应<code>qaq.getA()</code>）调用getter（对应<code>get</code>）获取一个可变引用，再对这个引用调用mutator（对应<code>setLabel</code>）<br>时，就会把拷贝的母本中的对象也修改！<br>再次体会一下这个逻辑：母本中的内容是一个引用，我们通过浅拷贝获取了这个引用，修改了引用对应的对象，于是母本的内容虽然没有改变，但是母本的内容指向的对象却发生了改变。<br>这已经很抽象了！为了避免这个方法，对于任何可变类型的List，Map等，在拷贝时要特别注意深浅。如果是List<String>，可以不用深拷贝，因为即使浅拷贝获得了母本的内容，也不能通过这个内容修改对象的值。</p>
<h2 id="一些探讨-public-final会导致rep-exposure吗？"><a href="#一些探讨-public-final会导致rep-exposure吗？" class="headerlink" title="一些探讨-public final会导致rep exposure吗？"></a>一些探讨-public final会导致rep exposure吗？</h2><p>MIT的课件中说表示泄露“meaning that code outside the class can modify the representation directly.”，<br>不过我认为这是不准确的，即使不能修改ADT的表示，而仅仅能够获取ADT的内部结构，客户端也足以让ADT的抽象性泄露。<br>我们考虑下面这个数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Represents an immutable right triangle. */</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">RightTriangle</span> </span>&#123;</span><br><span class="line"><span class="comment">/*A*/</span>     <span class="keyword">private</span> <span class="keyword">double</span>[] sides;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// sides[0] and sides[1] are the two legs,</span></span><br><span class="line">          <span class="comment">// and sides[2] is the hypotenuse, so declare it to avoid having a</span></span><br><span class="line">          <span class="comment">// magic number in the code:</span></span><br><span class="line"><span class="comment">/*B*/</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HYPOTENUSE = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，HYPOTENUSE被定义为是public static final int，因此它是作为一个不可变类属性。然而，其访问权限是public，这<br>意味着用户将有可能使用这个特殊的成员。比如说，编写一些依赖于HYPOTENUSE的代码，而一旦这个值改变，那么这些代码都需要进行修改！<br>要注意，“斜边存储在边数组的哪个位置”完全不是这个ADT应该暴露出来的东西，因此，尽管它是不可被修改的，但是它依然会导致表示泄露。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/16/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B21-%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/16/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B21-%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">软件构造-关于表示泄露1-基本内容</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-16 22:12:17" itemprop="dateCreated datePublished" datetime="2023-03-16T22:12:17+08:00">2023-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-12 22:59:19" itemprop="dateModified" datetime="2023-04-12T22:59:19+08:00">2023-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们将讨论表示泄露的几种情况，以及如何防止表示泄露<br>原创性声明：每一个字（除了代码和引用）都是我手敲的。</p>
</blockquote>
<h2 id="表示泄露的定义"><a href="#表示泄露的定义" class="headerlink" title="表示泄露的定义"></a>表示泄露的定义</h2><p>表示泄露，即Representation Exposure，指的是client端程序可以通过某种手段<br>查询、访问、修改ADT的<strong>内部结构</strong>。<br>我们将通过一些例子来感受这个定义。</p>
<h2 id="最基本的表示泄露-来自访问权限"><a href="#最基本的表示泄露-来自访问权限" class="headerlink" title="最基本的表示泄露-来自访问权限"></a>最基本的表示泄露-来自访问权限</h2><p>在java的设计中，一个字段的访问权限有四种。<br><img src="/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-16-57-49.png" alt="访问权限"><br>为了避免表示泄露，<strong>如果一个字段可以是private，那么它就应当是private</strong>。<br>下面我们来看一个因为访问权限导致表示泄露的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This immutable data type represents a tweet from Twitter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String author;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line">    <span class="keyword">public</span> Date timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make a Tweet.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个结构，我们在创建之后可以任意访问修改它的字段，因为字段被声明为public：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tweet t = <span class="keyword">new</span> Tweet(<span class="string">&quot;justinbieber&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;Thanks to all those beliebers out there inspiring me every day&quot;</span>, </span><br><span class="line">                    <span class="keyword">new</span> Date());</span><br><span class="line">t.author = <span class="string">&quot;rbmllr&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>你可能会想：为什么改变一个对象的字段被认为是一种“泄露”呢？我们从软件构造的3个角度来回答:</p>
<ol>
<li>safe from bug: 通过赋值改变一个字段可能会导致错误，例如赋值不匹配的类型或无意义的类型。</li>
<li>esay to understand： 赋值一个字段的行为可能是令人困惑的，尤其是当各个字段的含义并不是那么清楚的时候。</li>
<li>ready for change：一旦对象的内部表示发生变化，所有的赋值都必须手动重写。如果用方法进行赋值，则可以很方便的重构。</li>
</ol>
<p>此外，随意修改变量使得我们不能构造“immutable”的对象，这将让我们的程序充满了危险，我们不得不非常小心的应对每一次方法调用，<br>我们不知道返回之后的对象是否保持它原来的样子，这真是太可怕了！（译制腔）</p>
<p>为此，一个常见的方法是将所有字段声明为private， 并且如果要构建immutable对象的话，声明为private final.</p>
<h2 id="稍微间接一点的表示泄露-来自传递引用"><a href="#稍微间接一点的表示泄露-来自传递引用" class="headerlink" title="稍微间接一点的表示泄露-来自传递引用"></a>稍微间接一点的表示泄露-来自传递引用</h2><p>当我们把所有字段设置为私有，你可能松了口气：现在我的数据类型是安全的了。但还没结束——客户端总是需要了解ADT的“属性”，除非<br>这个ADT是一个纯粹的功能类（比如Math）。既然如此，我们必须为客户端服务，把ADT的内部表示转换为客户端感兴趣的属性。大部分情况下，属性和内部表示的对应关系是比较简单的，例如我们为Tweet类型增加获取作者、内容、发送时间的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> Twitter user who wrote the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> text of the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> date/time when the tweet was sent */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去没什么问题，客户端不能直接访问我们的内部表示，因此如果我们要修改内部表示，例如把text分为title和content，我们只需要重写getText，比如返回title + content，而无需客户端做任何改动。</p>
<p>但是还存在这样的一种情况：客户端拿到了这个属性之后，又修改了这个属性，这会发生什么呢？<br>考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a tweet that retweets t, one hour later*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tweet <span class="title">retweetLater</span><span class="params">(Tweet t)</span> </span>&#123;</span><br><span class="line">    Date d = t.getTimestamp();</span><br><span class="line">    d.setHours(d.getHours()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tweet(<span class="string">&quot;rbmllr&quot;</span>, t.getText(), d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端获取了发推时间后，把时间加了一个小时，又用这个时间创建了新的Tweet。这里的<code>d</code>是通过<code>getTimestamp()</code>获得的，而在d上调用了<br><code>setHours()</code>方法将会改变d的值！因此结果是，t和新创建的Tweet现在都指向了一小时后的时间。<br><img src="/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-17-14-39.png" alt="表示泄露-来自传递引用"><br>这个例子中，我们的getter传递了一个引用类型<code>Date</code>，一个可变数据类型。因此，在引用d上调用mutator导致了表示泄露。<br>我们该怎样修改这个代码？通过一种称之为“防御性拷贝”的方式，创建引用的一个副本。这样对返回值的修改便不会影响到对象本身。具体来讲：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就避免了getter（observor的一种）造成的访问泄露。对于所有的observor方法（返回值非空），我们都需要做如下的检查：只要返回的值不是基本数据类型，并且是可变数据类型，那么就要进行防御式拷贝。反之，如果返回值是基本数据类型或者是不可边类型，则可以直接返回。</p>
<h2 id="稍微间接一点的表示泄露-来自接收引用"><a href="#稍微间接一点的表示泄露-来自接收引用" class="headerlink" title="稍微间接一点的表示泄露-来自接收引用"></a>稍微间接一点的表示泄露-来自接收引用</h2><p>引用类型始终是危险的：ADT内部的引用类型也可能被外部的客户端程序持有，这时一旦外部引用调用了mutator，ADT的内部表示也将同步发生变化。我们来看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a list of 24 inspiring tweets, one per hour today */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Tweet&gt; <span class="title">tweetEveryHourToday</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Tweet&gt; list = <span class="keyword">new</span> ArrayList&lt;Tweet&gt;(); </span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">        date.setHours(i);</span><br><span class="line">        list.add(<span class="keyword">new</span> Tweet(<span class="string">&quot;rbmllr&quot;</span>, <span class="string">&quot;keep it up! you can do it&quot;</span>, date));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们试图创建24个Tweet，间隔1小时。然而，我们的构造器方法会直接将时间戳赋值给内部属性，因此当我们在循环中调用<code>setHours</code>时，所有Tweet内部的timestamp都将同步变化。最终，我们得到了24个时间相同的Tweet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a Tweet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-17-21-50.png" alt="表示泄露-接收引用"></p>
<p>为此，我们在接收引用时也要使用防御式拷贝。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，对基本数据类型和不可边数据类型，如String，不需要进行防御式拷贝。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是MIT课件中关于表示泄露的内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/12/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/" class="post-title-link" itemprop="url">Java学习笔记2-对象和类</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-12 16:51:47" itemprop="dateCreated datePublished" datetime="2023-03-12T16:51:47+08:00">2023-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 17:01:39" itemprop="dateModified" datetime="2023-05-26T17:01:39+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>适当的提醒自己学习的目的是有必要的。笔记的作者和理想中的读者应当是具有C语言编程的基础，对指针的概念有清晰理解，<br>正在学习面向对象编程并且希望理解类、对象的概念，特性和其大致实现原理。<br>本文的参考教材是java核心技术卷一</p>
</blockquote>
<h2 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a>面向对象的编程</h2><p>我很喜欢书中的一句话：对于面向过程而言，首先决定如何操作数据，然后再觉得如何组织数据的结构。而OOP却调换了这个次序，将数据放在第一位，然后再考虑组织数据的算法。<br>书中进一步提到，Web浏览器可能需要两千个过程对一组全局数据进行操作，而OOP只需要一百个含有20个方法的类，我对此存疑，但这不是重点。</p>
<h2 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><strong>类</strong>是构造对象的模板或蓝图。由类构造<strong>对象</strong>的过程称为创建类的<strong>实例</strong>。<br>对象中的数据称为<em>实例字段</em>，这些字段的值构成了对象的当前<em>状态</em>。<br>操作数据的过程称之为<em>方法</em>，程序只能通过一个类的方法来与该类的数据交互，这实现了类的<strong>封装</strong>。<br>可以通过<em>保留</em>一个类的全部属性和方法并<em>扩展</em>一些新的方法和数据字段的过程来创建一个新的类，这个过程称为<strong>继承</strong>。<br>对象的方法集合构成了对象的<strong>行为</strong>，示例字段值得集合构成了对象的当前<em>状态</em>同一个类的不同对象具有不同的<strong>标识</strong>。</p>
<h3 id="1-2-编写OOP程序的原则"><a href="#1-2-编写OOP程序的原则" class="headerlink" title="1.2 编写OOP程序的原则"></a>1.2 编写OOP程序的原则</h3><p>先识别类，再为类添加方法。重要的名词可能是类，重要的动词可能是类的方法。</p>
<h3 id="1-3-类之间的关系"><a href="#1-3-类之间的关系" class="headerlink" title="1.3 类之间的关系"></a>1.3 类之间的关系</h3><ol>
<li><p>依赖关系<br> 一个类的方法操作或使用另一个类的对象，就称为这个类<strong>依赖</strong>于另一个类</p>
</li>
<li><p>聚合关系<br>一个类的对象包含另一个类的对象</p>
</li>
<li><p>继承关系<br>一个类继承并扩展了另一个类的功能</p>
</li>
</ol>
<h2 id="二、使用类的方法"><a href="#二、使用类的方法" class="headerlink" title="二、使用类的方法"></a>二、使用类的方法</h2><p>使用对象要先<strong>构造</strong>对象，然后<strong>初始化</strong>对象，之后<strong>调用</strong>对象的方法。</p>
<h3 id="2-1-构造对象"><a href="#2-1-构造对象" class="headerlink" title="2.1 构造对象"></a>2.1 构造对象</h3><p>构造对象使用<code>new</code>运算符，这意味着为该对象分配存储空间。单独声明一个对象变量只是声明了一个指针（仔细思考一下，这意味着如果两个对象变量持有同一个对象的引用，通过任何一个对象变量调用方法都会影响另一个对象变量获得的数据）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date birthday;          <span class="comment">//unavailable</span></span><br><span class="line">birthday = <span class="keyword">new</span> Date();  <span class="comment">//available</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*other usage*/</span></span><br><span class="line">qaq(<span class="keyword">new</span> Q());   <span class="comment">//use constructed object as argument</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-成员"><a href="#2-2-成员" class="headerlink" title="2.2 成员"></a>2.2 成员</h3><p>对对象变量使用<code>.</code>运算符，就可以在对象上取出对应的成员。如果是成员字段，将会获得这个字段的<strong>引用</strong>。如果是方法，那么可以调用这个方法并且该方法已经绑定到该对象上。<br>这是相对而言比较正常的语法。</p>
<h3 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h3><p>我们在java中将一个类的成员函数称之为“方法”，这是一个非常拗口的称呼，尽管大多数程序员并不这么认为（<br>通常使用的成员方法可以分为两类：</p>
<ul>
<li>更改器</li>
<li>访问器<br>在C++中，我们会使用const来标志访问器方法，从语法上限制这个函数修改对象内容的能力。然而，在java里我们无能为力。<br>要问：这种区别有什么用呢？这涉及到后面重要的概念“不可变性”。</li>
</ul>
<h2 id="2-4-定义"><a href="#2-4-定义" class="headerlink" title="2.4 定义"></a>2.4 定义</h2><p>如果要定义一个类，我们需要定义其数据和对数据的操作，也就是成员字段和成员方法。同时，我们还应该准备一系列构造器，以初始化这个类。<br>定义字段的方法为访问修饰符+类型+标识符+;<br>定义方法的方式为访问修饰符+函数原型+函数定义<br>构造器的原型没有返回值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">软件构造-Java学习笔记（1）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-08 22:12:17 / 修改时间：22:40:39" itemprop="dateCreated datePublished" datetime="2023-03-08T22:12:17+08:00">2023-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>主要介绍java和c语言的一些区别,参考课程浙江大学翁恺b站java语言基础</p>
</blockquote>
<h2 id="第一个java程序"><a href="#第一个java程序" class="headerlink" title="第一个java程序"></a>第一个java程序</h2><p>java的开发环境基本上还是依赖ide的,因为java有比较复杂的依赖关系（至少对我而言比较复杂）。教学视频使用的是目前最广泛使用的eclipse,官网下载可以直接安装（2022年不再需要提前安装jre）,汉化方式可以自行搜索。  </p>
<p>java与C语言的第一个区别就在于”类”，和任何编程语言一样，java程序也有自己的执行入口，不过不是主函数，而是主类。我们在主类下编写的方法会被依次调用。一个类就是一个抽象数据类型，包含了数据和对数据的操作。这样的封装使得java和C++等面向对象的编程语言拥有与C语言截然不同的编程风格，会看到大量的标识符和”.”，取成员运算符。java中有许多自带的类，比如马上就会遇到的System类，执行java函数的时候如果跟进是可以直接跟进到System里的方法的，很有趣（另外很想吐槽类名不能自动补全实在是太糟糕了。）  </p>
<p>同样java中的特色还有字符串类String，以及字符串对加号运算符的重载。所谓运算符的重载就是在一定的作用域内，把运算符替换为某个函数的执行。比如原来的加法可以看成有两个算数类型参数返回一个算数类型的add函数，而java中字符串类对加号的重载可以看成把加号对应的函数替换成了strcat函数，也就是连接两个字符串。这种情况下，如果想要保留算数运算就需要在算数变量被替换为字符串变量之前进行算数运算，最简单的方法就是在算术表达式周围加一个括号。</p>
<p>可以看到，类和运算符重载的概念赋予了面向对象语言极大的灵活和自由性。对于类的使用者来说，完全不需要关心类的背后发生了什么。System类背后对输入输出流的复杂处理被掩盖起来，String类进行的字符串连接也被简单的加号替代。这样的封装使得面向对象语言天然的适合用来描述某种问题（我目前并不能很好的概括出是哪种问题）。  </p>
<p>C语言的函数也有类似的封装，然而，C语言并没有提供<em><strong>作用域</strong></em>层面的封装。我们可以在函数内部进行封装，但函数之间的数据传输必须通过清晰的传参返回来完成。C语言对访问类型（static&#x2F;global）的控制可以说提供了封装的一种方案，也就是以编译单元为单位进行模块化的编程设计。不过，函数之间的数据依靠传参管理降低了函数之间的最大聚合程度，更会在系统框架变更时带来巨大的麻烦，运算符重载这种特技更是无从谈起。不过，C语言同样有其独特的好处:面向过程的控制流是清晰可见且高度解耦的，由于没有层层抽象，它还可以生成效率更高的代码。</p>
<h2 id="java中的数组"><a href="#java中的数组" class="headerlink" title="java中的数组"></a>java中的数组</h2><p>java拥有美好的内存管理机制，我们可以使用new关键字分配一片地址，并且这片地址的大小是可变的。（不确定，但是new初始化的默认值全为0是很明显的静态存储特点）java中没有指针类型，而是用[]起到和指针类似的效果，于是我们会写出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>这是一个数组的定义，也就是声明并且分配存储空间。事实上a相当于一个指针。当我们把两个数组类型的变量做比较时，我们实际上在比较他们是否指向同一个地址。如果要比较他们的内容，则要使用数组自带的成员方法equals().<br>数组自带许多的成员，我也不清楚这些成员是哪里来的。一个很有用的成员变量是a.length，它是a的长度，于是我们遍历数组时可以用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和C语言是完全类似的。这个成员变量被声明为final，类似于C中的const，因此它不能被随意修改，而是在创建数组时就确定了。。Java允许我们对可枚举的类型写出for循环的另外一种形式，被称为for-each循环，是全新的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i: a)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的i是a的一个浅拷贝，刚刚给出的例子和一般的for循环的例子是完全等价的。不过需要注意的是，如果要改变数组中的元素的值，那么不能用for-each循环，因为for-each的循环相当于依次把a中元素的值赋给了i，不像a[i]是数组元素自身的标识符。可以想到，改变i的值的效果会在下一次循环时被清空。<br>事实上，for-each循环可以改写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*for (var i: a)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = a[<span class="number">0</span>] ; index &lt; a.length;index++, i = a[index])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组的形式和操作与C语言都是类似的，二维数组就是数组的数组。二维数组自身持有一个length成员，它的每一个元素作为一个数组也持有自己的成员。如果要遍历二维数组，可以写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">        a[i][j] ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步地，如果探究</p>
<h2 id="java中的字符与字符串"><a href="#java中的字符与字符串" class="headerlink" title="java中的字符与字符串"></a>java中的字符与字符串</h2><p>java中使用Unicode来表示字符，并且转义字符’\uxxxx’表示用十六进制表示的unicode字符码。除此之外关于字符的运算都是和C语言完全类似的。<br>字符串是java中一个很常用的类。创建字符串变量的方法据说有11种…让我们先看看比较常用的两种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a;</span><br><span class="line">a = <span class="keyword">new</span> String(<span class="string">&quot;qaq&quot;</span>);</span><br><span class="line">a = <span class="string">&quot;qaq&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>它提供了许多的方法,以及一种运算符重载。当其他类型和String类型进行运算时会被转换成String类型，所以要想避开加号重载就要在转换之前进行运算。常见的C语言函数都可以在java中找到对应的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strcat -&gt; +</span><br><span class="line">strlen -&gt; string.length();</span><br><span class="line">strcmp -&gt; string.compareto();</span><br><span class="line">strstr -&gt; string.indexOf();</span><br></pre></td></tr></table></figure>

<p>此外还有许多方法。不同方法之间可以配合产生出很惊艳的效果。java提供的修改字符串方法都可以看成持有一个结构体指针，返回一个结构体的函数。这意味着方法本身的返回值是一个全新的对象。对于java中的查找或匹配字符串方法，也就是在C语言中会返回字符指针的那些函数（strstr），现在会返回一个整数下标。因为这更多的是实践性的问题，这里就不再举更多例子，需要时可以查阅手册。</p>
<h2 id="java中的包裹类型"><a href="#java中的包裹类型" class="headerlink" title="java中的包裹类型"></a>java中的包裹类型</h2><p>基本类型对应的包裹类型，是具有一些常用成员的类。他们之间的对应是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>     -&gt; Integer</span><br><span class="line"><span class="keyword">boolean</span> -&gt; Boolean</span><br><span class="line"><span class="keyword">double</span>  -&gt; Double</span><br><span class="line"><span class="keyword">char</span>    -&gt; Character</span><br></pre></td></tr></table></figure>

<p>包裹类型会含有一些该类型的信息，比如Integer的成员MAX_VALUE就是C语言中的T_MAX，此外还有一些其他的方法，比如Character具有isdigit，isalpha方法。这些都和c语言是完全类似的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/11/03/RPC%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/RPC%E6%A2%B3%E7%90%86/" class="post-title-link" itemprop="url">RPC梳理</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-03 22:37:18" itemprop="dateCreated datePublished" datetime="2022-11-03T22:37:18+08:00">2022-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Erpc服务处理过程梳理"><a href="#Erpc服务处理过程梳理" class="headerlink" title="Erpc服务处理过程梳理"></a>Erpc服务处理过程梳理</h1><p>RPC的服务端处理过程从传输层开始。传输层收到消息，就会根据约定的传输协议接受信息，然后调用序列化层。序列化解析出请求内容，交由代理层处理。代理层通过对Server和Service的抽象，从请求内容中解析要调用的实际方法和参数，并根据有无返回值&#x2F;是否需要写回数据做进一步处理。<br>如果有返回消息的必要，则代理层调用序列化层写入返回内容，调用传输层用协议封装信息并进行发送</p>
<h2 id="代理层服务器开始服务"><a href="#代理层服务器开始服务" class="headerlink" title="代理层服务器开始服务"></a>代理层服务器开始服务</h2><p>一个典型的服务器启动之后便开始不断监听可能到来的请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::run</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    <span class="keyword">while</span> ((err == kErpcStatus_Success) &amp;&amp; m_isServerOn)</span><br><span class="line">    &#123;</span><br><span class="line">        err = <span class="built_in">runInternal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理过程大致可以分为两步,一是信息处理,二是请求处理,三是数据写回.在erpc中对应 <code>runInternalBegin</code>和<code>runInternalEnd</code>,前者完成第一步,后者完成后两步.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::runInternal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MessageBuffer buff;</span><br><span class="line">    Codec *codec = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">message_type_t</span> msgType;</span><br><span class="line">    <span class="keyword">uint32_t</span> serviceId;</span><br><span class="line">    <span class="keyword">uint32_t</span> methodId;</span><br><span class="line">    <span class="keyword">uint32_t</span> sequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = <span class="built_in">runInternalBegin</span>(&amp;codec, buff, msgType, serviceId, methodId, sequence);</span><br><span class="line">    <span class="keyword">if</span> (err == kErpcStatus_Success)</span><br><span class="line">    &#123;</span><br><span class="line">        err = <span class="built_in">runInternalEnd</span>(codec, msgType, serviceId, methodId, sequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信息处理"><a href="#信息处理" class="headerlink" title="信息处理"></a>信息处理</h2><p>Server在处理消息之前,必须获取一些关键的信息用于下一步处理事件.概括来说,一般需要以下几类信息:</p>
<ul>
<li>RPC协议相关<ul>
<li>消息类型: 是单向请求信息,双向请求信息还是响应信息或系统通知等</li>
<li>RPC协议版本: 用于正确解析信息</li>
<li>序列化方法: 用于正确配置序列化层</li>
<li>请求序列号: 用于异步响应时区分多个请求</li>
</ul>
</li>
<li>代理相关<ul>
<li>请求的Service: 请求的包名&#x2F;类名&#x2F;服务名等</li>
<li>请求的Method: 请求的具体方法</li>
<li>请求的arguments: 实参</li>
<li>请求的参数类型: 用于重载解析</li>
</ul>
</li>
</ul>
<p>这些信息有的在解析完之后立刻使用;有的存放起来作为参数在调用栈中传递;有的暂时不解析,而是配置一个codec,到时按需取用.</p>
<p>从代码中可以看到,信息解析的过程主要包括传输层接收,序列化层读取两个过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::runInternalBegin</span><span class="params">(Codec **codec, MessageBuffer &amp;buff, <span class="keyword">message_type_t</span> &amp;msgType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">uint32_t</span> &amp;serviceId, <span class="keyword">uint32_t</span> &amp;methodId, <span class="keyword">uint32_t</span> &amp;sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    <span class="comment">// buffer创建</span></span><br><span class="line">    <span class="keyword">if</span> (m_messageFactory-&gt;<span class="built_in">createServerBuffer</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buff = m_messageFactory-&gt;<span class="built_in">create</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传输层接收</span></span><br><span class="line">    err = m_transport-&gt;<span class="built_in">receive</span>(&amp;buff);</span><br><span class="line">    <span class="comment">// 序列化层初始化及读取</span></span><br><span class="line">    *codec = m_codecFactory-&gt;<span class="built_in">create</span>();</span><br><span class="line">    (*codec)-&gt;<span class="built_in">setBuffer</span>(buff);</span><br><span class="line">    err = <span class="built_in">readHeadOfMessage</span>(*codec, msgType, serviceId, methodId, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传输层接收"><a href="#传输层接收" class="headerlink" title="传输层接收"></a>传输层接收</h3><p>传输层接受的部分就一句话,简而言之就是将信息读取到buffer中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传输层接收</span></span><br><span class="line"> err = m_transport-&gt;<span class="built_in">receive</span>(&amp;buff);</span><br></pre></td></tr></table></figure>

<p>erpc在这里为所有按帧传输的传输层准备了接受一帧的函数,先接受请求头,读出请求帧的长度,再接受请求体.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">FramedTransport::receive</span><span class="params">(MessageBuffer *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Header h;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> retVal;</span><br><span class="line">    <span class="keyword">uint16_t</span> computedCrc;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !ERPC_THREADS_IS(NONE)</span></span><br><span class="line">        <span class="function">Mutex::Guard <span class="title">lock</span><span class="params">(m_receiveLock)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// Receive header first.</span></span><br><span class="line">        retVal = <span class="built_in">underlyingReceive</span>((<span class="keyword">uint8_t</span> *)&amp;h, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">         <span class="comment">// Receive rest of the message now we know its size.</span></span><br><span class="line">        retVal = <span class="built_in">underlyingReceive</span>(message-&gt;<span class="built_in">get</span>(), h.m_messageSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify CRC.</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    message-&gt;<span class="built_in">setUsed</span>(h.m_messageSize);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其底层实现为<code>TCPTransport::underlyingReceive</code>,本质上就是对read进行了封装.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">TCPTransport::underlyingReceive</span><span class="params">(<span class="keyword">uint8_t</span> *data, <span class="keyword">uint32_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> length;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> status = kErpcStatus_Success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block until we have a valid connection.</span></span><br><span class="line">    <span class="keyword">while</span> (m_socket &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        Thread::<span class="built_in">sleep</span>(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Loop until all requested data is received.</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0U</span>)&#123;</span><br><span class="line">        length = <span class="built_in">read</span>(m_socket, data, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Length will be zero if the connection is closed.</span></span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            size -= length;</span><br><span class="line">            data += length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// close socket, not server</span></span><br><span class="line">                <span class="built_in">close</span>(<span class="literal">false</span>);</span><br><span class="line">                status = kErpcStatus_ConnectionClosed;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                status = kErpcStatus_ReceiveFailed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个过程,我们将socket中的信息成功的接收到了buf中</p>
<h3 id="序列化层解析"><a href="#序列化层解析" class="headerlink" title="序列化层解析"></a>序列化层解析</h3><p>在erpc中,codec是对一次序列化的封装,一个codec不仅有读写各种数据类型的方法,还持有目前正在处理的buffer和buffer上的cursor,这纯粹是为了语法上的方便,不必在调用每个读写函数时都额外传递一个buffer参数,只需要在开始时设置即可.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    MessageBuffer m_buffer;         <span class="comment">/*!&lt; Message buffer object */</span></span><br><span class="line">    MessageBuffer::Cursor m_cursor; <span class="comment">/*!&lt; Copy data to message buffers. */</span></span><br><span class="line">    <span class="keyword">erpc_status_t</span> m_status;         <span class="comment">/*!&lt; Status of serialized data. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此,codec处理的部分先是创建一个codec并绑定buffer,然后再调用内部处理函数读取请求头</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化层初始化及读取</span></span><br><span class="line">*codec = m_codecFactory-&gt;<span class="built_in">create</span>();</span><br><span class="line">(*codec)-&gt;<span class="built_in">setBuffer</span>(buff);</span><br><span class="line">err = <span class="built_in">readHeadOfMessage</span>(*codec, msgType, serviceId, methodId, sequence);</span><br></pre></td></tr></table></figure>

<p>这里我们就不详细探究codec的底层实现了,可以想到对字节流做处理的大概方法就是针对数据类型的长度,读取一定的字节,填入到对象指针指向的内存中,并移动buffer上的cursor.</p>
<p>总体来说,在这里值得注意的地方时codec兼具序列化层和RPC传输协议约定的功能,codec的<code>readHeadOfMessage</code>的实现方法其实就对应了协议头如何组织信息.</p>
<p>在默认的codec中,请求头是一个四字节头加上一个int32序列号,四个字节分别表示codecVersion, serviceId, methodId, requestType(不过很明显,先构建codec再读取头信息已经太迟了,所以当他检测到不匹配的codecversion时没法处理,只能直接报错)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicCodec::startReadMessage</span><span class="params">(<span class="keyword">message_type_t</span> *type, <span class="keyword">uint32_t</span> *service, <span class="keyword">uint32_t</span> *request, <span class="keyword">uint32_t</span> *sequence)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> header;</span><br><span class="line">    <span class="built_in">read</span>(&amp;header);</span><br><span class="line">    <span class="keyword">if</span> (((header &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>U) != kBasicCodecVersion)&#123;</span><br><span class="line">        <span class="built_in">updateStatus</span>(kErpcStatus_InvalidMessageVersion);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStatusOk</span>())&#123;</span><br><span class="line">        *service = ((header &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>U);</span><br><span class="line">        *request = ((header &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>U);</span><br><span class="line">        *type = <span class="keyword">static_cast</span>&lt;<span class="keyword">message_type_t</span>&gt;(header &amp; <span class="number">0xff</span>U);</span><br><span class="line">        <span class="built_in">read</span>(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>在经过了信息处理之后,我们已经成功的将传输层中的一帧请求接收到buffer中,获得了这个请求的rpc协议参数,接下来要做的就是调用合适的处理程序来完成实际的处理工作.erpc中,这个函数正是<code>Server::processMessage</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::runInternalEnd</span><span class="params">(Codec *codec, <span class="keyword">message_type_t</span> msgType, <span class="keyword">uint32_t</span> serviceId, <span class="keyword">uint32_t</span> methodId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">uint32_t</span> sequence)</span></span>&#123;</span><br><span class="line">    <span class="comment">//请求处理</span></span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = <span class="built_in">processMessage</span>(codec, msgType, serviceId, methodId, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息写回</span></span><br><span class="line">    <span class="keyword">if</span> (err == kErpcStatus_Success)&#123;</span><br><span class="line">        <span class="keyword">if</span> (msgType != kOnewayMessage)&#123;</span><br><span class="line">                err = m_transport-&gt;<span class="built_in">send</span>(codec-&gt;<span class="built_in">getBuffer</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Dispose of buffers and codecs.</span></span><br><span class="line">    <span class="built_in">disposeBufferAndCodec</span>(codec);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读源码,我们看到请求处理分为两个阶段:服务发现和方法调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">Server::processMessage</span><span class="params">(Codec *codec, <span class="keyword">message_type_t</span> msgType, <span class="keyword">uint32_t</span> serviceId, <span class="keyword">uint32_t</span> methodId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span> sequence)</span></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    Service *service;</span><br><span class="line">    <span class="comment">//服务发现</span></span><br><span class="line">    service = <span class="built_in">findServiceWithId</span>(serviceId);</span><br><span class="line">    <span class="comment">//方法调用</span></span><br><span class="line">    err = service-&gt;<span class="built_in">handleInvocation</span>(methodId, sequence, codec, m_messageFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现的过程就是在服务器已注册的服务中寻找能响应请求的那个,一些语言会使用map来完成这个事情,而在erpc中直接使用了serviceId+methodId, 如果idl确定的话,对于S&#x2F;C端而言,这个id号是可以唯一确定有效服务的.</p>
<p>在服务端,服务用链表存储:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">getServiceId</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_serviceId; &#125;</span><br><span class="line">    <span class="function">Service *<span class="title">getNext</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> m_next; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Service *next)</span> </span>&#123; m_next = next; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">erpc_status_t</span> <span class="title">handleInvocation</span><span class="params">(<span class="keyword">uint32_t</span> methodId, <span class="keyword">uint32_t</span> sequence, Codec *codec,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           MessageBufferFactory *messageFactory)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> m_serviceId; <span class="comment">/*!&lt; Service unique id. */</span></span><br><span class="line">    Service *m_next;      <span class="comment">/*!&lt; Pointer to next service. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器在解析信息时通过遍历链表查找id对应的服务,然后调用对应的处理函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">Server::processMessage</span><span class="params">(Codec *codec, <span class="keyword">message_type_t</span> msgType, <span class="keyword">uint32_t</span> serviceId, <span class="keyword">uint32_t</span> methodId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    Service *service;</span><br><span class="line">    service = <span class="built_in">findServiceWithId</span>(serviceId);</span><br><span class="line">    err = service-&gt;<span class="built_in">handleInvocation</span>(methodId, sequence, codec, m_messageFactory);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><code>Server::processMessage</code>调用的<code>Service::handleInvocation</code>是由erpcgen工具根据我们定义的IDL自动生成的.<br>在.erpc中声明service及其方法, 其中interface关键字后跟服务名, 花括号内可以有若干个方法.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MatrixMultiplyService <span class="comment">// cover functions for same topic</span></span><br><span class="line">&#123;</span><br><span class="line">    erpcMatrixMultiply(in Matrix matrix1, in Matrix matrix2, out Matrix result_matrix) -&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行下列命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erpcgen idl.erpc -g c</span><br></pre></td></tr></table></figure>

<p>即可得到生成的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">erpc_matrix_multiply_client.c++</span><br><span class="line">erpc_matrix_multiply_server.c++</span><br><span class="line">erpc_matrix_multiply_server.h</span><br><span class="line">erpc_matrix_multiply.h</span><br></pre></td></tr></table></figure>

<p>其中,<code>erpc_matrix_multiply_server.c++</code>就有服务处理函数的定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">MatrixMultiplyService_service::handleInvocation</span><span class="params">(<span class="keyword">uint32_t</span> methodId, <span class="keyword">uint32_t</span> sequence, Codec * codec, MessageBufferFactory *messageFactory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> erpcStatus;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (methodId)&#123;</span><br><span class="line">        <span class="keyword">case</span> kMatrixMultiplyService_erpcMatrixMultiply_id:</span><br><span class="line">            erpcStatus = <span class="built_in">erpcMatrixMultiply_shim</span>(codec, messageFactory, sequence);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            erpcStatus = kErpcStatus_InvalidArgument;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> erpcStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, 处理函数进一步通过methodId判断该调用Service中的哪个方法的shim, 这个shim就是方法对应的代理.<br>代理完成的内容就是组织codec进行反序列化, 获取入参,然后对out类型的数据进行序列化写回, 返回值也一并写回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">MatrixMultiplyService_service::erpcMatrixMultiply_shim</span><span class="params">(Codec * codec, MessageBufferFactory *messageFactory, <span class="keyword">uint32_t</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line"></span><br><span class="line">    Matrix matrix1;</span><br><span class="line">    Matrix matrix2;</span><br><span class="line">    Matrix result_matrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)&#123;</span><br><span class="line">            codec-&gt;<span class="built_in">read</span>(&amp;matrix1[arrayCount0][arrayCount1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)&#123;</span><br><span class="line">            codec-&gt;<span class="built_in">read</span>(&amp;matrix2[arrayCount0][arrayCount1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// preparing codec for serializing data</span></span><br><span class="line">    codec-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用实际方法</span></span><br><span class="line">    <span class="built_in">erpcMatrixMultiply</span>(matrix1, matrix2, result_matrix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build response message.</span></span><br><span class="line">    codec-&gt;<span class="built_in">startWriteMessage</span>(kReplyMessage, kMatrixMultiplyService_service_id, kMatrixMultiplyService_erpcMatrixMultiply_id, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)&#123;</span><br><span class="line">                codec-&gt;<span class="built_in">write</span>(result_matrix[arrayCount0][arrayCount1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据写回"><a href="#数据写回" class="headerlink" title="数据写回"></a>数据写回</h3><p>首先需要注意的是,在调用实际方法之前,对codec进行了重置:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// preparing codec for serializing data</span></span><br><span class="line">    codec-&gt;<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure>

<p>这个重置函数将内部的buffer和cursor恢复到使用之前的状态,相当于将这个读缓冲区又作为写缓冲区复用.在写回过程中，序列化首先调用codec的startWriteMessage方法写回响应头.和我们之前谈到的一样,这一步也是和RPC协议相关的,即codec写入头消息的方式就是rpc协议的方式.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicCodec::startWriteMessage</span><span class="params">(<span class="keyword">message_type_t</span> type, <span class="keyword">uint32_t</span> service, <span class="keyword">uint32_t</span> request, <span class="keyword">uint32_t</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> header =</span><br><span class="line">        (kBasicCodecVersion &lt;&lt; <span class="number">24u</span>) | ((service &amp; <span class="number">0xff</span>u) &lt;&lt; <span class="number">16u</span>) | ((request &amp; <span class="number">0xff</span>u) &lt;&lt; <span class="number">8u</span>) | ((<span class="keyword">uint32_t</span>)type &amp; <span class="number">0xff</span>u);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(header);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, 调用Codec的write方法.在这里,对于数组,erpcgen将会自动生成对应的循环结构来写入.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    ...    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)</span><br><span class="line">            &#123;</span><br><span class="line">                codec-&gt;<span class="built_in">write</span>(result_matrix[arrayCount0][arrayCount1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Codec对c++的所有数据类型重载一个write方法, 这个方法是对writeData的封装, 后者将按照数据的值和长度传递写入数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicCodec::writeData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">uint32_t</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStatusOk</span>())&#123;</span><br><span class="line">        m_status = m_cursor.<span class="built_in">write</span>(value, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cursor将作为buffer的内部类完成信息的写入，就是将信息复制到缓冲区里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">erpc_status_t</span> MessageBuffer::Cursor::<span class="built_in">write</span>(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">uint32_t</span> length)&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0U</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            err = kErpcStatus_MemoryError;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (length &gt; <span class="built_in">getRemaining</span>())&#123;</span><br><span class="line">            err = kErpcStatus_BufferOverrun;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            (<span class="keyword">void</span>)<span class="built_in">memcpy</span>(m_pos, data, length);</span><br><span class="line">            m_pos += length;</span><br><span class="line">            m_buffer-&gt;<span class="built_in">setUsed</span>(m_buffer-&gt;<span class="built_in">getUsed</span>() + length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成write之后shim就会直接返回,之后可以直接利用send发送,因为我们在生成的shim函数中已经完成了需要写回的数据的序列化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据发送</span></span><br><span class="line"><span class="keyword">if</span> (err == kErpcStatus_Success)&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgType != kOnewayMessage)&#123;</span><br><span class="line">            err = m_transport-&gt;<span class="built_in">send</span>(codec-&gt;<span class="built_in">getBuffer</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/" class="post-title-link" itemprop="url">RPC框架设计侧重点-特色和架构调研2.md</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-02 16:26:48" itemprop="dateCreated datePublished" datetime="2022-10-02T16:26:48+08:00">2022-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-03 20:35:34" itemprop="dateModified" datetime="2022-10-03T20:35:34+08:00">2022-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a><a target="_blank" rel="noopener" href="https://github.com/apache/thrift">Thrift</a></h2><p>Thrift 是用于点对点 RPC 实现的轻量级、跨语言的软件栈。Thrift，为传输、序列化、应用级逻辑都提供了实现，同时具有从idl生成代码的功能。</p>
<p>Thrift将架构分为6层，每层都可以自由组合，以适应不同的需求。<br><img src="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/thrift%E6%8A%80%E6%9C%AF%E6%A0%88.png" alt="1"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">├── ...(一些构建相关)</span><br><span class="line">├── compiler</span><br><span class="line">│   └── cpp</span><br><span class="line">├── debian</span><br><span class="line">├── lib             #代码实现</span><br><span class="line">│   ├── c_glib/src/thrift</span><br><span class="line">|       ├── processor                               #处理请求</span><br><span class="line">|       │   ├── thrift_dispatch_processor.c         #实现,使用glib-object完成面向对象</span><br><span class="line">|       │   ├── thrift_dispatch_processor.h</span><br><span class="line">|       │   ├── thrift_multiplexed_processor.c      #提供多个处理器</span><br><span class="line">|       │   ├── thrift_multiplexed_processor.h</span><br><span class="line">|       │   ├── thrift_processor.c                  #接口</span><br><span class="line">|       │   └── thrift_processor.h</span><br><span class="line">|       ├── protocol</span><br><span class="line">|       │   ├── thrift_binary_protocol.c            #二进制协议的实现,把数据转化为合适的形式(bool转化为uint8, double转化为IEEE int64等)</span><br><span class="line">|       │   ├── thrift_binary_protocol.h</span><br><span class="line">|       │   ├── thrift_binary_protocol_factory.c</span><br><span class="line">|       │   ├── thrift_binary_protocol_factory.h</span><br><span class="line">|       │   ├── thrift_compact_protocol.c</span><br><span class="line">|       │   ├── thrift_compact_protocol.h</span><br><span class="line">|       │   ├── thrift_compact_protocol_factory.c</span><br><span class="line">|       │   ├── thrift_compact_protocol_factory.h</span><br><span class="line">|       │   ├── thrift_multiplexed_protocol.c</span><br><span class="line">|       │   ├── thrift_multiplexed_protocol.h</span><br><span class="line">|       │   ├── thrift_protocol.c                   #写入数据,`THRIFT_PROTOCOL_GET_CLASS (protocol)-&gt;write`</span><br><span class="line">|       │   ├── thrift_protocol.h</span><br><span class="line">|       │   ├── thrift_protocol_decorator.c         #用decorator模式提供了多协议`THRIFT_PROTOCOL_GET_CLASS (self-&gt;concrete_protocol)-&gt;write_struct_begin (self-&gt;concrete_protocol,name, error)`</span><br><span class="line">|       │   ├── thrift_protocol_decorator.h</span><br><span class="line">|       │   ├── thrift_protocol_factory.c</span><br><span class="line">|       │   ├── thrift_protocol_factory.h</span><br><span class="line">|       │   ├── thrift_stored_message_protocol.c</span><br><span class="line">|       │   └── thrift_stored_message_protocol.h</span><br><span class="line">|       ├── server</span><br><span class="line">|       │   ├── thrift_server.c                 #服务器抽象类</span><br><span class="line">|       │   ├── thrift_server.h                 </span><br><span class="line">|       │   ├── thrift_simple_server.c          #简单实现</span><br><span class="line">|       │   └── thrift_simple_server.h</span><br><span class="line">|       ├── thrift.c</span><br><span class="line">|       ├── thrift.h</span><br><span class="line">|       ├── thrift_application_exception.c</span><br><span class="line">|       ├── thrift_application_exception.h</span><br><span class="line">|       ├── thrift_configuration.c</span><br><span class="line">|       ├── thrift_configuration.h</span><br><span class="line">|       ├── thrift_struct.c</span><br><span class="line">|       ├── thrift_struct.h</span><br><span class="line">|       └── transport</span><br><span class="line">|           ├── thrift_buffered_transport.c</span><br><span class="line">|           ├── thrift_buffered_transport.h</span><br><span class="line">|           ├── thrift_buffered_transport_factory.c</span><br><span class="line">|           ├── thrift_buffered_transport_factory.h</span><br><span class="line">|           ├── thrift_fd_transport.c</span><br><span class="line">|           ├── thrift_fd_transport.h</span><br><span class="line">|           ├── thrift_framed_transport.c</span><br><span class="line">|           ├── thrift_framed_transport.h</span><br><span class="line">|           ├── thrift_framed_transport_factory.c</span><br><span class="line">|           ├── thrift_framed_transport_factory.h</span><br><span class="line">|           ├── thrift_memory_buffer.c</span><br><span class="line">|           ├── thrift_memory_buffer.h</span><br><span class="line">|           ├── thrift_platform_socket.h</span><br><span class="line">|           ├── thrift_server_socket.c</span><br><span class="line">|           ├── thrift_server_socket.h          </span><br><span class="line">|           ├── thrift_server_transport.c</span><br><span class="line">|           ├── thrift_server_transport.h</span><br><span class="line">|           ├── thrift_socket.c</span><br><span class="line">|           ├── thrift_socket.h</span><br><span class="line">|           ├── thrift_ssl_socket.c</span><br><span class="line">|           ├── thrift_ssl_socket.h</span><br><span class="line">|           ├── thrift_transport.c</span><br><span class="line">|           ├── thrift_transport.h</span><br><span class="line">|           ├── thrift_transport_factory.c</span><br><span class="line">|           ├── thrift_transport_factory.h</span><br><span class="line">|           ├── thrift_zlib_transport.c</span><br><span class="line">|           ├── thrift_zlib_transport.h</span><br><span class="line">|           ├── thrift_zlib_transport_factory.c</span><br><span class="line">|           └── thrift_zlib_transport_factory.h</span><br><span class="line">|   ...</span><br><span class="line">|</span><br><span class="line">├── contrib         #一些实例,但不是官方测试用例</span><br><span class="line">├── test            #测试用例</span><br><span class="line">├── doc</span><br><span class="line">│   ├── specs       #一些格式信息</span><br><span class="line">|       ├── HeaderFormat.md                 #请求头格式</span><br><span class="line">|       ├── SequenceNumbers.md              #序列号(用于在一个链接中异步处理多个请求)</span><br><span class="line">|       ├── idl.md                          #接口定义语言</span><br><span class="line">|       ├── thrift-binary-protocol.md       #二进制协议, TLV格式</span><br><span class="line">|       ├── thrift-compact-protocol.md      #压缩方式 zigzag压缩整数, 其他的似乎编码没有太大不同?</span><br><span class="line">|       ├── thrift-parameter-validation-proposal.md     #参数验证,也就是通过某些方式限定参数的取值范围.比如int32类型必须取1,2,4,或者限定某个字符串长度必须大于4</span><br><span class="line">|       ├── thrift-protocol-spec.md         #BNF</span><br><span class="line">|       ├── thrift-rpc.md                   #框架整体简介</span><br><span class="line">|       ├── thrift-sasl-spec.txt            #(Simple Authentication and Security Layer)</span><br><span class="line">|       ├── thrift-tconfiguration.md        #一些设置</span><br><span class="line">|       └── thrift.tex</span><br><span class="line">│       └── ...         #没啥用</span><br><span class="line">└── tutorial        #教程</span><br><span class="line">    ├── c_glib</span><br><span class="line">    ...</span><br><span class="line">    └── swift</span><br></pre></td></tr></table></figure>

<h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><p>Thrift 专门设计用于支持跨客户端和服务器代码的非原子版本更改。这使您可以升级服务器，同时仍然能够为旧客户端提供服务；或让较新的客户端向较旧的服务器发出请求。</p>
<h2 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a><a target="_blank" rel="noopener" href="https://github.com/weibocom/motan/wiki/zh_overview">Motan</a></h2><p>Motan是一套基于java开发的RPC框架，除了常规的点对点调用外，Motan还提供服务治理功能，包括服务节点的自动发现、摘除、高可用和负载均衡等。</p>
<p>Motan具有良好的扩展性，主要模块都提供了多种不同的实现，例如支持多种注册中心，支持多种rpc协议等。</p>
<h3 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a><a target="_blank" rel="noopener" href="https://github.com/weibocom/motan/wiki/zh_userguide#%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0">架构概述</a></h3><p><img src="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0.png" alt="2"><br>默认序列化: Hessian2, 默认传输层: Netty NIO TCP长连接</p>
<ul>
<li><p>register:<br>用来和注册中心进行交互，包括注册服务、订阅服务、服务变更通知、服务心跳发送等功能；Server端会在系统初始化时通过register模块注册服务，Client端在系统初始化时会通过register模块订阅到具体提供服务的Server列表，当Server 列表发生变更时也由register模块通知Client。</p>
</li>
<li><p>Cluster:<br>cluster是一组可用的Server在逻辑上的封装，包含若干可以提供RPC服务的Server，实际请求时会根据不同的高可用与负载均衡策略选择一个可用的Server发起远程调用。</p>
<p>在进行RPC请求时，Client通过代理机制调用cluster模块，cluster根据配置的HA和LoadBalance选出一个可用的Server，通过serialize模块把RPC请求转换为字节流，然后通过transport模块发送到Server端。</p>
</li>
</ul>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">├── closable</span><br><span class="line">├── cluster</span><br><span class="line">│   ├── ha</span><br><span class="line">│   ├── loadbalance</span><br><span class="line">│   └── support</span><br><span class="line">├── codec</span><br><span class="line">├── common</span><br><span class="line">├── config</span><br><span class="line">│   ├── annotation</span><br><span class="line">│   └── handler</span><br><span class="line">├── core</span><br><span class="line">│   └── extension</span><br><span class="line">├── exception</span><br><span class="line">├── filter</span><br><span class="line">├── log</span><br><span class="line">├── protocol</span><br><span class="line">│   ├── injvm</span><br><span class="line">│   ├── mock</span><br><span class="line">│   ├── rpc</span><br><span class="line">│   ├── support</span><br><span class="line">│   └── v2motan</span><br><span class="line">├── proxy</span><br><span class="line">│   └── spi</span><br><span class="line">├── registry    #服务注册:发现注册/变更通知/流量配置/失败返回</span><br><span class="line">│   └── support</span><br><span class="line">│       └── command</span><br><span class="line">├── rpc         #奇怪的工具类 Callbackable/Future/Node/Refer/Request/...Response</span><br><span class="line">│   └── init</span><br><span class="line">├── serialize   #FastJson, Hessian2, Breeze, Simple</span><br><span class="line">├── switcher</span><br><span class="line">├── transport   #Channel/Transport/Server绑定/Clent心跳/..</span><br><span class="line">│   ├── async</span><br><span class="line">│   └── support</span><br><span class="line">└── util        #Math/Net/Stats/Reflect/....</span><br></pre></td></tr></table></figure>

<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo</a></h2><ul>
<li>基于透明接口的 RPC</li>
<li>智能负载均衡</li>
<li>自动服务注册和发现</li>
<li>高扩展性</li>
<li>运行时流量路由</li>
<li>可视化服务治理</li>
</ul>
<h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p><img src="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/Dubbo%E6%9E%B6%E6%9E%84.png" alt="3"></p>
<p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/docs/v2.7/dev/design/">代码架构和设计内容像详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">RPC框架设计侧重点, 特色和架构调研</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 16:53:30" itemprop="dateCreated datePublished" datetime="2022-09-25T16:53:30+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 21:19:12" itemprop="dateModified" datetime="2022-10-24T21:19:12+08:00">2022-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Volo调研"><a href="#Volo调研" class="headerlink" title="Volo调研"></a>Volo调研</h2><p>Volo 是字节跳动服务框架团队研发的轻量级、高性能、可扩展性强、易用性好的 Rust RPC 框架，使用了 Rust 最新的 GAT 特性。</p>
<h3 id="特色-易用性"><a href="#特色-易用性" class="headerlink" title="特色-易用性"></a>特色-易用性</h3><p>具体来说，这个框架使用了<a target="_blank" rel="noopener" href="https://github.com/cloudwego/motore">motore</a>中间件, 而其使用GAT语法完成了<a target="_blank" rel="noopener" href="https://github.com/cloudwego/motore">高效的异步接口</a></p>
<p>Rust不支持一个<code>async trait</code>, 一般的解决方法是使用Box(类似智能指针)来完成这件事情, <a target="_blank" rel="noopener" href="https://www.cloudwego.io/zh/docs/motore/faq/q1_gat/">但这会</a>带来额外的开销并且降低代码可读性. 有一个使用宏完成用Box实现异步接口的<a target="_blank" rel="noopener" href="https://docs.rs/async-trait/latest/async_trait/">Crate</a></p>
<p>具体细节可能需要进一步理解一些Rust的语言特性</p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">├─volo          RPC框架的通用组件</span><br><span class="line">│  └─src  </span><br><span class="line">│      ├─discovery      #服务发现:一些接口,一种简单实现(返回静态单链表)</span><br><span class="line">│      ├─loadbalance    #负载均衡:同上(加权随机)</span><br><span class="line">│      ├─net            #网络链接: probe创建套接字,dial建立连接,incomming进行监听,conn进行读写 </span><br><span class="line">│      └─util           #工具: buf_reader</span><br><span class="line">|                       #</span><br><span class="line">├─volo-build    #编译用</span><br><span class="line">│  └─src</span><br><span class="line">├─volo-cli      #用户界面</span><br><span class="line">│  └─...</span><br><span class="line">├─volo-grpc     #grpc框架</span><br><span class="line">│  └─src</span><br><span class="line">│      ├─client         #客户端底层组件</span><br><span class="line">│      ├─codec          #编解码器</span><br><span class="line">│      ├─layer          #待调研,类似某种封装tonic/src/metadata</span><br><span class="line">│      │  └─loadbalance</span><br><span class="line">│      ├─metadata</span><br><span class="line">│      ├─server         #服务端底层组件</span><br><span class="line">│      └─transport</span><br><span class="line">    ...                 #从tonic/src/中copy并修改了一些文件,完成rpc的请求响应相关工作</span><br><span class="line">├─volo-macros   #宏</span><br><span class="line">│  └─src</span><br><span class="line">└─volo-thrift   #thrift框架</span><br><span class="line">    └─src</span><br><span class="line">        ├─client</span><br><span class="line">        │  └─layer</span><br><span class="line">        ├─codec</span><br><span class="line">        ├─protocol</span><br><span class="line">        └─transport</span><br><span class="line">            ├─pingpong</span><br><span class="line">            └─pool</span><br></pre></td></tr></table></figure>

<p><strong>如何用Volo的特色实现grpc</strong><br><img src="/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/2022-09-25-16-54-19.png" alt="架构图"></p>
<h3 id="erpc"><a href="#erpc" class="headerlink" title="erpc"></a>erpc</h3><p><strong>传输层(串口),嵌入式,代码生成(结合nanopb)</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/EmbeddedRPC/erpc">erpc项目地址</a>及其<a target="_blank" rel="noopener" href="https://embeddedrpc.github.io/eRPC">详细文档</a></p>
<h3 id="侧重点"><a href="#侧重点" class="headerlink" title="侧重点"></a>侧重点</h3><p>嵌入式,轻量化</p>
<h3 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">├─erpcgen           #代码生成工具</span><br><span class="line">├─erpcsniffer</span><br><span class="line">│  └─src</span><br><span class="line">├─erpc_c            #基础架构</span><br><span class="line">│  ├─config         #config.h配置文件 </span><br><span class="line">│  └─infra</span><br><span class="line">|     ├─ erpc_arbitrated_client_manager.cpp</span><br><span class="line">|     ├─ erpc_arbitrated_client_manager.hpp</span><br><span class="line">|     ├─ erpc_basic_codec.cpp      #基础编解码器</span><br><span class="line">|     ├─ erpc_basic_codec.hpp</span><br><span class="line">|     ├─ erpc_client_manager.cpp</span><br><span class="line">|     ├─ erpc_client_manager.h</span><br><span class="line">|     ├─ erpc_client_server_common.hpp</span><br><span class="line">|     ├─ erpc_codec.hpp             #编解码器抽象定义</span><br><span class="line">|     ├─ erpc_common.h              #状态码枚举类型的定义</span><br><span class="line">|     ├─ erpc_crc16.cpp</span><br><span class="line">|     ├─ erpc_crc16.hpp</span><br><span class="line">|     ├─ erpc_framed_transport.cpp</span><br><span class="line">|     ├─ erpc_framed_transport.hpp</span><br><span class="line">|     ├─ erpc_manually_constructed.hpp</span><br><span class="line">|     ├─ erpc_message_buffer.cpp</span><br><span class="line">|     ├─ erpc_message_buffer.hpp</span><br><span class="line">|     ├─ erpc_message_loggers.cpp</span><br><span class="line">|     ├─ erpc_message_loggers.hpp</span><br><span class="line">|     ├─ erpc_pre_post_action.cpp</span><br><span class="line">|     ├─ erpc_pre_post_action.h</span><br><span class="line">|     ├─ erpc_server.cpp            </span><br><span class="line">|     ├─ erpc_server.hpp            #Service和Server的抽象接口,注册移除服务,处理信息等</span><br><span class="line">|     ├─ erpc_simple_server.cpp     #</span><br><span class="line">|     ├─ erpc_simple_server.hpp</span><br><span class="line">|     ├─ erpc_static_queue.hpp      #数组实现的队列</span><br><span class="line">|     ├─ erpc_transport.hpp         #Transport</span><br><span class="line">|     ├─ erpc_transport_arbitrator.cpp</span><br><span class="line">|     ├─ erpc_transport_arbitrator.hpp</span><br><span class="line">|     ├─ erpc_version.h</span><br><span class="line">|     ├─ infra.dox     </span><br><span class="line">│  ├─port           #便于移植</span><br><span class="line">│  ├─setup          #C语言接口</span><br><span class="line">│  └─transports     #支持不同通信方法的工具类</span><br><span class="line">├─erpc_python</span><br><span class="line">│  └─erpc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<ul>
<li>rtos上的 protobuf-c</li>
<li>erpc 传输层 nanopb</li>
<li>volo 语法特性</li>
<li>motan dubbo 事件逻辑</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="辉夜"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">辉夜</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">辉夜</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
