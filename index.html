<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huiyeruzhou.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="辉夜的博客">
<meta property="og:url" content="http://huiyeruzhou.github.io/index.html">
<meta property="og:site_name" content="辉夜的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="辉夜">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://huiyeruzhou.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>辉夜的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">辉夜的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">繁花似锦，辉夜如昼</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/08/%E5%85%AC%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E5%85%AC%E5%91%8A/" class="post-title-link" itemprop="url">公告</a>
        </h2>

        <div class="post-meta">
          
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-08 22:27:25 / 修改时间：22:29:11" itemprop="dateCreated datePublished" datetime="2023-03-08T22:27:25+08:00">2023-03-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一条置顶公告。<br>如果要查阅专门为软件构造课程写的博客，请点击“标签”并在其中选择 <code>#软件构造</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">软件构造-Java学习笔记（1）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-08 22:12:17 / 修改时间：22:40:39" itemprop="dateCreated datePublished" datetime="2023-03-08T22:12:17+08:00">2023-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>主要介绍java和c语言的一些区别,参考课程浙江大学翁恺b站java语言基础</p>
</blockquote>
<h2 id="第一个java程序"><a href="#第一个java程序" class="headerlink" title="第一个java程序"></a>第一个java程序</h2><p>java的开发环境基本上还是依赖ide的,因为java有比较复杂的依赖关系（至少对我而言比较复杂）。教学视频使用的是目前最广泛使用的eclipse,官网下载可以直接安装（2022年不再需要提前安装jre）,汉化方式可以自行搜索。  </p>
<p>java与C语言的第一个区别就在于”类”，和任何编程语言一样，java程序也有自己的执行入口，不过不是主函数，而是主类。我们在主类下编写的方法会被依次调用。一个类就是一个抽象数据类型，包含了数据和对数据的操作。这样的封装使得java和C++等面向对象的编程语言拥有与C语言截然不同的编程风格，会看到大量的标识符和”.”，取成员运算符。java中有许多自带的类，比如马上就会遇到的System类，执行java函数的时候如果跟进是可以直接跟进到System里的方法的，很有趣（另外很想吐槽类名不能自动补全实在是太糟糕了。）  </p>
<p>同样java中的特色还有字符串类String，以及字符串对加号运算符的重载。所谓运算符的重载就是在一定的作用域内，把运算符替换为某个函数的执行。比如原来的加法可以看成有两个算数类型参数返回一个算数类型的add函数，而java中字符串类对加号的重载可以看成把加号对应的函数替换成了strcat函数，也就是连接两个字符串。这种情况下，如果想要保留算数运算就需要在算数变量被替换为字符串变量之前进行算数运算，最简单的方法就是在算术表达式周围加一个括号。</p>
<p>可以看到，类和运算符重载的概念赋予了面向对象语言极大的灵活和自由性。对于类的使用者来说，完全不需要关心类的背后发生了什么。System类背后对输入输出流的复杂处理被掩盖起来，String类进行的字符串连接也被简单的加号替代。这样的封装使得面向对象语言天然的适合用来描述某种问题（我目前并不能很好的概括出是哪种问题）。  </p>
<p>C语言的函数也有类似的封装，然而，C语言并没有提供<em><strong>作用域</strong></em>层面的封装。我们可以在函数内部进行封装，但函数之间的数据传输必须通过清晰的传参返回来完成。C语言对访问类型（static&#x2F;global）的控制可以说提供了封装的一种方案，也就是以编译单元为单位进行模块化的编程设计。不过，函数之间的数据依靠传参管理降低了函数之间的最大聚合程度，更会在系统框架变更时带来巨大的麻烦，运算符重载这种特技更是无从谈起。不过，C语言同样有其独特的好处:面向过程的控制流是清晰可见且高度解耦的，由于没有层层抽象，它还可以生成效率更高的代码。</p>
<h2 id="java中的数组"><a href="#java中的数组" class="headerlink" title="java中的数组"></a>java中的数组</h2><p>java拥有美好的内存管理机制，我们可以使用new关键字分配一片地址，并且这片地址的大小是可变的。（不确定，但是new初始化的默认值全为0是很明显的静态存储特点）java中没有指针类型，而是用[]起到和指针类似的效果，于是我们会写出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>这是一个数组的定义，也就是声明并且分配存储空间。事实上a相当于一个指针。当我们把两个数组类型的变量做比较时，我们实际上在比较他们是否指向同一个地址。如果要比较他们的内容，则要使用数组自带的成员方法equals().<br>数组自带许多的成员，我也不清楚这些成员是哪里来的。一个很有用的成员变量是a.length，它是a的长度，于是我们遍历数组时可以用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和C语言是完全类似的。这个成员变量被声明为final，类似于C中的const，因此它不能被随意修改，而是在创建数组时就确定了。。Java允许我们对可枚举的类型写出for循环的另外一种形式，被称为for-each循环，是全新的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i: a)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的i是a的一个浅拷贝，刚刚给出的例子和一般的for循环的例子是完全等价的。不过需要注意的是，如果要改变数组中的元素的值，那么不能用for-each循环，因为for-each的循环相当于依次把a中元素的值赋给了i，不像a[i]是数组元素自身的标识符。可以想到，改变i的值的效果会在下一次循环时被清空。<br>事实上，for-each循环可以改写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*for (var i: a)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = a[<span class="number">0</span>] ; index &lt; a.length;index++, i = a[index])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组的形式和操作与C语言都是类似的，二维数组就是数组的数组。二维数组自身持有一个length成员，它的每一个元素作为一个数组也持有自己的成员。如果要遍历二维数组，可以写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">        a[i][j] ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步地，如果探究</p>
<h2 id="java中的字符与字符串"><a href="#java中的字符与字符串" class="headerlink" title="java中的字符与字符串"></a>java中的字符与字符串</h2><p>java中使用Unicode来表示字符，并且转义字符’\uxxxx’表示用十六进制表示的unicode字符码。除此之外关于字符的运算都是和C语言完全类似的。<br>字符串是java中一个很常用的类。创建字符串变量的方法据说有11种…让我们先看看比较常用的两种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a;</span><br><span class="line">a = <span class="keyword">new</span> String(<span class="string">&quot;qaq&quot;</span>);</span><br><span class="line">a = <span class="string">&quot;qaq&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>它提供了许多的方法,以及一种运算符重载。当其他类型和String类型进行运算时会被转换成String类型，所以要想避开加号重载就要在转换之前进行运算。常见的C语言函数都可以在java中找到对应的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strcat -&gt; +</span><br><span class="line">strlen -&gt; string.length();</span><br><span class="line">strcmp -&gt; string.compareto();</span><br><span class="line">strstr -&gt; string.indexOf();</span><br></pre></td></tr></table></figure>

<p>此外还有许多方法。不同方法之间可以配合产生出很惊艳的效果。java提供的修改字符串方法都可以看成持有一个结构体指针，返回一个结构体的函数。这意味着方法本身的返回值是一个全新的对象。对于java中的查找或匹配字符串方法，也就是在C语言中会返回字符指针的那些函数（strstr），现在会返回一个整数下标。因为这更多的是实践性的问题，这里就不再举更多例子，需要时可以查阅手册。</p>
<h2 id="java中的包裹类型"><a href="#java中的包裹类型" class="headerlink" title="java中的包裹类型"></a>java中的包裹类型</h2><p>基本类型对应的包裹类型，是具有一些常用成员的类。他们之间的对应是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>     -&gt; Integer</span><br><span class="line"><span class="keyword">boolean</span> -&gt; Boolean</span><br><span class="line"><span class="keyword">double</span>  -&gt; Double</span><br><span class="line"><span class="keyword">char</span>    -&gt; Character</span><br></pre></td></tr></table></figure>

<p>包裹类型会含有一些该类型的信息，比如Integer的成员MAX_VALUE就是C语言中的T_MAX，此外还有一些其他的方法，比如Character具有isdigit，isalpha方法。这些都和c语言是完全类似的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/" class="post-title-link" itemprop="url">软件构造-关于表示泄露1-基本内容</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-08 22:12:17" itemprop="dateCreated datePublished" datetime="2023-03-08T22:12:17+08:00">2023-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-22 17:45:06" itemprop="dateModified" datetime="2023-03-22T17:45:06+08:00">2023-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们将讨论表示泄露的几种情况，以及如何防止表示泄露<br>原创性声明：每一个字（除了代码和引用）都是我手敲的。</p>
</blockquote>
<h2 id="表示泄露的定义"><a href="#表示泄露的定义" class="headerlink" title="表示泄露的定义"></a>表示泄露的定义</h2><p>表示泄露，即Representation Exposure，指的是client端程序可以通过某种手段<br>查询、访问、修改ADT的<strong>内部结构</strong>。<br>我们将通过一些例子来感受这个定义。</p>
<h2 id="最基本的表示泄露-来自访问权限"><a href="#最基本的表示泄露-来自访问权限" class="headerlink" title="最基本的表示泄露-来自访问权限"></a>最基本的表示泄露-来自访问权限</h2><p>在java的设计中，一个字段的访问权限有四种。<br><img src="/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-16-57-49.png" alt="访问权限"><br>为了避免表示泄露，<strong>如果一个字段可以是private，那么它就应当是private</strong>。<br>下面我们来看一个因为访问权限导致表示泄露的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This immutable data type represents a tweet from Twitter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String author;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line">    <span class="keyword">public</span> Date timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make a Tweet.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个结构，我们在创建之后可以任意访问修改它的字段，因为字段被声明为public：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tweet t = <span class="keyword">new</span> Tweet(<span class="string">&quot;justinbieber&quot;</span>, </span><br><span class="line">                    <span class="string">&quot;Thanks to all those beliebers out there inspiring me every day&quot;</span>, </span><br><span class="line">                    <span class="keyword">new</span> Date());</span><br><span class="line">t.author = <span class="string">&quot;rbmllr&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>你可能会想：为什么改变一个对象的字段被认为是一种“泄露”呢？我们从软件构造的3个角度来回答:</p>
<ol>
<li>safe from bug: 通过赋值改变一个字段可能会导致错误，例如赋值不匹配的类型或无意义的类型。</li>
<li>esay to understand： 赋值一个字段的行为可能是令人困惑的，尤其是当各个字段的含义并不是那么清楚的时候。</li>
<li>ready for change：一旦对象的内部表示发生变化，所有的赋值都必须手动重写。如果用方法进行赋值，则可以很方便的重构。</li>
</ol>
<p>此外，随意修改变量使得我们不能构造“immutable”的对象，这将让我们的程序充满了危险，我们不得不非常小心的应对每一次方法调用，<br>我们不知道返回之后的对象是否保持它原来的样子，这真是太可怕了！（译制腔）</p>
<p>为此，一个常见的方法是将所有字段声明为private， 并且如果要构建immutable对象的话，声明为private final.</p>
<h2 id="稍微间接一点的表示泄露-来自传递引用"><a href="#稍微间接一点的表示泄露-来自传递引用" class="headerlink" title="稍微间接一点的表示泄露-来自传递引用"></a>稍微间接一点的表示泄露-来自传递引用</h2><p>当我们把所有字段设置为私有，你可能松了口气：现在我的数据类型是安全的了。但还没结束——客户端总是需要了解ADT的“属性”，除非<br>这个ADT是一个纯粹的功能类（比如Math）。既然如此，我们必须为客户端服务，把ADT的内部表示转换为客户端感兴趣的属性。大部分情况下，属性和内部表示的对应关系是比较简单的，例如我们为Tweet类型增加获取作者、内容、发送时间的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> Twitter user who wrote the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> text of the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> date/time when the tweet was sent */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去没什么问题，客户端不能直接访问我们的内部表示，因此如果我们要修改内部表示，例如把text分为title和content，我们只需要重写getText，比如返回title + content，而无需客户端做任何改动。</p>
<p>但是还存在这样的一种情况：客户端拿到了这个属性之后，又修改了这个属性，这会发生什么呢？<br>考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a tweet that retweets t, one hour later*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tweet <span class="title">retweetLater</span><span class="params">(Tweet t)</span> </span>&#123;</span><br><span class="line">    Date d = t.getTimestamp();</span><br><span class="line">    d.setHours(d.getHours()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tweet(<span class="string">&quot;rbmllr&quot;</span>, t.getText(), d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端获取了发推时间后，把时间加了一个小时，又用这个时间创建了新的Tweet。这里的<code>d</code>是通过<code>getTimestamp()</code>获得的，而在d上调用了<br><code>setHours()</code>方法将会改变d的值！因此结果是，t和新创建的Tweet现在都指向了一小时后的时间。<br><img src="/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-17-14-39.png" alt="表示泄露-来自传递引用"><br>这个例子中，我们的getter传递了一个引用类型<code>Date</code>，一个可变数据类型。因此，在引用d上调用mutator导致了表示泄露。<br>我们该怎样修改这个代码？通过一种称之为“防御性拷贝”的方式，创建引用的一个副本。这样对返回值的修改便不会影响到对象本身。具体来讲：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就避免了getter（observor的一种）造成的访问泄露。对于所有的observor方法（返回值非空），我们都需要做如下的检查：只要返回的值不是基本数据类型，并且是可变数据类型，那么就要进行防御式拷贝。反之，如果返回值是基本数据类型或者是不可边类型，则可以直接返回。</p>
<h2 id="稍微间接一点的表示泄露-来自接收引用"><a href="#稍微间接一点的表示泄露-来自接收引用" class="headerlink" title="稍微间接一点的表示泄露-来自接收引用"></a>稍微间接一点的表示泄露-来自接收引用</h2><p>引用类型始终是危险的：ADT内部的引用类型也可能被外部的客户端程序持有，这时一旦外部引用调用了mutator，ADT的内部表示也将同步发生变化。我们来看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a list of 24 inspiring tweets, one per hour today */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Tweet&gt; <span class="title">tweetEveryHourToday</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Tweet&gt; list = <span class="keyword">new</span> ArrayList&lt;Tweet&gt;(); </span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">        date.setHours(i);</span><br><span class="line">        list.add(<span class="keyword">new</span> Tweet(<span class="string">&quot;rbmllr&quot;</span>, <span class="string">&quot;keep it up! you can do it&quot;</span>, date));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们试图创建24个Tweet，间隔1小时。然而，我们的构造器方法会直接将时间戳赋值给内部属性，因此当我们在循环中调用<code>setHours</code>时，所有Tweet内部的timestamp都将同步变化。最终，我们得到了24个时间相同的Tweet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a Tweet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0-%E5%85%B3%E4%BA%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2/2023-03-22-17-21-50.png" alt="表示泄露-接收引用"></p>
<p>为此，我们在接收引用时也要使用防御式拷贝。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，对基本数据类型和不可边数据类型，如String，不需要进行防御式拷贝。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是MIT课件中关于表示泄露的内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/11/03/RPC%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/RPC%E6%A2%B3%E7%90%86/" class="post-title-link" itemprop="url">RPC梳理</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-03 22:37:18" itemprop="dateCreated datePublished" datetime="2022-11-03T22:37:18+08:00">2022-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Erpc服务处理过程梳理"><a href="#Erpc服务处理过程梳理" class="headerlink" title="Erpc服务处理过程梳理"></a>Erpc服务处理过程梳理</h1><p>RPC的服务端处理过程从传输层开始。传输层收到消息，就会根据约定的传输协议接受信息，然后调用序列化层。序列化解析出请求内容，交由代理层处理。代理层通过对Server和Service的抽象，从请求内容中解析要调用的实际方法和参数，并根据有无返回值&#x2F;是否需要写回数据做进一步处理。<br>如果有返回消息的必要，则代理层调用序列化层写入返回内容，调用传输层用协议封装信息并进行发送</p>
<h2 id="代理层服务器开始服务"><a href="#代理层服务器开始服务" class="headerlink" title="代理层服务器开始服务"></a>代理层服务器开始服务</h2><p>一个典型的服务器启动之后便开始不断监听可能到来的请求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::run</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    <span class="keyword">while</span> ((err == kErpcStatus_Success) &amp;&amp; m_isServerOn)</span><br><span class="line">    &#123;</span><br><span class="line">        err = <span class="built_in">runInternal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理过程大致可以分为两步,一是信息处理,二是请求处理,三是数据写回.在erpc中对应 <code>runInternalBegin</code>和<code>runInternalEnd</code>,前者完成第一步,后者完成后两步.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::runInternal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MessageBuffer buff;</span><br><span class="line">    Codec *codec = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">message_type_t</span> msgType;</span><br><span class="line">    <span class="keyword">uint32_t</span> serviceId;</span><br><span class="line">    <span class="keyword">uint32_t</span> methodId;</span><br><span class="line">    <span class="keyword">uint32_t</span> sequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = <span class="built_in">runInternalBegin</span>(&amp;codec, buff, msgType, serviceId, methodId, sequence);</span><br><span class="line">    <span class="keyword">if</span> (err == kErpcStatus_Success)</span><br><span class="line">    &#123;</span><br><span class="line">        err = <span class="built_in">runInternalEnd</span>(codec, msgType, serviceId, methodId, sequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信息处理"><a href="#信息处理" class="headerlink" title="信息处理"></a>信息处理</h2><p>Server在处理消息之前,必须获取一些关键的信息用于下一步处理事件.概括来说,一般需要以下几类信息:</p>
<ul>
<li>RPC协议相关<ul>
<li>消息类型: 是单向请求信息,双向请求信息还是响应信息或系统通知等</li>
<li>RPC协议版本: 用于正确解析信息</li>
<li>序列化方法: 用于正确配置序列化层</li>
<li>请求序列号: 用于异步响应时区分多个请求</li>
</ul>
</li>
<li>代理相关<ul>
<li>请求的Service: 请求的包名&#x2F;类名&#x2F;服务名等</li>
<li>请求的Method: 请求的具体方法</li>
<li>请求的arguments: 实参</li>
<li>请求的参数类型: 用于重载解析</li>
</ul>
</li>
</ul>
<p>这些信息有的在解析完之后立刻使用;有的存放起来作为参数在调用栈中传递;有的暂时不解析,而是配置一个codec,到时按需取用.</p>
<p>从代码中可以看到,信息解析的过程主要包括传输层接收,序列化层读取两个过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::runInternalBegin</span><span class="params">(Codec **codec, MessageBuffer &amp;buff, <span class="keyword">message_type_t</span> &amp;msgType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">uint32_t</span> &amp;serviceId, <span class="keyword">uint32_t</span> &amp;methodId, <span class="keyword">uint32_t</span> &amp;sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    <span class="comment">// buffer创建</span></span><br><span class="line">    <span class="keyword">if</span> (m_messageFactory-&gt;<span class="built_in">createServerBuffer</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buff = m_messageFactory-&gt;<span class="built_in">create</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传输层接收</span></span><br><span class="line">    err = m_transport-&gt;<span class="built_in">receive</span>(&amp;buff);</span><br><span class="line">    <span class="comment">// 序列化层初始化及读取</span></span><br><span class="line">    *codec = m_codecFactory-&gt;<span class="built_in">create</span>();</span><br><span class="line">    (*codec)-&gt;<span class="built_in">setBuffer</span>(buff);</span><br><span class="line">    err = <span class="built_in">readHeadOfMessage</span>(*codec, msgType, serviceId, methodId, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传输层接收"><a href="#传输层接收" class="headerlink" title="传输层接收"></a>传输层接收</h3><p>传输层接受的部分就一句话,简而言之就是将信息读取到buffer中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传输层接收</span></span><br><span class="line"> err = m_transport-&gt;<span class="built_in">receive</span>(&amp;buff);</span><br></pre></td></tr></table></figure>

<p>erpc在这里为所有按帧传输的传输层准备了接受一帧的函数,先接受请求头,读出请求帧的长度,再接受请求体.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">FramedTransport::receive</span><span class="params">(MessageBuffer *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Header h;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> retVal;</span><br><span class="line">    <span class="keyword">uint16_t</span> computedCrc;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !ERPC_THREADS_IS(NONE)</span></span><br><span class="line">        <span class="function">Mutex::Guard <span class="title">lock</span><span class="params">(m_receiveLock)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// Receive header first.</span></span><br><span class="line">        retVal = <span class="built_in">underlyingReceive</span>((<span class="keyword">uint8_t</span> *)&amp;h, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">         <span class="comment">// Receive rest of the message now we know its size.</span></span><br><span class="line">        retVal = <span class="built_in">underlyingReceive</span>(message-&gt;<span class="built_in">get</span>(), h.m_messageSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify CRC.</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    message-&gt;<span class="built_in">setUsed</span>(h.m_messageSize);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其底层实现为<code>TCPTransport::underlyingReceive</code>,本质上就是对read进行了封装.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">TCPTransport::underlyingReceive</span><span class="params">(<span class="keyword">uint8_t</span> *data, <span class="keyword">uint32_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> length;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> status = kErpcStatus_Success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block until we have a valid connection.</span></span><br><span class="line">    <span class="keyword">while</span> (m_socket &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        Thread::<span class="built_in">sleep</span>(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Loop until all requested data is received.</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0U</span>)&#123;</span><br><span class="line">        length = <span class="built_in">read</span>(m_socket, data, size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Length will be zero if the connection is closed.</span></span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            size -= length;</span><br><span class="line">            data += length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// close socket, not server</span></span><br><span class="line">                <span class="built_in">close</span>(<span class="literal">false</span>);</span><br><span class="line">                status = kErpcStatus_ConnectionClosed;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                status = kErpcStatus_ReceiveFailed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个过程,我们将socket中的信息成功的接收到了buf中</p>
<h3 id="序列化层解析"><a href="#序列化层解析" class="headerlink" title="序列化层解析"></a>序列化层解析</h3><p>在erpc中,codec是对一次序列化的封装,一个codec不仅有读写各种数据类型的方法,还持有目前正在处理的buffer和buffer上的cursor,这纯粹是为了语法上的方便,不必在调用每个读写函数时都额外传递一个buffer参数,只需要在开始时设置即可.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    MessageBuffer m_buffer;         <span class="comment">/*!&lt; Message buffer object */</span></span><br><span class="line">    MessageBuffer::Cursor m_cursor; <span class="comment">/*!&lt; Copy data to message buffers. */</span></span><br><span class="line">    <span class="keyword">erpc_status_t</span> m_status;         <span class="comment">/*!&lt; Status of serialized data. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此,codec处理的部分先是创建一个codec并绑定buffer,然后再调用内部处理函数读取请求头</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化层初始化及读取</span></span><br><span class="line">*codec = m_codecFactory-&gt;<span class="built_in">create</span>();</span><br><span class="line">(*codec)-&gt;<span class="built_in">setBuffer</span>(buff);</span><br><span class="line">err = <span class="built_in">readHeadOfMessage</span>(*codec, msgType, serviceId, methodId, sequence);</span><br></pre></td></tr></table></figure>

<p>这里我们就不详细探究codec的底层实现了,可以想到对字节流做处理的大概方法就是针对数据类型的长度,读取一定的字节,填入到对象指针指向的内存中,并移动buffer上的cursor.</p>
<p>总体来说,在这里值得注意的地方时codec兼具序列化层和RPC传输协议约定的功能,codec的<code>readHeadOfMessage</code>的实现方法其实就对应了协议头如何组织信息.</p>
<p>在默认的codec中,请求头是一个四字节头加上一个int32序列号,四个字节分别表示codecVersion, serviceId, methodId, requestType(不过很明显,先构建codec再读取头信息已经太迟了,所以当他检测到不匹配的codecversion时没法处理,只能直接报错)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicCodec::startReadMessage</span><span class="params">(<span class="keyword">message_type_t</span> *type, <span class="keyword">uint32_t</span> *service, <span class="keyword">uint32_t</span> *request, <span class="keyword">uint32_t</span> *sequence)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> header;</span><br><span class="line">    <span class="built_in">read</span>(&amp;header);</span><br><span class="line">    <span class="keyword">if</span> (((header &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>U) != kBasicCodecVersion)&#123;</span><br><span class="line">        <span class="built_in">updateStatus</span>(kErpcStatus_InvalidMessageVersion);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStatusOk</span>())&#123;</span><br><span class="line">        *service = ((header &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>U);</span><br><span class="line">        *request = ((header &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>U);</span><br><span class="line">        *type = <span class="keyword">static_cast</span>&lt;<span class="keyword">message_type_t</span>&gt;(header &amp; <span class="number">0xff</span>U);</span><br><span class="line">        <span class="built_in">read</span>(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>在经过了信息处理之后,我们已经成功的将传输层中的一帧请求接收到buffer中,获得了这个请求的rpc协议参数,接下来要做的就是调用合适的处理程序来完成实际的处理工作.erpc中,这个函数正是<code>Server::processMessage</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">SimpleServer::runInternalEnd</span><span class="params">(Codec *codec, <span class="keyword">message_type_t</span> msgType, <span class="keyword">uint32_t</span> serviceId, <span class="keyword">uint32_t</span> methodId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">uint32_t</span> sequence)</span></span>&#123;</span><br><span class="line">    <span class="comment">//请求处理</span></span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = <span class="built_in">processMessage</span>(codec, msgType, serviceId, methodId, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息写回</span></span><br><span class="line">    <span class="keyword">if</span> (err == kErpcStatus_Success)&#123;</span><br><span class="line">        <span class="keyword">if</span> (msgType != kOnewayMessage)&#123;</span><br><span class="line">                err = m_transport-&gt;<span class="built_in">send</span>(codec-&gt;<span class="built_in">getBuffer</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Dispose of buffers and codecs.</span></span><br><span class="line">    <span class="built_in">disposeBufferAndCodec</span>(codec);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读源码,我们看到请求处理分为两个阶段:服务发现和方法调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">Server::processMessage</span><span class="params">(Codec *codec, <span class="keyword">message_type_t</span> msgType, <span class="keyword">uint32_t</span> serviceId, <span class="keyword">uint32_t</span> methodId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span> sequence)</span></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    Service *service;</span><br><span class="line">    <span class="comment">//服务发现</span></span><br><span class="line">    service = <span class="built_in">findServiceWithId</span>(serviceId);</span><br><span class="line">    <span class="comment">//方法调用</span></span><br><span class="line">    err = service-&gt;<span class="built_in">handleInvocation</span>(methodId, sequence, codec, m_messageFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现的过程就是在服务器已注册的服务中寻找能响应请求的那个,一些语言会使用map来完成这个事情,而在erpc中直接使用了serviceId+methodId, 如果idl确定的话,对于S&#x2F;C端而言,这个id号是可以唯一确定有效服务的.</p>
<p>在服务端,服务用链表存储:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">getServiceId</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_serviceId; &#125;</span><br><span class="line">    <span class="function">Service *<span class="title">getNext</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> m_next; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Service *next)</span> </span>&#123; m_next = next; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">erpc_status_t</span> <span class="title">handleInvocation</span><span class="params">(<span class="keyword">uint32_t</span> methodId, <span class="keyword">uint32_t</span> sequence, Codec *codec,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           MessageBufferFactory *messageFactory)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> m_serviceId; <span class="comment">/*!&lt; Service unique id. */</span></span><br><span class="line">    Service *m_next;      <span class="comment">/*!&lt; Pointer to next service. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器在解析信息时通过遍历链表查找id对应的服务,然后调用对应的处理函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">Server::processMessage</span><span class="params">(Codec *codec, <span class="keyword">message_type_t</span> msgType, <span class="keyword">uint32_t</span> serviceId, <span class="keyword">uint32_t</span> methodId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    Service *service;</span><br><span class="line">    service = <span class="built_in">findServiceWithId</span>(serviceId);</span><br><span class="line">    err = service-&gt;<span class="built_in">handleInvocation</span>(methodId, sequence, codec, m_messageFactory);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><code>Server::processMessage</code>调用的<code>Service::handleInvocation</code>是由erpcgen工具根据我们定义的IDL自动生成的.<br>在.erpc中声明service及其方法, 其中interface关键字后跟服务名, 花括号内可以有若干个方法.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MatrixMultiplyService <span class="comment">// cover functions for same topic</span></span><br><span class="line">&#123;</span><br><span class="line">    erpcMatrixMultiply(in Matrix matrix1, in Matrix matrix2, out Matrix result_matrix) -&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行下列命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erpcgen idl.erpc -g c</span><br></pre></td></tr></table></figure>

<p>即可得到生成的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">erpc_matrix_multiply_client.c++</span><br><span class="line">erpc_matrix_multiply_server.c++</span><br><span class="line">erpc_matrix_multiply_server.h</span><br><span class="line">erpc_matrix_multiply.h</span><br></pre></td></tr></table></figure>

<p>其中,<code>erpc_matrix_multiply_server.c++</code>就有服务处理函数的定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">MatrixMultiplyService_service::handleInvocation</span><span class="params">(<span class="keyword">uint32_t</span> methodId, <span class="keyword">uint32_t</span> sequence, Codec * codec, MessageBufferFactory *messageFactory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> erpcStatus;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (methodId)&#123;</span><br><span class="line">        <span class="keyword">case</span> kMatrixMultiplyService_erpcMatrixMultiply_id:</span><br><span class="line">            erpcStatus = <span class="built_in">erpcMatrixMultiply_shim</span>(codec, messageFactory, sequence);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            erpcStatus = kErpcStatus_InvalidArgument;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> erpcStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, 处理函数进一步通过methodId判断该调用Service中的哪个方法的shim, 这个shim就是方法对应的代理.<br>代理完成的内容就是组织codec进行反序列化, 获取入参,然后对out类型的数据进行序列化写回, 返回值也一并写回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">MatrixMultiplyService_service::erpcMatrixMultiply_shim</span><span class="params">(Codec * codec, MessageBufferFactory *messageFactory, <span class="keyword">uint32_t</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line"></span><br><span class="line">    Matrix matrix1;</span><br><span class="line">    Matrix matrix2;</span><br><span class="line">    Matrix result_matrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)&#123;</span><br><span class="line">            codec-&gt;<span class="built_in">read</span>(&amp;matrix1[arrayCount0][arrayCount1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)&#123;</span><br><span class="line">            codec-&gt;<span class="built_in">read</span>(&amp;matrix2[arrayCount0][arrayCount1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// preparing codec for serializing data</span></span><br><span class="line">    codec-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用实际方法</span></span><br><span class="line">    <span class="built_in">erpcMatrixMultiply</span>(matrix1, matrix2, result_matrix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build response message.</span></span><br><span class="line">    codec-&gt;<span class="built_in">startWriteMessage</span>(kReplyMessage, kMatrixMultiplyService_service_id, kMatrixMultiplyService_erpcMatrixMultiply_id, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)&#123;</span><br><span class="line">                codec-&gt;<span class="built_in">write</span>(result_matrix[arrayCount0][arrayCount1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据写回"><a href="#数据写回" class="headerlink" title="数据写回"></a>数据写回</h3><p>首先需要注意的是,在调用实际方法之前,对codec进行了重置:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// preparing codec for serializing data</span></span><br><span class="line">    codec-&gt;<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure>

<p>这个重置函数将内部的buffer和cursor恢复到使用之前的状态,相当于将这个读缓冲区又作为写缓冲区复用.在写回过程中，序列化首先调用codec的startWriteMessage方法写回响应头.和我们之前谈到的一样,这一步也是和RPC协议相关的,即codec写入头消息的方式就是rpc协议的方式.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicCodec::startWriteMessage</span><span class="params">(<span class="keyword">message_type_t</span> type, <span class="keyword">uint32_t</span> service, <span class="keyword">uint32_t</span> request, <span class="keyword">uint32_t</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> header =</span><br><span class="line">        (kBasicCodecVersion &lt;&lt; <span class="number">24u</span>) | ((service &amp; <span class="number">0xff</span>u) &lt;&lt; <span class="number">16u</span>) | ((request &amp; <span class="number">0xff</span>u) &lt;&lt; <span class="number">8u</span>) | ((<span class="keyword">uint32_t</span>)type &amp; <span class="number">0xff</span>u);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(header);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, 调用Codec的write方法.在这里,对于数组,erpcgen将会自动生成对应的循环结构来写入.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    ...    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount0 = <span class="number">0U</span>; arrayCount0 &lt; <span class="number">2U</span>; ++arrayCount0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> arrayCount1 = <span class="number">0U</span>; arrayCount1 &lt; <span class="number">2U</span>; ++arrayCount1)</span><br><span class="line">            &#123;</span><br><span class="line">                codec-&gt;<span class="built_in">write</span>(result_matrix[arrayCount0][arrayCount1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Codec对c++的所有数据类型重载一个write方法, 这个方法是对writeData的封装, 后者将按照数据的值和长度传递写入数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicCodec::writeData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">uint32_t</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStatusOk</span>())&#123;</span><br><span class="line">        m_status = m_cursor.<span class="built_in">write</span>(value, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cursor将作为buffer的内部类完成信息的写入，就是将信息复制到缓冲区里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">erpc_status_t</span> MessageBuffer::Cursor::<span class="built_in">write</span>(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">uint32_t</span> length)&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0U</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            err = kErpcStatus_MemoryError;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (length &gt; <span class="built_in">getRemaining</span>())&#123;</span><br><span class="line">            err = kErpcStatus_BufferOverrun;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            (<span class="keyword">void</span>)<span class="built_in">memcpy</span>(m_pos, data, length);</span><br><span class="line">            m_pos += length;</span><br><span class="line">            m_buffer-&gt;<span class="built_in">setUsed</span>(m_buffer-&gt;<span class="built_in">getUsed</span>() + length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成write之后shim就会直接返回,之后可以直接利用send发送,因为我们在生成的shim函数中已经完成了需要写回的数据的序列化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据发送</span></span><br><span class="line"><span class="keyword">if</span> (err == kErpcStatus_Success)&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgType != kOnewayMessage)&#123;</span><br><span class="line">            err = m_transport-&gt;<span class="built_in">send</span>(codec-&gt;<span class="built_in">getBuffer</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/" class="post-title-link" itemprop="url">RPC框架设计侧重点-特色和架构调研2.md</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-02 16:26:48" itemprop="dateCreated datePublished" datetime="2022-10-02T16:26:48+08:00">2022-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-03 20:35:34" itemprop="dateModified" datetime="2022-10-03T20:35:34+08:00">2022-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a><a target="_blank" rel="noopener" href="https://github.com/apache/thrift">Thrift</a></h2><p>Thrift 是用于点对点 RPC 实现的轻量级、跨语言的软件栈。Thrift，为传输、序列化、应用级逻辑都提供了实现，同时具有从idl生成代码的功能。</p>
<p>Thrift将架构分为6层，每层都可以自由组合，以适应不同的需求。<br><img src="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/thrift%E6%8A%80%E6%9C%AF%E6%A0%88.png" alt="1"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">├── ...(一些构建相关)</span><br><span class="line">├── compiler</span><br><span class="line">│   └── cpp</span><br><span class="line">├── debian</span><br><span class="line">├── lib             #代码实现</span><br><span class="line">│   ├── c_glib/src/thrift</span><br><span class="line">|       ├── processor                               #处理请求</span><br><span class="line">|       │   ├── thrift_dispatch_processor.c         #实现,使用glib-object完成面向对象</span><br><span class="line">|       │   ├── thrift_dispatch_processor.h</span><br><span class="line">|       │   ├── thrift_multiplexed_processor.c      #提供多个处理器</span><br><span class="line">|       │   ├── thrift_multiplexed_processor.h</span><br><span class="line">|       │   ├── thrift_processor.c                  #接口</span><br><span class="line">|       │   └── thrift_processor.h</span><br><span class="line">|       ├── protocol</span><br><span class="line">|       │   ├── thrift_binary_protocol.c            #二进制协议的实现,把数据转化为合适的形式(bool转化为uint8, double转化为IEEE int64等)</span><br><span class="line">|       │   ├── thrift_binary_protocol.h</span><br><span class="line">|       │   ├── thrift_binary_protocol_factory.c</span><br><span class="line">|       │   ├── thrift_binary_protocol_factory.h</span><br><span class="line">|       │   ├── thrift_compact_protocol.c</span><br><span class="line">|       │   ├── thrift_compact_protocol.h</span><br><span class="line">|       │   ├── thrift_compact_protocol_factory.c</span><br><span class="line">|       │   ├── thrift_compact_protocol_factory.h</span><br><span class="line">|       │   ├── thrift_multiplexed_protocol.c</span><br><span class="line">|       │   ├── thrift_multiplexed_protocol.h</span><br><span class="line">|       │   ├── thrift_protocol.c                   #写入数据,`THRIFT_PROTOCOL_GET_CLASS (protocol)-&gt;write`</span><br><span class="line">|       │   ├── thrift_protocol.h</span><br><span class="line">|       │   ├── thrift_protocol_decorator.c         #用decorator模式提供了多协议`THRIFT_PROTOCOL_GET_CLASS (self-&gt;concrete_protocol)-&gt;write_struct_begin (self-&gt;concrete_protocol,name, error)`</span><br><span class="line">|       │   ├── thrift_protocol_decorator.h</span><br><span class="line">|       │   ├── thrift_protocol_factory.c</span><br><span class="line">|       │   ├── thrift_protocol_factory.h</span><br><span class="line">|       │   ├── thrift_stored_message_protocol.c</span><br><span class="line">|       │   └── thrift_stored_message_protocol.h</span><br><span class="line">|       ├── server</span><br><span class="line">|       │   ├── thrift_server.c                 #服务器抽象类</span><br><span class="line">|       │   ├── thrift_server.h                 </span><br><span class="line">|       │   ├── thrift_simple_server.c          #简单实现</span><br><span class="line">|       │   └── thrift_simple_server.h</span><br><span class="line">|       ├── thrift.c</span><br><span class="line">|       ├── thrift.h</span><br><span class="line">|       ├── thrift_application_exception.c</span><br><span class="line">|       ├── thrift_application_exception.h</span><br><span class="line">|       ├── thrift_configuration.c</span><br><span class="line">|       ├── thrift_configuration.h</span><br><span class="line">|       ├── thrift_struct.c</span><br><span class="line">|       ├── thrift_struct.h</span><br><span class="line">|       └── transport</span><br><span class="line">|           ├── thrift_buffered_transport.c</span><br><span class="line">|           ├── thrift_buffered_transport.h</span><br><span class="line">|           ├── thrift_buffered_transport_factory.c</span><br><span class="line">|           ├── thrift_buffered_transport_factory.h</span><br><span class="line">|           ├── thrift_fd_transport.c</span><br><span class="line">|           ├── thrift_fd_transport.h</span><br><span class="line">|           ├── thrift_framed_transport.c</span><br><span class="line">|           ├── thrift_framed_transport.h</span><br><span class="line">|           ├── thrift_framed_transport_factory.c</span><br><span class="line">|           ├── thrift_framed_transport_factory.h</span><br><span class="line">|           ├── thrift_memory_buffer.c</span><br><span class="line">|           ├── thrift_memory_buffer.h</span><br><span class="line">|           ├── thrift_platform_socket.h</span><br><span class="line">|           ├── thrift_server_socket.c</span><br><span class="line">|           ├── thrift_server_socket.h          </span><br><span class="line">|           ├── thrift_server_transport.c</span><br><span class="line">|           ├── thrift_server_transport.h</span><br><span class="line">|           ├── thrift_socket.c</span><br><span class="line">|           ├── thrift_socket.h</span><br><span class="line">|           ├── thrift_ssl_socket.c</span><br><span class="line">|           ├── thrift_ssl_socket.h</span><br><span class="line">|           ├── thrift_transport.c</span><br><span class="line">|           ├── thrift_transport.h</span><br><span class="line">|           ├── thrift_transport_factory.c</span><br><span class="line">|           ├── thrift_transport_factory.h</span><br><span class="line">|           ├── thrift_zlib_transport.c</span><br><span class="line">|           ├── thrift_zlib_transport.h</span><br><span class="line">|           ├── thrift_zlib_transport_factory.c</span><br><span class="line">|           └── thrift_zlib_transport_factory.h</span><br><span class="line">|   ...</span><br><span class="line">|</span><br><span class="line">├── contrib         #一些实例,但不是官方测试用例</span><br><span class="line">├── test            #测试用例</span><br><span class="line">├── doc</span><br><span class="line">│   ├── specs       #一些格式信息</span><br><span class="line">|       ├── HeaderFormat.md                 #请求头格式</span><br><span class="line">|       ├── SequenceNumbers.md              #序列号(用于在一个链接中异步处理多个请求)</span><br><span class="line">|       ├── idl.md                          #接口定义语言</span><br><span class="line">|       ├── thrift-binary-protocol.md       #二进制协议, TLV格式</span><br><span class="line">|       ├── thrift-compact-protocol.md      #压缩方式 zigzag压缩整数, 其他的似乎编码没有太大不同?</span><br><span class="line">|       ├── thrift-parameter-validation-proposal.md     #参数验证,也就是通过某些方式限定参数的取值范围.比如int32类型必须取1,2,4,或者限定某个字符串长度必须大于4</span><br><span class="line">|       ├── thrift-protocol-spec.md         #BNF</span><br><span class="line">|       ├── thrift-rpc.md                   #框架整体简介</span><br><span class="line">|       ├── thrift-sasl-spec.txt            #(Simple Authentication and Security Layer)</span><br><span class="line">|       ├── thrift-tconfiguration.md        #一些设置</span><br><span class="line">|       └── thrift.tex</span><br><span class="line">│       └── ...         #没啥用</span><br><span class="line">└── tutorial        #教程</span><br><span class="line">    ├── c_glib</span><br><span class="line">    ...</span><br><span class="line">    └── swift</span><br></pre></td></tr></table></figure>

<h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><p>Thrift 专门设计用于支持跨客户端和服务器代码的非原子版本更改。这使您可以升级服务器，同时仍然能够为旧客户端提供服务；或让较新的客户端向较旧的服务器发出请求。</p>
<h2 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a><a target="_blank" rel="noopener" href="https://github.com/weibocom/motan/wiki/zh_overview">Motan</a></h2><p>Motan是一套基于java开发的RPC框架，除了常规的点对点调用外，Motan还提供服务治理功能，包括服务节点的自动发现、摘除、高可用和负载均衡等。</p>
<p>Motan具有良好的扩展性，主要模块都提供了多种不同的实现，例如支持多种注册中心，支持多种rpc协议等。</p>
<h3 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a><a target="_blank" rel="noopener" href="https://github.com/weibocom/motan/wiki/zh_userguide#%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0">架构概述</a></h3><p><img src="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0.png" alt="2"><br>默认序列化: Hessian2, 默认传输层: Netty NIO TCP长连接</p>
<ul>
<li><p>register:<br>用来和注册中心进行交互，包括注册服务、订阅服务、服务变更通知、服务心跳发送等功能；Server端会在系统初始化时通过register模块注册服务，Client端在系统初始化时会通过register模块订阅到具体提供服务的Server列表，当Server 列表发生变更时也由register模块通知Client。</p>
</li>
<li><p>Cluster:<br>cluster是一组可用的Server在逻辑上的封装，包含若干可以提供RPC服务的Server，实际请求时会根据不同的高可用与负载均衡策略选择一个可用的Server发起远程调用。</p>
<p>在进行RPC请求时，Client通过代理机制调用cluster模块，cluster根据配置的HA和LoadBalance选出一个可用的Server，通过serialize模块把RPC请求转换为字节流，然后通过transport模块发送到Server端。</p>
</li>
</ul>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">├── closable</span><br><span class="line">├── cluster</span><br><span class="line">│   ├── ha</span><br><span class="line">│   ├── loadbalance</span><br><span class="line">│   └── support</span><br><span class="line">├── codec</span><br><span class="line">├── common</span><br><span class="line">├── config</span><br><span class="line">│   ├── annotation</span><br><span class="line">│   └── handler</span><br><span class="line">├── core</span><br><span class="line">│   └── extension</span><br><span class="line">├── exception</span><br><span class="line">├── filter</span><br><span class="line">├── log</span><br><span class="line">├── protocol</span><br><span class="line">│   ├── injvm</span><br><span class="line">│   ├── mock</span><br><span class="line">│   ├── rpc</span><br><span class="line">│   ├── support</span><br><span class="line">│   └── v2motan</span><br><span class="line">├── proxy</span><br><span class="line">│   └── spi</span><br><span class="line">├── registry    #服务注册:发现注册/变更通知/流量配置/失败返回</span><br><span class="line">│   └── support</span><br><span class="line">│       └── command</span><br><span class="line">├── rpc         #奇怪的工具类 Callbackable/Future/Node/Refer/Request/...Response</span><br><span class="line">│   └── init</span><br><span class="line">├── serialize   #FastJson, Hessian2, Breeze, Simple</span><br><span class="line">├── switcher</span><br><span class="line">├── transport   #Channel/Transport/Server绑定/Clent心跳/..</span><br><span class="line">│   ├── async</span><br><span class="line">│   └── support</span><br><span class="line">└── util        #Math/Net/Stats/Reflect/....</span><br></pre></td></tr></table></figure>

<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo</a></h2><ul>
<li>基于透明接口的 RPC</li>
<li>智能负载均衡</li>
<li>自动服务注册和发现</li>
<li>高扩展性</li>
<li>运行时流量路由</li>
<li>可视化服务治理</li>
</ul>
<h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p><img src="/2022/10/02/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%942/Dubbo%E6%9E%B6%E6%9E%84.png" alt="3"></p>
<p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/docs/v2.7/dev/design/">代码架构和设计内容像详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">RPC框架设计侧重点, 特色和架构调研</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 16:53:30" itemprop="dateCreated datePublished" datetime="2022-09-25T16:53:30+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 21:19:12" itemprop="dateModified" datetime="2022-10-24T21:19:12+08:00">2022-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Volo调研"><a href="#Volo调研" class="headerlink" title="Volo调研"></a>Volo调研</h2><p>Volo 是字节跳动服务框架团队研发的轻量级、高性能、可扩展性强、易用性好的 Rust RPC 框架，使用了 Rust 最新的 GAT 特性。</p>
<h3 id="特色-易用性"><a href="#特色-易用性" class="headerlink" title="特色-易用性"></a>特色-易用性</h3><p>具体来说，这个框架使用了<a target="_blank" rel="noopener" href="https://github.com/cloudwego/motore">motore</a>中间件, 而其使用GAT语法完成了<a target="_blank" rel="noopener" href="https://github.com/cloudwego/motore">高效的异步接口</a></p>
<p>Rust不支持一个<code>async trait</code>, 一般的解决方法是使用Box(类似智能指针)来完成这件事情, <a target="_blank" rel="noopener" href="https://www.cloudwego.io/zh/docs/motore/faq/q1_gat/">但这会</a>带来额外的开销并且降低代码可读性. 有一个使用宏完成用Box实现异步接口的<a target="_blank" rel="noopener" href="https://docs.rs/async-trait/latest/async_trait/">Crate</a></p>
<p>具体细节可能需要进一步理解一些Rust的语言特性</p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">├─volo          RPC框架的通用组件</span><br><span class="line">│  └─src  </span><br><span class="line">│      ├─discovery      #服务发现:一些接口,一种简单实现(返回静态单链表)</span><br><span class="line">│      ├─loadbalance    #负载均衡:同上(加权随机)</span><br><span class="line">│      ├─net            #网络链接: probe创建套接字,dial建立连接,incomming进行监听,conn进行读写 </span><br><span class="line">│      └─util           #工具: buf_reader</span><br><span class="line">|                       #</span><br><span class="line">├─volo-build    #编译用</span><br><span class="line">│  └─src</span><br><span class="line">├─volo-cli      #用户界面</span><br><span class="line">│  └─...</span><br><span class="line">├─volo-grpc     #grpc框架</span><br><span class="line">│  └─src</span><br><span class="line">│      ├─client         #客户端底层组件</span><br><span class="line">│      ├─codec          #编解码器</span><br><span class="line">│      ├─layer          #待调研,类似某种封装tonic/src/metadata</span><br><span class="line">│      │  └─loadbalance</span><br><span class="line">│      ├─metadata</span><br><span class="line">│      ├─server         #服务端底层组件</span><br><span class="line">│      └─transport</span><br><span class="line">    ...                 #从tonic/src/中copy并修改了一些文件,完成rpc的请求响应相关工作</span><br><span class="line">├─volo-macros   #宏</span><br><span class="line">│  └─src</span><br><span class="line">└─volo-thrift   #thrift框架</span><br><span class="line">    └─src</span><br><span class="line">        ├─client</span><br><span class="line">        │  └─layer</span><br><span class="line">        ├─codec</span><br><span class="line">        ├─protocol</span><br><span class="line">        └─transport</span><br><span class="line">            ├─pingpong</span><br><span class="line">            └─pool</span><br></pre></td></tr></table></figure>

<p><strong>如何用Volo的特色实现grpc</strong><br><img src="/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/2022-09-25-16-54-19.png" alt="架构图"></p>
<h3 id="erpc"><a href="#erpc" class="headerlink" title="erpc"></a>erpc</h3><p><strong>传输层(串口),嵌入式,代码生成(结合nanopb)</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/EmbeddedRPC/erpc">erpc项目地址</a>及其<a target="_blank" rel="noopener" href="https://embeddedrpc.github.io/eRPC">详细文档</a></p>
<h3 id="侧重点"><a href="#侧重点" class="headerlink" title="侧重点"></a>侧重点</h3><p>嵌入式,轻量化</p>
<h3 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">├─erpcgen           #代码生成工具</span><br><span class="line">├─erpcsniffer</span><br><span class="line">│  └─src</span><br><span class="line">├─erpc_c            #基础架构</span><br><span class="line">│  ├─config         #config.h配置文件 </span><br><span class="line">│  └─infra</span><br><span class="line">|     ├─ erpc_arbitrated_client_manager.cpp</span><br><span class="line">|     ├─ erpc_arbitrated_client_manager.hpp</span><br><span class="line">|     ├─ erpc_basic_codec.cpp      #基础编解码器</span><br><span class="line">|     ├─ erpc_basic_codec.hpp</span><br><span class="line">|     ├─ erpc_client_manager.cpp</span><br><span class="line">|     ├─ erpc_client_manager.h</span><br><span class="line">|     ├─ erpc_client_server_common.hpp</span><br><span class="line">|     ├─ erpc_codec.hpp             #编解码器抽象定义</span><br><span class="line">|     ├─ erpc_common.h              #状态码枚举类型的定义</span><br><span class="line">|     ├─ erpc_crc16.cpp</span><br><span class="line">|     ├─ erpc_crc16.hpp</span><br><span class="line">|     ├─ erpc_framed_transport.cpp</span><br><span class="line">|     ├─ erpc_framed_transport.hpp</span><br><span class="line">|     ├─ erpc_manually_constructed.hpp</span><br><span class="line">|     ├─ erpc_message_buffer.cpp</span><br><span class="line">|     ├─ erpc_message_buffer.hpp</span><br><span class="line">|     ├─ erpc_message_loggers.cpp</span><br><span class="line">|     ├─ erpc_message_loggers.hpp</span><br><span class="line">|     ├─ erpc_pre_post_action.cpp</span><br><span class="line">|     ├─ erpc_pre_post_action.h</span><br><span class="line">|     ├─ erpc_server.cpp            </span><br><span class="line">|     ├─ erpc_server.hpp            #Service和Server的抽象接口,注册移除服务,处理信息等</span><br><span class="line">|     ├─ erpc_simple_server.cpp     #</span><br><span class="line">|     ├─ erpc_simple_server.hpp</span><br><span class="line">|     ├─ erpc_static_queue.hpp      #数组实现的队列</span><br><span class="line">|     ├─ erpc_transport.hpp         #Transport</span><br><span class="line">|     ├─ erpc_transport_arbitrator.cpp</span><br><span class="line">|     ├─ erpc_transport_arbitrator.hpp</span><br><span class="line">|     ├─ erpc_version.h</span><br><span class="line">|     ├─ infra.dox     </span><br><span class="line">│  ├─port           #便于移植</span><br><span class="line">│  ├─setup          #C语言接口</span><br><span class="line">│  └─transports     #支持不同通信方法的工具类</span><br><span class="line">├─erpc_python</span><br><span class="line">│  └─erpc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<ul>
<li>rtos上的 protobuf-c</li>
<li>erpc 传输层 nanopb</li>
<li>volo 语法特性</li>
<li>motan dubbo 事件逻辑</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/" class="post-title-link" itemprop="url">grpc-go源码分析(1)</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-04 14:43:36" itemprop="dateCreated datePublished" datetime="2022-09-04T14:43:36+08:00">2022-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要分析了grpc-go服务端的启动过程，重点考察了服务端的建立、注册、监听<br>等关键的生命周期对应的代码实现。<br>目前阶段主要考察普通的rpc调用，暂时没有研究流式传输。</p>
<p>首先来看服务端<code>examples/helloworld/greeter_server/main.go</code>的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解析命令行参数,主要是port</span></span><br><span class="line">    flag.Parse()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建一个对本地端口的监听</span></span><br><span class="line">    lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建grpc服务器</span></span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册protobuf中的服务</span></span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监听</span></span><br><span class="line">    <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, main函数中和server相关的操作主要有三步:<br>（1）创建 server<br>（2）server 的注册<br>（3）调用 Serve 监听端口并处理请求</p>
<h2 id="Server的创建"><a href="#Server的创建" class="headerlink" title="Server的创建"></a>Server的创建</h2><p>这里调用的函数就是<code>\server.go#NewServer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(opt ...ServerOption)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    <span class="comment">//用option模式指定各个服务器选项</span></span><br><span class="line">    opts := defaultServerOptions</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> extraServerOptions &#123;</span><br><span class="line">        o.apply(&amp;opts)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opt &#123;</span><br><span class="line">        o.apply(&amp;opts)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建服务器</span></span><br><span class="line">    s := &amp;Server&#123;</span><br><span class="line">        lis:      <span class="built_in">make</span>(<span class="keyword">map</span>[net.Listener]<span class="keyword">bool</span>),</span><br><span class="line">        opts:     opts,</span><br><span class="line">        conns:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[transport.ServerTransport]<span class="keyword">bool</span>),</span><br><span class="line">        services: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*serviceInfo),</span><br><span class="line">        quit:     grpcsync.NewEvent(),</span><br><span class="line">        done:     grpcsync.NewEvent(),</span><br><span class="line">        czData:   <span class="built_in">new</span>(channelzData),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置拦截器</span></span><br><span class="line">    chainUnaryServerInterceptors(s)</span><br><span class="line">    chainStreamServerInterceptors(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步相关(优雅退出时发送信号)</span></span><br><span class="line">    s.cv = sync.NewCond(&amp;s.mu)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试相关 打印调用信息</span></span><br><span class="line">    <span class="keyword">if</span> EnableTracing &#123;</span><br><span class="line">        _, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">        s.events = trace.NewEventLog(<span class="string">&quot;grpc.Server&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, file, line))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发相关</span></span><br><span class="line">    <span class="keyword">if</span> s.opts.numServerWorkers &gt; <span class="number">0</span> &#123;</span><br><span class="line">        s.initServerWorkers()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// channelz(一个调试工具)相关</span></span><br><span class="line">    s.channelzID = channelz.RegisterServer(&amp;channelzServer&#123;s&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    channelz.Info(logger, s.channelzID, <span class="string">&quot;Server created&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个Server结构体包括了一系列网络通讯和同步相关的内容，通常是使用了sync包中的功能或利用通道完成各种同步操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server is a gRPC server to serve RPC requests.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    opts serverOptions</span><br><span class="line"></span><br><span class="line">    mu  sync.Mutex <span class="comment">// guards following</span></span><br><span class="line"></span><br><span class="line">    lis <span class="keyword">map</span>[net.Listener]<span class="keyword">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听地址到 transports的映射</span></span><br><span class="line">    conns    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[transport.ServerTransport]<span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 是否在服务</span></span><br><span class="line">    serve    <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    drain    <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 优雅退出时进行广播</span></span><br><span class="line">    cv       *sync.Cond          </span><br><span class="line">    <span class="comment">// 核心:服务名到服务信息的映射</span></span><br><span class="line">    services <span class="keyword">map</span>[<span class="keyword">string</span>]*serviceInfo</span><br><span class="line">    <span class="comment">// 日志 </span></span><br><span class="line">    events   trace.EventLog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步相关</span></span><br><span class="line">    quit               *grpcsync.Event</span><br><span class="line">    done               *grpcsync.Event</span><br><span class="line">    channelzRemoveOnce sync.Once</span><br><span class="line">    serveWG            sync.WaitGroup <span class="comment">// counts active Serve goroutines for GracefulStop</span></span><br><span class="line"></span><br><span class="line">    channelzID *channelz.Identifier</span><br><span class="line">    czData     *channelzData</span><br><span class="line"></span><br><span class="line">    serverWorkerChannels []<span class="keyword">chan</span> *serverWorkerData</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="用于同步的grpc-Event"><a href="#用于同步的grpc-Event" class="headerlink" title="用于同步的grpc.Event"></a>用于同步的grpc.Event</h3><p>对于Event类型的quit和done，这里简单的分析一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Event represents a one-time event that may occur in the future.</span></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">    fired <span class="keyword">int32</span></span><br><span class="line">    c     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    o     sync.Once</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Event可以被并发地多次触发。一旦被触发，e.c将被关闭，从而所有试图从e.c中接受一个值的协程将从阻塞中恢复，这起到了一对多通知的效果。o是为了防止e.c被多次关闭而引发panic。</p>
<h3 id="核心部分：map-string"><a href="#核心部分：map-string" class="headerlink" title="核心部分：map[string]"></a>核心部分：<code>map[string]</code></h3><p>而这一部分代码中的核心还是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services <span class="keyword">map</span>[<span class="keyword">string</span>]*serviceInfo</span><br></pre></td></tr></table></figure>

<p>通过服务名，我们可以直接获取服务相关的信息，主要也是两个map，通过名称可以分别获取stream和method的描述（Desc）。每个描述都包含了name和handler</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serviceInfo wraps information about a service. It is very similar to</span></span><br><span class="line"><span class="comment">// ServiceDesc and is constructed from it for internal purposes.</span></span><br><span class="line"><span class="keyword">type</span> serviceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Contains the implementation for the methods in this service.</span></span><br><span class="line">    serviceImpl <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    methods     <span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc</span><br><span class="line">    streams     <span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc</span><br><span class="line">    mdata       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，在调用过程中Server的关键结构是这样的：</p>
<p><img src="/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/2022-09-04-16-04-53.png" alt="grpc-go源码分析"></p>
<h2 id="Server注册"><a href="#Server注册" class="headerlink" title="Server注册"></a>Server注册</h2><p>main函数中的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册protobuf中的服务</span></span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>需要先考察一下server是一个什么样的结构</p>
<h3 id="自定义的服务器实现：Server类型"><a href="#自定义的服务器实现：Server类型" class="headerlink" title="自定义的服务器实现：Server类型"></a>自定义的服务器实现：Server类型</h3><p>在<code>examples/helloworld/greeter_server/main.go</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实际上就是对proto中定义的服务端的一个实现, 注意接口中要求的方法<code>mustEmbedUnimplementedGreeterServer()</code>是在protobuf的生成文件pb中的<code>pb.UnimplementedGreeterServer</code>中实现的，这是为了从语法上要求server的实现中必须包含<code>pb.UnimplementedGreeterServer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GreeterServer is the server API for Greeter service.</span></span><br><span class="line"><span class="comment">// All implementations must embed UnimplementedGreeterServer</span></span><br><span class="line"><span class="comment">// for forward compatibility</span></span><br><span class="line"><span class="keyword">type</span> GreeterServer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Sends a greeting</span></span><br><span class="line">    SayHello(context.Context, *HelloRequest) (*HelloReply, error)</span><br><span class="line">    mustEmbedUnimplementedGreeterServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么必须包含这个奇怪的结构体，可能是因为这个结构体中包含了一个默认的SayHello方法，这样即使我们忘了实现SayHello方法，也能让server实现<code>GreeterServer</code>接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedGreeterServer)</span> <span class="title">SayHello</span><span class="params">(context.Context, *HelloRequest)</span> <span class="params">(*HelloReply, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unimplemented, <span class="string">&quot;method SayHello not implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedGreeterServer)</span> <span class="title">mustEmbedUnimplementedGreeterServer</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总而言之，Server就是一个我们自己实现的服务器。包含了我们在proto中声明的方法。</p>
<h3 id="Register调用分析"><a href="#Register调用分析" class="headerlink" title="Register调用分析"></a>Register调用分析</h3><p>main函数中直接调用的方法是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册protobuf中的服务</span></span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>server 的注册调用了 RegisterGreeterServer 方法，这个方法是<code>examples/helloworld/helloworld/helloworld_grpc.pb.go</code>中的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterGreeterServer</span><span class="params">(s *grpc.Server, srv GreeterServer)</span></span> &#123;</span><br><span class="line">    s.RegisterService(&amp;Greeter_serviceDesc, srv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法调用了 server 的 RegisterService 方法，然后传入了一个 ServiceDesc 的数据结构，如下 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeter_ServiceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">    ServiceName: <span class="string">&quot;helloworld.Greeter&quot;</span>,</span><br><span class="line">    HandlerType: (*GreeterServer)(<span class="literal">nil</span>),</span><br><span class="line">    Methods: []grpc.MethodDesc&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            MethodName: <span class="string">&quot;SayHello&quot;</span>,</span><br><span class="line">            Handler:    _Greeter_SayHello_Handler,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Streams:  []grpc.StreamDesc&#123;&#125;,</span><br><span class="line">    Metadata: <span class="string">&quot;examples/helloworld/helloworld/helloworld.proto&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个结构体的结构serviceInfo的结构是吻合的：<br><img src="/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/2022-09-04-16-04-53.png" alt="grpc"></p>
<p>下面来看RegisterService函数的实现，核心的内容在就是检查完类型之后调用register将sd中的信息注入到seviceinfo结构体中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterService registers a service and its implementation to the gRPC</span></span><br><span class="line"><span class="comment">// server. It is called from the IDL generated code. This must be called before</span></span><br><span class="line"><span class="comment">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to</span></span><br><span class="line"><span class="comment">// ensure it implements sd.HandlerType.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterService</span><span class="params">(sd*ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查类型</span></span><br><span class="line">    <span class="keyword">if</span> ss != <span class="literal">nil</span> &#123;</span><br><span class="line">        ht := reflect.TypeOf(sd.HandlerType).Elem()</span><br><span class="line">        st := reflect.TypeOf(ss)</span><br><span class="line">        <span class="keyword">if</span> !st.Implements(ht) &#123;</span><br><span class="line">            logger.Fatalf(<span class="string">&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;</span>, st, ht)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.register(sd, ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">register</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    s.printf(<span class="string">&quot;RegisterService(%q)&quot;</span>, sd.ServiceName)</span><br><span class="line">    <span class="comment">// 检查异常</span></span><br><span class="line">    <span class="keyword">if</span> s.serve &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;</span>, sd.ServiceName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := s.services[sd.ServiceName]; ok &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;</span>, sd.ServiceName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将sd中的内容注入到serviceinfo中，并将ss类型保存为serviceImpl</span></span><br><span class="line">    info := &amp;serviceInfo&#123;</span><br><span class="line">        serviceImpl: ss,</span><br><span class="line">        methods:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc),</span><br><span class="line">        streams:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc),</span><br><span class="line">        mdata:       sd.Metadata,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> sd.Methods &#123;</span><br><span class="line">        d := &amp;sd.Methods[i]</span><br><span class="line">        info.methods[d.MethodName] = d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> sd.Streams &#123;</span><br><span class="line">        d := &amp;sd.Streams[i]</span><br><span class="line">        info.streams[d.StreamName] = d</span><br><span class="line">    &#125;</span><br><span class="line">    s.services[sd.ServiceName] = info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server 对不同 rpc 请求的处理，也是根据 service 中不同的 serviceName 去 service map 中取出不同的 handler 进行处理，这样相当于完成了grpc的代理操作，把字符串传递给代理，代理就能调用对应的实际方法去处理。</p>
<h3 id="Sever服务过程"><a href="#Sever服务过程" class="headerlink" title="Sever服务过程"></a>Sever服务过程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Serve</span><span class="params">(lis net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="comment">//打印日志</span></span><br><span class="line">    s.printf(<span class="string">&quot;serving&quot;</span>)</span><br><span class="line">    <span class="comment">//更新状态</span></span><br><span class="line">    s.serve = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查是否已经关闭</span></span><br><span class="line">    <span class="keyword">if</span> s.lis == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Serve called after Stop or GracefulStop.</span></span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">        lis.Close()</span><br><span class="line">        <span class="keyword">return</span> ErrServerStopped</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发相关</span></span><br><span class="line">    s.serveWG.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.serveWG.Done()</span><br><span class="line">        <span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">            <span class="comment">// Stop or GracefulStop called; block until done and return nil.</span></span><br><span class="line">            &lt;-s.done.Done()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册端口监听</span></span><br><span class="line"><span class="comment">    type listenSocket struct &#123;</span></span><br><span class="line"><span class="comment">        net.Listener</span></span><br><span class="line"><span class="comment">        channelzID *channelz.Identifier</span></span><br><span class="line"><span class="comment">    &#125;   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ls := &amp;listenSocket&#123;Listener: lis&#125;</span><br><span class="line">    s.lis[ls] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（在退出时）注销端口监听</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> s.lis != <span class="literal">nil</span> &amp;&amp; s.lis[ls] &#123;</span><br><span class="line">            ls.Close()</span><br><span class="line">            <span class="built_in">delete</span>(s.lis, ls)</span><br><span class="line">        &#125;</span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//channelz相关</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    ls.channelzID, err = channelz.RegisterListenSocket(ls, s.channelzID, lis.Addr().String())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁，并发操作完成</span></span><br><span class="line">    s.mu.Unlock()</span><br><span class="line">    channelz.Info(logger, ls.channelzID, <span class="string">&quot;ListenSocket created&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 死循环，用accept监听</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rawConn, err := lis.Accept()</span><br><span class="line">        <span class="comment">//错误检查</span></span><br><span class="line">        <span class="comment">//https://openskill.cn/article/1792</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否是临时错误</span></span><br><span class="line">            <span class="keyword">if</span> ne, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">                Temporary() <span class="keyword">bool</span></span><br><span class="line">            &#125;); </span><br><span class="line">            <span class="comment">/*类型断言，利用短逻辑避免调用不存在的方法*/</span></span><br><span class="line">                ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="comment">// 试图恢复，等待一段时间</span></span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印日志</span></span><br><span class="line">                s.mu.Lock()</span><br><span class="line">                s.printf(<span class="string">&quot;Accept error: %v; retrying in %v&quot;</span>, err, tempDelay)</span><br><span class="line">                s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待，如果此时服务退出就不再等待直接返回</span></span><br><span class="line">                timer := time.NewTimer(tempDelay)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">                <span class="keyword">case</span> &lt;-s.quit.Done():</span><br><span class="line">                    timer.Stop()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//等待多次之后仍有错误，打印日志</span></span><br><span class="line">            s.mu.Lock()</span><br><span class="line">            s.printf(<span class="string">&quot;done serving; Accept = %v&quot;</span>, err)</span><br><span class="line">            s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否退出</span></span><br><span class="line">            <span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        <span class="comment">// Start a new goroutine to deal with rawConn so we don&#x27;t stall this Accept</span></span><br><span class="line">        <span class="comment">// loop goroutine.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Make sure we account for the goroutine so GracefulStop doesn&#x27;t nil out</span></span><br><span class="line">        <span class="comment">// s.conns before this conn can be added.</span></span><br><span class="line">        s.serveWG.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            s.handleRawConn(lis.Addr().String(), rawConn)</span><br><span class="line">            s.serveWG.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终这个函数会把端口地址和通过Accept得到的连接传递给handle函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleRawConn forks a goroutine to handle a just-accepted connection that</span></span><br><span class="line"><span class="comment">// has not had any I/O performed on it yet.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleRawConn</span><span class="params">(lisAddr <span class="keyword">string</span>, rawConn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否退出</span></span><br><span class="line">    <span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">        rawConn.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一次IO操作的最大时间，如果超过直接失败</span></span><br><span class="line">    <span class="comment">// 这里是用来限制连接时间的</span></span><br><span class="line">    rawConn.SetDeadline(time.Now().Add(s.opts. connectionTimeout))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish handshaking (HTTP2)</span></span><br><span class="line">    st := s.newHTTP2Transport(rawConn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成连接之后取消时长限制</span></span><br><span class="line">    rawConn.SetDeadline(time.Time&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> st == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !s.addConn(lisAddr, st) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.serveStreams(st)</span><br><span class="line">        s.removeConn(lisAddr, st)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Http2握手"><a href="#Http2握手" class="headerlink" title="Http2握手"></a>Http2握手</h3><p>handle函数处理连接的第一步就是完成HTTP2的握手</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newHTTP2Transport sets up a http/2 transport (using the</span></span><br><span class="line"><span class="comment">// gRPC http2 server transport in transport/http2_server.go).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">newHTTP2Transport</span><span class="params">(c net.Conn)</span> <span class="title">transport</span>.<span class="title">ServerTransport</span></span> &#123;</span><br><span class="line">    config := &amp;transport.ServerConfig&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    st, err := transport.NewServerTransport(c, config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码如下：<code>internal/transport/http2_server.go</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/08/06/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">Android学习笔记（五）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-06 20:10:06" itemprop="dateCreated datePublished" datetime="2022-08-06T20:10:06+08:00">2022-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h2><p>application是应用程序中除了activity之外的另一个context，顾名思义，它就像是“应用程序”本身。因此，它拥有与应用程序相同的生命周期，并且拥有对全局资源的访问权限，此外它还可以监控Activity的声明周期。</p>
<h3 id="Application类的注册"><a href="#Application类的注册" class="headerlink" title="Application类的注册"></a>Application类的注册</h3><p>一个应用程序只能有一个application实例，默认情况下会自动创建一个。如果要自己编写一个，就需要让一个类继承Application，并且在androidmanifest文件中为application添加<code>android:name</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>android:name</code>设置为自己编写的类名。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.App&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> &gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，应用程序就会以App类作为Application实例。</p>
<h3 id="利用Application获取-x2F-传递全局资源"><a href="#利用Application获取-x2F-传递全局资源" class="headerlink" title="利用Application获取&#x2F;传递全局资源"></a>利用Application获取&#x2F;传递全局资源</h3><p>由于Application也是Context的一种，因此它也可以解析R文件中的内容。例如在res&#x2F;values&#x2F;strings.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;qaq&quot;</span>&gt;</span>qaq<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就可以使用Application直接进行访问，首先定义<code>getApp()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> App <span class="title">getApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (App) getApplicationContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Activity中调用，可以看到解析全局资源呈现出来的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setText(<span class="string">&quot;资源字符串的内容是: &quot;</span> + getApp().getString(R.string.qaq));</span><br></pre></td></tr></table></figure>

<p>另一种方法是利用应用程序只有一个application，并且每个activity都可以通过调用<code>getApplicationContext()</code>获得application的特性，在App类中添加字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String textData = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTextData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextData</span><span class="params">(String textData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.textData = textData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码添加了字段textData和它的访问器与修改器，可以在IDEA或AS中通过code-&gt;generate-&gt;getter and setter来自动生成，<strong>注意鼠标光标必须位于类定义的大括号内，否则generate可能只有copyright选项</strong></p>
<p>接下来，可以编写两个activity，在一个activity中设置，启动另一个activity，再在另一个activity中显示。这部分内容就是之前讲过的了：<br>在MainActivity.java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main1);</span><br><span class="line"></span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line">    editText = findViewById(R.id.editText);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.button).setOnClickListener(</span><br><span class="line">            <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    getApp().setTextData(editText.getText().toString());</span><br><span class="line">                    textView.setText(<span class="string">&quot;共享的数据是: &quot;</span> + editText.getText().toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    findViewById(R.id.button2).setOnClickListener(</span><br><span class="line">            <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MainActivity2.class));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MainActivity2.java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main2);</span><br><span class="line"></span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">    textView.setText(<span class="string">&quot;共享的数据是: &quot;</span> + getApp().getString(R.string.qaq));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Application生命周期"><a href="#Application生命周期" class="headerlink" title="Application生命周期"></a>Application生命周期</h3><p>启动应用程序时，首先创建Application并调用其<code>onCreate()</code>方法。关闭程序时，如果在虚拟环境下会回调<code>onTerminate()</code>方法。注意，Application的onCreate比Activity的onCreate先被调用，这个特性使得Application的onCreate成为初始化内容的好时机。<br>在应用的运行过程中，Application还有如下几个生命周期：<code>onLowMemory()</code>,<code>onTrimMemory()</code>,<code>onConfigurationChanges()</code>，分别对应于低内存、内存清理和配置改变，程序可以做相应的资源释放和布局改变来响应这些事件。</p>
<h3 id="从多个Activity启动应用程序"><a href="#从多个Activity启动应用程序" class="headerlink" title="从多个Activity启动应用程序"></a>从多个Activity启动应用程序</h3><p>可以让两个Activity在AndroidManifest中都包含下列内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>这样会为应用程序生成两个图标，分别从不同的Activity启动。<br>不知道有什么用（</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/08/06/%E7%AB%AF%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/%E7%AB%AF%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-06 18:09:35 / 修改时间：18:15:16" itemprop="dateCreated datePublished" datetime="2022-08-06T18:09:35+08:00">2022-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">网络通讯与数据存储</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-02 12:45:10" itemprop="dateCreated datePublished" datetime="2022-08-02T12:45:10+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-03 01:22:37" itemprop="dateModified" datetime="2022-08-03T01:22:37+08:00">2022-08-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络请求框架对比：</p>
<ul>
<li>HttpURLConnection</li>
<li>Volley<ul>
<li>停更</li>
<li>不适合上传下载文件</li>
</ul>
</li>
<li>OkHttp<ul>
<li>支持大文件上传下载</li>
<li>性能更好</li>
<li>一般需要二次封装</li>
</ul>
</li>
<li>Retrofit<ul>
<li>可以通过注解配置请求</li>
<li>可以搭配转换器解析数据，支持jackjson，pb等</li>
</ul>
</li>
</ul>
<h3 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h3><p>Retrofit其实是对OkHttp的一个封装，使用Retrofit库的基本流程包括引用、创建用于描述网络请求的接口、使用Retrofit实例发起网络请求。</p>
<blockquote>
<p>场景：客户端知道用户uid，要在服务端查询用户姓名，通过Retrofit实现</p>
</blockquote>
<ul>
<li>接口：<code>https://www.bytedane.com/&#123;uid&#125;/name</code></li>
<li>类型：GET请求</li>
<li>接口返回：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;data&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;1123&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;first_name&quot;</span>:<span class="string">&quot;张&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;last_name&quot;</span>:<span class="string">&quot;三丰&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.导入dependencies依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建用于描述网络请求的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUserInfoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;uid&#125;/name&quot;)</span></span><br><span class="line">  <span class="function">fun <span class="title">getUserName</span><span class="params">(<span class="meta">@Path(&quot;uid&quot;)</span> uid: Int)</span>: Call&lt;ResponseBody&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接口类名：和请求的含义相关</li>
<li>函数名：识别出该接口的作用，该Interface里可以增加多个不同的函数</li>
<li>@GET注解：指定该接口的相对路径，用get方法发起请求</li>
<li>@Path注解：需要外部调用时，用传入的uid替换注解里的{uid}</li>
<li>返回值Call&lt;ResponseBody&gt;：可以直接转换把Sring转换为Model，这里就转换为User</li>
<li>ResponseBody：根据返回内容定义的类，应当包含所有字段和一些输出方法，<code>response.body()</code>是该类的一个实例</li>
</ul>
<ol start="3">
<li>发起网络请求</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">(View)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建Retrofit实例</span></span><br><span class="line">  <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">  .baseUrl(<span class="string">&quot;https://www.bytedance.com/&quot;</span>)<span class="comment">//请求Url地址</span></span><br><span class="line">  .build()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建 网络请求接口 的实例</span></span><br><span class="line">  <span class="keyword">val</span> iUserInterface = retrofit.create(IUserInfoService::<span class="keyword">class</span>.java)</span><br><span class="line">  <span class="keyword">val</span> call = iUserInterface.getUserName(<span class="number">1123</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入队异步请求</span></span><br><span class="line">  call.enqueue(<span class="keyword">object</span>: Callback&lt;ResponseBody&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;,response: <span class="type">Response</span>&lt;<span class="type">ResponseBody</span>&gt;)</span></span> &#123;</span><br><span class="line">      request_result_tv.text = <span class="string">&quot;请求成功：&quot;</span> + response.body()!!.string();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">      request_result_tv.text = <span class="string">&quot;请求失败&quot;</span> + e.message</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Retrofit注解"><a href="#Retrofit注解" class="headerlink" title="Retrofit注解"></a>Retrofit注解</h3><!-- ![注解](/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2022-08-03-00-22-55.png) -->
<ul>
<li>注解简介<br>注解可以作用在类、方法、参数、成员变量上，并且可以在合适的时机读取注解并进行替换。<br>注解的处理一般有三个时机(Retention)：</li>
</ul>
<p>1.SOURCE: 只在源码有效<br>2.CLASS: 编译时用注解处理器处理<br>3.RUNTIME: 运行时处理</p>
<ul>
<li>注解定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(METHOD)</span><span class="comment">//作用对象</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//生命周期</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解使用</li>
</ul>
<p>可以利用Method类的接口来获取注解的内容。配合动态代理可以获取方法和参数的注解，构造Request对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClasslLoader loader, </span></span></span><br><span class="line"><span class="params"><span class="function">Class&lt;?&gt;[] interfaces, </span></span></span><br><span class="line"><span class="params"><span class="function">InvocationHandler h)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">  throw Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后可以通过<code>Method.getAnnotaion()</code>和<code>Method.getParameterAnnotation()</code>来获取方法和方法参数的注解内容。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>Retrofit的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.builder()</span><br><span class="line">      .baseUrl(<span class="string">&quot;http://www.bytedance.com/&quot;</span>)</span><br><span class="line">      .addConverterFactory(GsonConverterFactory.create())<span class="comment">//利用gson转换器解析json，需要添加gson依赖</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">IUserInfoService iUserInterface = retrofit.create(IUserInfoService.class);</span><br><span class="line"></span><br><span class="line">retrofit2.Call&lt;ResponseBody&gt; call = iUserInterface.getUserName(<span class="number">1123</span>);</span><br><span class="line"></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span> <span class="params">(Call&lt;ResponseBody&gt; call,</span></span></span><br><span class="line"><span class="params"><span class="function">      Response&lt;ResponseBody&gt; response)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call,  Throwable t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>OkHttp的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建OkHttpClient</span></span><br><span class="line">OkHttpClient OkHttpClient = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .get()</span><br><span class="line">    .url(<span class="string">&quot;https://www.bytedance.com/user/1123/name&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">OkHttp.Call call = okHttpClient.newCall(request);</span><br><span class="line"></span><br><span class="line">Call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span> <span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span> <span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 服务器响应结果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字节跳动网络库"><a href="#字节跳动网络库" class="headerlink" title="字节跳动网络库"></a>字节跳动网络库</h3><p>Cronet用C++实现，对OkHttp进行了特定优化。对其进行二次封装，设计一个高已用、功能全面的框架。最终决定基于Retrofit进行二次开发，将底层的OkHttp替换为Cronet，这就是TTNet。<br>核心点就是将OkHttpClient和OkHttpCall的生成替换为OkHttp和Cronet二选一。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="辉夜"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">辉夜</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">辉夜</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
