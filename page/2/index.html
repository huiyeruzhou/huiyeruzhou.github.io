<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huiyeruzhou.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="辉夜的博客">
<meta property="og:url" content="http://huiyeruzhou.github.io/page/2/index.html">
<meta property="og:site_name" content="辉夜的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="辉夜">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://huiyeruzhou.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>辉夜的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">辉夜的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">繁花似锦，辉夜如昼</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">RPC框架设计侧重点, 特色和架构调研</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 16:53:30" itemprop="dateCreated datePublished" datetime="2022-09-25T16:53:30+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 21:19:12" itemprop="dateModified" datetime="2022-10-24T21:19:12+08:00">2022-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Volo调研"><a href="#Volo调研" class="headerlink" title="Volo调研"></a>Volo调研</h2><p>Volo 是字节跳动服务框架团队研发的轻量级、高性能、可扩展性强、易用性好的 Rust RPC 框架，使用了 Rust 最新的 GAT 特性。</p>
<h3 id="特色-易用性"><a href="#特色-易用性" class="headerlink" title="特色-易用性"></a>特色-易用性</h3><p>具体来说，这个框架使用了<a target="_blank" rel="noopener" href="https://github.com/cloudwego/motore">motore</a>中间件, 而其使用GAT语法完成了<a target="_blank" rel="noopener" href="https://github.com/cloudwego/motore">高效的异步接口</a></p>
<p>Rust不支持一个<code>async trait</code>, 一般的解决方法是使用Box(类似智能指针)来完成这件事情, <a target="_blank" rel="noopener" href="https://www.cloudwego.io/zh/docs/motore/faq/q1_gat/">但这会</a>带来额外的开销并且降低代码可读性. 有一个使用宏完成用Box实现异步接口的<a target="_blank" rel="noopener" href="https://docs.rs/async-trait/latest/async_trait/">Crate</a></p>
<p>具体细节可能需要进一步理解一些Rust的语言特性</p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">├─volo          RPC框架的通用组件</span><br><span class="line">│  └─src  </span><br><span class="line">│      ├─discovery      #服务发现:一些接口,一种简单实现(返回静态单链表)</span><br><span class="line">│      ├─loadbalance    #负载均衡:同上(加权随机)</span><br><span class="line">│      ├─net            #网络链接: probe创建套接字,dial建立连接,incomming进行监听,conn进行读写 </span><br><span class="line">│      └─util           #工具: buf_reader</span><br><span class="line">|                       #</span><br><span class="line">├─volo-build    #编译用</span><br><span class="line">│  └─src</span><br><span class="line">├─volo-cli      #用户界面</span><br><span class="line">│  └─...</span><br><span class="line">├─volo-grpc     #grpc框架</span><br><span class="line">│  └─src</span><br><span class="line">│      ├─client         #客户端底层组件</span><br><span class="line">│      ├─codec          #编解码器</span><br><span class="line">│      ├─layer          #待调研,类似某种封装tonic/src/metadata</span><br><span class="line">│      │  └─loadbalance</span><br><span class="line">│      ├─metadata</span><br><span class="line">│      ├─server         #服务端底层组件</span><br><span class="line">│      └─transport</span><br><span class="line">    ...                 #从tonic/src/中copy并修改了一些文件,完成rpc的请求响应相关工作</span><br><span class="line">├─volo-macros   #宏</span><br><span class="line">│  └─src</span><br><span class="line">└─volo-thrift   #thrift框架</span><br><span class="line">    └─src</span><br><span class="line">        ├─client</span><br><span class="line">        │  └─layer</span><br><span class="line">        ├─codec</span><br><span class="line">        ├─protocol</span><br><span class="line">        └─transport</span><br><span class="line">            ├─pingpong</span><br><span class="line">            └─pool</span><br></pre></td></tr></table></figure>

<p><strong>如何用Volo的特色实现grpc</strong><br><img src="/2022/09/25/RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%BE%A7%E9%87%8D%E7%82%B9-%E7%89%B9%E8%89%B2%E5%92%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/2022-09-25-16-54-19.png" alt="架构图"></p>
<h3 id="erpc"><a href="#erpc" class="headerlink" title="erpc"></a>erpc</h3><p><strong>传输层(串口),嵌入式,代码生成(结合nanopb)</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/EmbeddedRPC/erpc">erpc项目地址</a>及其<a target="_blank" rel="noopener" href="https://embeddedrpc.github.io/eRPC">详细文档</a></p>
<h3 id="侧重点"><a href="#侧重点" class="headerlink" title="侧重点"></a>侧重点</h3><p>嵌入式,轻量化</p>
<h3 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">├─erpcgen           #代码生成工具</span><br><span class="line">├─erpcsniffer</span><br><span class="line">│  └─src</span><br><span class="line">├─erpc_c            #基础架构</span><br><span class="line">│  ├─config         #config.h配置文件 </span><br><span class="line">│  └─infra</span><br><span class="line">|     ├─ erpc_arbitrated_client_manager.cpp</span><br><span class="line">|     ├─ erpc_arbitrated_client_manager.hpp</span><br><span class="line">|     ├─ erpc_basic_codec.cpp      #基础编解码器</span><br><span class="line">|     ├─ erpc_basic_codec.hpp</span><br><span class="line">|     ├─ erpc_client_manager.cpp</span><br><span class="line">|     ├─ erpc_client_manager.h</span><br><span class="line">|     ├─ erpc_client_server_common.hpp</span><br><span class="line">|     ├─ erpc_codec.hpp             #编解码器抽象定义</span><br><span class="line">|     ├─ erpc_common.h              #状态码枚举类型的定义</span><br><span class="line">|     ├─ erpc_crc16.cpp</span><br><span class="line">|     ├─ erpc_crc16.hpp</span><br><span class="line">|     ├─ erpc_framed_transport.cpp</span><br><span class="line">|     ├─ erpc_framed_transport.hpp</span><br><span class="line">|     ├─ erpc_manually_constructed.hpp</span><br><span class="line">|     ├─ erpc_message_buffer.cpp</span><br><span class="line">|     ├─ erpc_message_buffer.hpp</span><br><span class="line">|     ├─ erpc_message_loggers.cpp</span><br><span class="line">|     ├─ erpc_message_loggers.hpp</span><br><span class="line">|     ├─ erpc_pre_post_action.cpp</span><br><span class="line">|     ├─ erpc_pre_post_action.h</span><br><span class="line">|     ├─ erpc_server.cpp            </span><br><span class="line">|     ├─ erpc_server.hpp            #Service和Server的抽象接口,注册移除服务,处理信息等</span><br><span class="line">|     ├─ erpc_simple_server.cpp     #</span><br><span class="line">|     ├─ erpc_simple_server.hpp</span><br><span class="line">|     ├─ erpc_static_queue.hpp      #数组实现的队列</span><br><span class="line">|     ├─ erpc_transport.hpp         #Transport</span><br><span class="line">|     ├─ erpc_transport_arbitrator.cpp</span><br><span class="line">|     ├─ erpc_transport_arbitrator.hpp</span><br><span class="line">|     ├─ erpc_version.h</span><br><span class="line">|     ├─ infra.dox     </span><br><span class="line">│  ├─port           #便于移植</span><br><span class="line">│  ├─setup          #C语言接口</span><br><span class="line">│  └─transports     #支持不同通信方法的工具类</span><br><span class="line">├─erpc_python</span><br><span class="line">│  └─erpc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<ul>
<li>rtos上的 protobuf-c</li>
<li>erpc 传输层 nanopb</li>
<li>volo 语法特性</li>
<li>motan dubbo 事件逻辑</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/" class="post-title-link" itemprop="url">grpc-go源码分析(1)</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-04 14:43:36" itemprop="dateCreated datePublished" datetime="2022-09-04T14:43:36+08:00">2022-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要分析了grpc-go服务端的启动过程，重点考察了服务端的建立、注册、监听<br>等关键的生命周期对应的代码实现。<br>目前阶段主要考察普通的rpc调用，暂时没有研究流式传输。</p>
<p>首先来看服务端<code>examples/helloworld/greeter_server/main.go</code>的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解析命令行参数,主要是port</span></span><br><span class="line">    flag.Parse()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建一个对本地端口的监听</span></span><br><span class="line">    lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建grpc服务器</span></span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册protobuf中的服务</span></span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监听</span></span><br><span class="line">    <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, main函数中和server相关的操作主要有三步:<br>（1）创建 server<br>（2）server 的注册<br>（3）调用 Serve 监听端口并处理请求</p>
<h2 id="Server的创建"><a href="#Server的创建" class="headerlink" title="Server的创建"></a>Server的创建</h2><p>这里调用的函数就是<code>\server.go#NewServer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(opt ...ServerOption)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    <span class="comment">//用option模式指定各个服务器选项</span></span><br><span class="line">    opts := defaultServerOptions</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> extraServerOptions &#123;</span><br><span class="line">        o.apply(&amp;opts)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opt &#123;</span><br><span class="line">        o.apply(&amp;opts)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建服务器</span></span><br><span class="line">    s := &amp;Server&#123;</span><br><span class="line">        lis:      <span class="built_in">make</span>(<span class="keyword">map</span>[net.Listener]<span class="keyword">bool</span>),</span><br><span class="line">        opts:     opts,</span><br><span class="line">        conns:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[transport.ServerTransport]<span class="keyword">bool</span>),</span><br><span class="line">        services: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*serviceInfo),</span><br><span class="line">        quit:     grpcsync.NewEvent(),</span><br><span class="line">        done:     grpcsync.NewEvent(),</span><br><span class="line">        czData:   <span class="built_in">new</span>(channelzData),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置拦截器</span></span><br><span class="line">    chainUnaryServerInterceptors(s)</span><br><span class="line">    chainStreamServerInterceptors(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步相关(优雅退出时发送信号)</span></span><br><span class="line">    s.cv = sync.NewCond(&amp;s.mu)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试相关 打印调用信息</span></span><br><span class="line">    <span class="keyword">if</span> EnableTracing &#123;</span><br><span class="line">        _, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">        s.events = trace.NewEventLog(<span class="string">&quot;grpc.Server&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, file, line))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发相关</span></span><br><span class="line">    <span class="keyword">if</span> s.opts.numServerWorkers &gt; <span class="number">0</span> &#123;</span><br><span class="line">        s.initServerWorkers()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// channelz(一个调试工具)相关</span></span><br><span class="line">    s.channelzID = channelz.RegisterServer(&amp;channelzServer&#123;s&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    channelz.Info(logger, s.channelzID, <span class="string">&quot;Server created&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个Server结构体包括了一系列网络通讯和同步相关的内容，通常是使用了sync包中的功能或利用通道完成各种同步操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server is a gRPC server to serve RPC requests.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    opts serverOptions</span><br><span class="line"></span><br><span class="line">    mu  sync.Mutex <span class="comment">// guards following</span></span><br><span class="line"></span><br><span class="line">    lis <span class="keyword">map</span>[net.Listener]<span class="keyword">bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听地址到 transports的映射</span></span><br><span class="line">    conns    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[transport.ServerTransport]<span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 是否在服务</span></span><br><span class="line">    serve    <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    drain    <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 优雅退出时进行广播</span></span><br><span class="line">    cv       *sync.Cond          </span><br><span class="line">    <span class="comment">// 核心:服务名到服务信息的映射</span></span><br><span class="line">    services <span class="keyword">map</span>[<span class="keyword">string</span>]*serviceInfo</span><br><span class="line">    <span class="comment">// 日志 </span></span><br><span class="line">    events   trace.EventLog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步相关</span></span><br><span class="line">    quit               *grpcsync.Event</span><br><span class="line">    done               *grpcsync.Event</span><br><span class="line">    channelzRemoveOnce sync.Once</span><br><span class="line">    serveWG            sync.WaitGroup <span class="comment">// counts active Serve goroutines for GracefulStop</span></span><br><span class="line"></span><br><span class="line">    channelzID *channelz.Identifier</span><br><span class="line">    czData     *channelzData</span><br><span class="line"></span><br><span class="line">    serverWorkerChannels []<span class="keyword">chan</span> *serverWorkerData</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="用于同步的grpc-Event"><a href="#用于同步的grpc-Event" class="headerlink" title="用于同步的grpc.Event"></a>用于同步的grpc.Event</h3><p>对于Event类型的quit和done，这里简单的分析一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Event represents a one-time event that may occur in the future.</span></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">    fired <span class="keyword">int32</span></span><br><span class="line">    c     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    o     sync.Once</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Event可以被并发地多次触发。一旦被触发，e.c将被关闭，从而所有试图从e.c中接受一个值的协程将从阻塞中恢复，这起到了一对多通知的效果。o是为了防止e.c被多次关闭而引发panic。</p>
<h3 id="核心部分：map-string"><a href="#核心部分：map-string" class="headerlink" title="核心部分：map[string]"></a>核心部分：<code>map[string]</code></h3><p>而这一部分代码中的核心还是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services <span class="keyword">map</span>[<span class="keyword">string</span>]*serviceInfo</span><br></pre></td></tr></table></figure>

<p>通过服务名，我们可以直接获取服务相关的信息，主要也是两个map，通过名称可以分别获取stream和method的描述（Desc）。每个描述都包含了name和handler</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serviceInfo wraps information about a service. It is very similar to</span></span><br><span class="line"><span class="comment">// ServiceDesc and is constructed from it for internal purposes.</span></span><br><span class="line"><span class="keyword">type</span> serviceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Contains the implementation for the methods in this service.</span></span><br><span class="line">    serviceImpl <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    methods     <span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc</span><br><span class="line">    streams     <span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc</span><br><span class="line">    mdata       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，在调用过程中Server的关键结构是这样的：</p>
<p><img src="/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/2022-09-04-16-04-53.png" alt="grpc-go源码分析"></p>
<h2 id="Server注册"><a href="#Server注册" class="headerlink" title="Server注册"></a>Server注册</h2><p>main函数中的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册protobuf中的服务</span></span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>需要先考察一下server是一个什么样的结构</p>
<h3 id="自定义的服务器实现：Server类型"><a href="#自定义的服务器实现：Server类型" class="headerlink" title="自定义的服务器实现：Server类型"></a>自定义的服务器实现：Server类型</h3><p>在<code>examples/helloworld/greeter_server/main.go</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实际上就是对proto中定义的服务端的一个实现, 注意接口中要求的方法<code>mustEmbedUnimplementedGreeterServer()</code>是在protobuf的生成文件pb中的<code>pb.UnimplementedGreeterServer</code>中实现的，这是为了从语法上要求server的实现中必须包含<code>pb.UnimplementedGreeterServer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GreeterServer is the server API for Greeter service.</span></span><br><span class="line"><span class="comment">// All implementations must embed UnimplementedGreeterServer</span></span><br><span class="line"><span class="comment">// for forward compatibility</span></span><br><span class="line"><span class="keyword">type</span> GreeterServer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Sends a greeting</span></span><br><span class="line">    SayHello(context.Context, *HelloRequest) (*HelloReply, error)</span><br><span class="line">    mustEmbedUnimplementedGreeterServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么必须包含这个奇怪的结构体，可能是因为这个结构体中包含了一个默认的SayHello方法，这样即使我们忘了实现SayHello方法，也能让server实现<code>GreeterServer</code>接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedGreeterServer)</span> <span class="title">SayHello</span><span class="params">(context.Context, *HelloRequest)</span> <span class="params">(*HelloReply, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unimplemented, <span class="string">&quot;method SayHello not implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedGreeterServer)</span> <span class="title">mustEmbedUnimplementedGreeterServer</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总而言之，Server就是一个我们自己实现的服务器。包含了我们在proto中声明的方法。</p>
<h3 id="Register调用分析"><a href="#Register调用分析" class="headerlink" title="Register调用分析"></a>Register调用分析</h3><p>main函数中直接调用的方法是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册protobuf中的服务</span></span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>server 的注册调用了 RegisterGreeterServer 方法，这个方法是<code>examples/helloworld/helloworld/helloworld_grpc.pb.go</code>中的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterGreeterServer</span><span class="params">(s *grpc.Server, srv GreeterServer)</span></span> &#123;</span><br><span class="line">    s.RegisterService(&amp;Greeter_serviceDesc, srv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法调用了 server 的 RegisterService 方法，然后传入了一个 ServiceDesc 的数据结构，如下 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeter_ServiceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">    ServiceName: <span class="string">&quot;helloworld.Greeter&quot;</span>,</span><br><span class="line">    HandlerType: (*GreeterServer)(<span class="literal">nil</span>),</span><br><span class="line">    Methods: []grpc.MethodDesc&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            MethodName: <span class="string">&quot;SayHello&quot;</span>,</span><br><span class="line">            Handler:    _Greeter_SayHello_Handler,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Streams:  []grpc.StreamDesc&#123;&#125;,</span><br><span class="line">    Metadata: <span class="string">&quot;examples/helloworld/helloworld/helloworld.proto&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个结构体的结构serviceInfo的结构是吻合的：<br><img src="/2022/09/04/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/2022-09-04-16-04-53.png" alt="grpc"></p>
<p>下面来看RegisterService函数的实现，核心的内容在就是检查完类型之后调用register将sd中的信息注入到seviceinfo结构体中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterService registers a service and its implementation to the gRPC</span></span><br><span class="line"><span class="comment">// server. It is called from the IDL generated code. This must be called before</span></span><br><span class="line"><span class="comment">// invoking Serve. If ss is non-nil (for legacy code), its type is checked to</span></span><br><span class="line"><span class="comment">// ensure it implements sd.HandlerType.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterService</span><span class="params">(sd*ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查类型</span></span><br><span class="line">    <span class="keyword">if</span> ss != <span class="literal">nil</span> &#123;</span><br><span class="line">        ht := reflect.TypeOf(sd.HandlerType).Elem()</span><br><span class="line">        st := reflect.TypeOf(ss)</span><br><span class="line">        <span class="keyword">if</span> !st.Implements(ht) &#123;</span><br><span class="line">            logger.Fatalf(<span class="string">&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;</span>, st, ht)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.register(sd, ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">register</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    s.printf(<span class="string">&quot;RegisterService(%q)&quot;</span>, sd.ServiceName)</span><br><span class="line">    <span class="comment">// 检查异常</span></span><br><span class="line">    <span class="keyword">if</span> s.serve &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;</span>, sd.ServiceName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := s.services[sd.ServiceName]; ok &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;</span>, sd.ServiceName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将sd中的内容注入到serviceinfo中，并将ss类型保存为serviceImpl</span></span><br><span class="line">    info := &amp;serviceInfo&#123;</span><br><span class="line">        serviceImpl: ss,</span><br><span class="line">        methods:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc),</span><br><span class="line">        streams:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc),</span><br><span class="line">        mdata:       sd.Metadata,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> sd.Methods &#123;</span><br><span class="line">        d := &amp;sd.Methods[i]</span><br><span class="line">        info.methods[d.MethodName] = d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> sd.Streams &#123;</span><br><span class="line">        d := &amp;sd.Streams[i]</span><br><span class="line">        info.streams[d.StreamName] = d</span><br><span class="line">    &#125;</span><br><span class="line">    s.services[sd.ServiceName] = info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server 对不同 rpc 请求的处理，也是根据 service 中不同的 serviceName 去 service map 中取出不同的 handler 进行处理，这样相当于完成了grpc的代理操作，把字符串传递给代理，代理就能调用对应的实际方法去处理。</p>
<h3 id="Sever服务过程"><a href="#Sever服务过程" class="headerlink" title="Sever服务过程"></a>Sever服务过程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Serve</span><span class="params">(lis net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="comment">//打印日志</span></span><br><span class="line">    s.printf(<span class="string">&quot;serving&quot;</span>)</span><br><span class="line">    <span class="comment">//更新状态</span></span><br><span class="line">    s.serve = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查是否已经关闭</span></span><br><span class="line">    <span class="keyword">if</span> s.lis == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Serve called after Stop or GracefulStop.</span></span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">        lis.Close()</span><br><span class="line">        <span class="keyword">return</span> ErrServerStopped</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发相关</span></span><br><span class="line">    s.serveWG.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.serveWG.Done()</span><br><span class="line">        <span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">            <span class="comment">// Stop or GracefulStop called; block until done and return nil.</span></span><br><span class="line">            &lt;-s.done.Done()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册端口监听</span></span><br><span class="line"><span class="comment">    type listenSocket struct &#123;</span></span><br><span class="line"><span class="comment">        net.Listener</span></span><br><span class="line"><span class="comment">        channelzID *channelz.Identifier</span></span><br><span class="line"><span class="comment">    &#125;   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ls := &amp;listenSocket&#123;Listener: lis&#125;</span><br><span class="line">    s.lis[ls] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（在退出时）注销端口监听</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> s.lis != <span class="literal">nil</span> &amp;&amp; s.lis[ls] &#123;</span><br><span class="line">            ls.Close()</span><br><span class="line">            <span class="built_in">delete</span>(s.lis, ls)</span><br><span class="line">        &#125;</span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//channelz相关</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    ls.channelzID, err = channelz.RegisterListenSocket(ls, s.channelzID, lis.Addr().String())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁，并发操作完成</span></span><br><span class="line">    s.mu.Unlock()</span><br><span class="line">    channelz.Info(logger, ls.channelzID, <span class="string">&quot;ListenSocket created&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 死循环，用accept监听</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rawConn, err := lis.Accept()</span><br><span class="line">        <span class="comment">//错误检查</span></span><br><span class="line">        <span class="comment">//https://openskill.cn/article/1792</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否是临时错误</span></span><br><span class="line">            <span class="keyword">if</span> ne, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">                Temporary() <span class="keyword">bool</span></span><br><span class="line">            &#125;); </span><br><span class="line">            <span class="comment">/*类型断言，利用短逻辑避免调用不存在的方法*/</span></span><br><span class="line">                ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="comment">// 试图恢复，等待一段时间</span></span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印日志</span></span><br><span class="line">                s.mu.Lock()</span><br><span class="line">                s.printf(<span class="string">&quot;Accept error: %v; retrying in %v&quot;</span>, err, tempDelay)</span><br><span class="line">                s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待，如果此时服务退出就不再等待直接返回</span></span><br><span class="line">                timer := time.NewTimer(tempDelay)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">                <span class="keyword">case</span> &lt;-s.quit.Done():</span><br><span class="line">                    timer.Stop()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//等待多次之后仍有错误，打印日志</span></span><br><span class="line">            s.mu.Lock()</span><br><span class="line">            s.printf(<span class="string">&quot;done serving; Accept = %v&quot;</span>, err)</span><br><span class="line">            s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否退出</span></span><br><span class="line">            <span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        <span class="comment">// Start a new goroutine to deal with rawConn so we don&#x27;t stall this Accept</span></span><br><span class="line">        <span class="comment">// loop goroutine.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Make sure we account for the goroutine so GracefulStop doesn&#x27;t nil out</span></span><br><span class="line">        <span class="comment">// s.conns before this conn can be added.</span></span><br><span class="line">        s.serveWG.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            s.handleRawConn(lis.Addr().String(), rawConn)</span><br><span class="line">            s.serveWG.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终这个函数会把端口地址和通过Accept得到的连接传递给handle函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleRawConn forks a goroutine to handle a just-accepted connection that</span></span><br><span class="line"><span class="comment">// has not had any I/O performed on it yet.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleRawConn</span><span class="params">(lisAddr <span class="keyword">string</span>, rawConn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否退出</span></span><br><span class="line">    <span class="keyword">if</span> s.quit.HasFired() &#123;</span><br><span class="line">        rawConn.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一次IO操作的最大时间，如果超过直接失败</span></span><br><span class="line">    <span class="comment">// 这里是用来限制连接时间的</span></span><br><span class="line">    rawConn.SetDeadline(time.Now().Add(s.opts. connectionTimeout))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish handshaking (HTTP2)</span></span><br><span class="line">    st := s.newHTTP2Transport(rawConn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成连接之后取消时长限制</span></span><br><span class="line">    rawConn.SetDeadline(time.Time&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> st == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !s.addConn(lisAddr, st) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s.serveStreams(st)</span><br><span class="line">        s.removeConn(lisAddr, st)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Http2握手"><a href="#Http2握手" class="headerlink" title="Http2握手"></a>Http2握手</h3><p>handle函数处理连接的第一步就是完成HTTP2的握手</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newHTTP2Transport sets up a http/2 transport (using the</span></span><br><span class="line"><span class="comment">// gRPC http2 server transport in transport/http2_server.go).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">newHTTP2Transport</span><span class="params">(c net.Conn)</span> <span class="title">transport</span>.<span class="title">ServerTransport</span></span> &#123;</span><br><span class="line">    config := &amp;transport.ServerConfig&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    st, err := transport.NewServerTransport(c, config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码如下：<code>internal/transport/http2_server.go</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/08/06/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">Android学习笔记（五）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-06 20:10:06" itemprop="dateCreated datePublished" datetime="2022-08-06T20:10:06+08:00">2022-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h2><p>application是应用程序中除了activity之外的另一个context，顾名思义，它就像是“应用程序”本身。因此，它拥有与应用程序相同的生命周期，并且拥有对全局资源的访问权限，此外它还可以监控Activity的声明周期。</p>
<h3 id="Application类的注册"><a href="#Application类的注册" class="headerlink" title="Application类的注册"></a>Application类的注册</h3><p>一个应用程序只能有一个application实例，默认情况下会自动创建一个。如果要自己编写一个，就需要让一个类继承Application，并且在androidmanifest文件中为application添加<code>android:name</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>android:name</code>设置为自己编写的类名。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.App&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> &gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，应用程序就会以App类作为Application实例。</p>
<h3 id="利用Application获取-x2F-传递全局资源"><a href="#利用Application获取-x2F-传递全局资源" class="headerlink" title="利用Application获取&#x2F;传递全局资源"></a>利用Application获取&#x2F;传递全局资源</h3><p>由于Application也是Context的一种，因此它也可以解析R文件中的内容。例如在res&#x2F;values&#x2F;strings.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;qaq&quot;</span>&gt;</span>qaq<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就可以使用Application直接进行访问，首先定义<code>getApp()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> App <span class="title">getApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (App) getApplicationContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Activity中调用，可以看到解析全局资源呈现出来的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setText(<span class="string">&quot;资源字符串的内容是: &quot;</span> + getApp().getString(R.string.qaq));</span><br></pre></td></tr></table></figure>

<p>另一种方法是利用应用程序只有一个application，并且每个activity都可以通过调用<code>getApplicationContext()</code>获得application的特性，在App类中添加字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String textData = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTextData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextData</span><span class="params">(String textData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.textData = textData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码添加了字段textData和它的访问器与修改器，可以在IDEA或AS中通过code-&gt;generate-&gt;getter and setter来自动生成，<strong>注意鼠标光标必须位于类定义的大括号内，否则generate可能只有copyright选项</strong></p>
<p>接下来，可以编写两个activity，在一个activity中设置，启动另一个activity，再在另一个activity中显示。这部分内容就是之前讲过的了：<br>在MainActivity.java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main1);</span><br><span class="line"></span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line">    editText = findViewById(R.id.editText);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.button).setOnClickListener(</span><br><span class="line">            <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    getApp().setTextData(editText.getText().toString());</span><br><span class="line">                    textView.setText(<span class="string">&quot;共享的数据是: &quot;</span> + editText.getText().toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    findViewById(R.id.button2).setOnClickListener(</span><br><span class="line">            <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MainActivity2.class));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MainActivity2.java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main2);</span><br><span class="line"></span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">    textView.setText(<span class="string">&quot;共享的数据是: &quot;</span> + getApp().getString(R.string.qaq));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Application生命周期"><a href="#Application生命周期" class="headerlink" title="Application生命周期"></a>Application生命周期</h3><p>启动应用程序时，首先创建Application并调用其<code>onCreate()</code>方法。关闭程序时，如果在虚拟环境下会回调<code>onTerminate()</code>方法。注意，Application的onCreate比Activity的onCreate先被调用，这个特性使得Application的onCreate成为初始化内容的好时机。<br>在应用的运行过程中，Application还有如下几个生命周期：<code>onLowMemory()</code>,<code>onTrimMemory()</code>,<code>onConfigurationChanges()</code>，分别对应于低内存、内存清理和配置改变，程序可以做相应的资源释放和布局改变来响应这些事件。</p>
<h3 id="从多个Activity启动应用程序"><a href="#从多个Activity启动应用程序" class="headerlink" title="从多个Activity启动应用程序"></a>从多个Activity启动应用程序</h3><p>可以让两个Activity在AndroidManifest中都包含下列内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>这样会为应用程序生成两个图标，分别从不同的Activity启动。<br>不知道有什么用（</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/08/06/%E7%AB%AF%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/%E7%AB%AF%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-06 18:09:35 / 修改时间：18:15:16" itemprop="dateCreated datePublished" datetime="2022-08-06T18:09:35+08:00">2022-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">网络通讯与数据存储</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-02 12:45:10" itemprop="dateCreated datePublished" datetime="2022-08-02T12:45:10+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-03 01:22:37" itemprop="dateModified" datetime="2022-08-03T01:22:37+08:00">2022-08-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络请求框架对比：</p>
<ul>
<li>HttpURLConnection</li>
<li>Volley<ul>
<li>停更</li>
<li>不适合上传下载文件</li>
</ul>
</li>
<li>OkHttp<ul>
<li>支持大文件上传下载</li>
<li>性能更好</li>
<li>一般需要二次封装</li>
</ul>
</li>
<li>Retrofit<ul>
<li>可以通过注解配置请求</li>
<li>可以搭配转换器解析数据，支持jackjson，pb等</li>
</ul>
</li>
</ul>
<h3 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h3><p>Retrofit其实是对OkHttp的一个封装，使用Retrofit库的基本流程包括引用、创建用于描述网络请求的接口、使用Retrofit实例发起网络请求。</p>
<blockquote>
<p>场景：客户端知道用户uid，要在服务端查询用户姓名，通过Retrofit实现</p>
</blockquote>
<ul>
<li>接口：<code>https://www.bytedane.com/&#123;uid&#125;/name</code></li>
<li>类型：GET请求</li>
<li>接口返回：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;data&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;1123&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;first_name&quot;</span>:<span class="string">&quot;张&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;last_name&quot;</span>:<span class="string">&quot;三丰&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.导入dependencies依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建用于描述网络请求的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUserInfoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;uid&#125;/name&quot;)</span></span><br><span class="line">  <span class="function">fun <span class="title">getUserName</span><span class="params">(<span class="meta">@Path(&quot;uid&quot;)</span> uid: Int)</span>: Call&lt;ResponseBody&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接口类名：和请求的含义相关</li>
<li>函数名：识别出该接口的作用，该Interface里可以增加多个不同的函数</li>
<li>@GET注解：指定该接口的相对路径，用get方法发起请求</li>
<li>@Path注解：需要外部调用时，用传入的uid替换注解里的{uid}</li>
<li>返回值Call&lt;ResponseBody&gt;：可以直接转换把Sring转换为Model，这里就转换为User</li>
<li>ResponseBody：根据返回内容定义的类，应当包含所有字段和一些输出方法，<code>response.body()</code>是该类的一个实例</li>
</ul>
<ol start="3">
<li>发起网络请求</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">(View)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建Retrofit实例</span></span><br><span class="line">  <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">  .baseUrl(<span class="string">&quot;https://www.bytedance.com/&quot;</span>)<span class="comment">//请求Url地址</span></span><br><span class="line">  .build()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建 网络请求接口 的实例</span></span><br><span class="line">  <span class="keyword">val</span> iUserInterface = retrofit.create(IUserInfoService::<span class="keyword">class</span>.java)</span><br><span class="line">  <span class="keyword">val</span> call = iUserInterface.getUserName(<span class="number">1123</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入队异步请求</span></span><br><span class="line">  call.enqueue(<span class="keyword">object</span>: Callback&lt;ResponseBody&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;,response: <span class="type">Response</span>&lt;<span class="type">ResponseBody</span>&gt;)</span></span> &#123;</span><br><span class="line">      request_result_tv.text = <span class="string">&quot;请求成功：&quot;</span> + response.body()!!.string();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">      request_result_tv.text = <span class="string">&quot;请求失败&quot;</span> + e.message</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Retrofit注解"><a href="#Retrofit注解" class="headerlink" title="Retrofit注解"></a>Retrofit注解</h3><!-- ![注解](/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2022-08-03-00-22-55.png) -->
<ul>
<li>注解简介<br>注解可以作用在类、方法、参数、成员变量上，并且可以在合适的时机读取注解并进行替换。<br>注解的处理一般有三个时机(Retention)：</li>
</ul>
<p>1.SOURCE: 只在源码有效<br>2.CLASS: 编译时用注解处理器处理<br>3.RUNTIME: 运行时处理</p>
<ul>
<li>注解定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(METHOD)</span><span class="comment">//作用对象</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//生命周期</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解使用</li>
</ul>
<p>可以利用Method类的接口来获取注解的内容。配合动态代理可以获取方法和参数的注解，构造Request对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClasslLoader loader, </span></span></span><br><span class="line"><span class="params"><span class="function">Class&lt;?&gt;[] interfaces, </span></span></span><br><span class="line"><span class="params"><span class="function">InvocationHandler h)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">  throw Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后可以通过<code>Method.getAnnotaion()</code>和<code>Method.getParameterAnnotation()</code>来获取方法和方法参数的注解内容。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>Retrofit的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.builder()</span><br><span class="line">      .baseUrl(<span class="string">&quot;http://www.bytedance.com/&quot;</span>)</span><br><span class="line">      .addConverterFactory(GsonConverterFactory.create())<span class="comment">//利用gson转换器解析json，需要添加gson依赖</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">IUserInfoService iUserInterface = retrofit.create(IUserInfoService.class);</span><br><span class="line"></span><br><span class="line">retrofit2.Call&lt;ResponseBody&gt; call = iUserInterface.getUserName(<span class="number">1123</span>);</span><br><span class="line"></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span> <span class="params">(Call&lt;ResponseBody&gt; call,</span></span></span><br><span class="line"><span class="params"><span class="function">      Response&lt;ResponseBody&gt; response)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call,  Throwable t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>OkHttp的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建OkHttpClient</span></span><br><span class="line">OkHttpClient OkHttpClient = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .get()</span><br><span class="line">    .url(<span class="string">&quot;https://www.bytedance.com/user/1123/name&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">OkHttp.Call call = okHttpClient.newCall(request);</span><br><span class="line"></span><br><span class="line">Call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span> <span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span> <span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 服务器响应结果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字节跳动网络库"><a href="#字节跳动网络库" class="headerlink" title="字节跳动网络库"></a>字节跳动网络库</h3><p>Cronet用C++实现，对OkHttp进行了特定优化。对其进行二次封装，设计一个高已用、功能全面的框架。最终决定基于Retrofit进行二次开发，将底层的OkHttp替换为Cronet，这就是TTNet。<br>核心点就是将OkHttpClient和OkHttpCall的生成替换为OkHttp和Cronet二选一。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/31/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/31/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">Android学习笔记（四）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-31 19:37:07" itemprop="dateCreated datePublished" datetime="2022-07-31T19:37:07+08:00">2022-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-03 22:56:14" itemprop="dateModified" datetime="2022-08-03T22:56:14+08:00">2022-08-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context是一个控制全局资源的抽象类，由Android系统负责具体实现。各个组件都需要利用Context才能访问res中的字符串，图片等资源。同时一些应用级功能也要通过Context实现</p>
<h3 id="正常设置UI时的Context"><a href="#正常设置UI时的Context" class="headerlink" title="正常设置UI时的Context"></a>正常设置UI时的Context</h3><p>正常设置UI是使用setContentView(R.layout.activity_main),这个函数会调用<code>getDelegate().setContentView(layoutResID);</code>递归地查找并且生成定义在xml中的各个View:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in AppCompatActivity.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    initViewTreeOwners();</span><br><span class="line">    <span class="comment">//调用了Activity的Delegate的同名方法，设置了mDelegate.mContext</span></span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegate.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    <span class="comment">/*这一句会触发后续的递归查找*/</span></span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中<code>AppCompactDelegat</code>类带有一个字段mContext，这个字段用在了解析xml度过程中。可以看到，调用getDelegate时会设置这个字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return The AppCompatDelegate being used by this Activity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppCompatDelegate <span class="title">getDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDelegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDelegate = AppCompatDelegate.create(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDelegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegate.java（抽象类）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppCompatDelegate <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> AppCompatCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImpl(activity, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegateImpl.java（实现）</span></span><br><span class="line">AppCompatDelegateImpl(Activity activity, AppCompatCallback callback) &#123;</span><br><span class="line">    <span class="comment">//调用另一个构造器</span></span><br><span class="line">    <span class="keyword">this</span>(activity, <span class="keyword">null</span>, callback, activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegateImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AppCompatDelegateImpl</span><span class="params">(Context context, Window window, AppCompatCallback callback,</span></span></span><br><span class="line"><span class="params"><span class="function">            Object host)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mAppCompatCallback = callback;</span><br><span class="line">    mHost = host;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现Activity本身就是mDelegate的context和callback。事实上Activity隔着漫长的继承链继承了Context类。<br>正是因为有了Context，这个解析过程在能够把id和xml中的内容联系起来。</p>
<h3 id="直接使用View"><a href="#直接使用View" class="headerlink" title="直接使用View"></a>直接使用View</h3><p>这里以imageview为例，通常我们都是在xml中定义的View组件，这样它们就会在上述的一系列过程中被加载出来，最后作为一整个activity呈现。<br>如果单独定义iv，就要显式指定Context，这里我们仍然用activity作为context，并通过他访问应用的启动图标，然后呈现在内容页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImageView iv = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">iv.setImageResource(R.mipmap.ic_launcher);</span><br><span class="line">setContentView(iv);</span><br></pre></td></tr></table></figure>

<p>在这里，同样是通过Context才能用R文件中的int常量直接找到图片。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/29/table/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/table/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-29 18:10:23 / 修改时间：18:27:28" itemprop="dateCreated datePublished" datetime="2022-07-29T18:10:23+08:00">2022-07-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>

<body>


    <h4>横跨两行的单元格：</h4>
    <table border="1">
        <tr>
            <th>类别</th>
            <th>属性</th>
            <th>功能描述</th>
        </tr>
        <tr>
            <th rowspan="8">根据父容器定位</th>
            <td>android:layout centerInParent</td>
            <td>组件位于父容器中央位置</td>
        </tr>
        <td>android:layout_centerHorizontal</td>
        <td>组件位于父容器水平中央位置</td>
        <tr>
            <td>android:layout_centerHorizontal</td>
            <td>组件位于父容器水平中央位置</td>
        </tr>
        <tr>
            <td>android:layout_centerVertical</td>
            <td>组件位于父容器垂直中央位置</td>
        </tr>
        <tr>
            <td>android:layout_alignParentTop</td>
            <td>组件与父容器顶部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentLeft</td>
            <td>组件与父容器左部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentRight</td>
            <td>组件与父容器右部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentBottom</td>
            <td>组件与父容器底部对齐</td>
        </tr>
        <tr>
            <th rowspan="7">根据兄弟组件定位</th>
            <td>android:layout_above</td>
            <td>组件位于某组件上部</td>
        </tr>
        <tr>
            <td>android:layout_below</td>
            <td>组件位于某组件下部</td>
        </tr>
        <tr>
            <td>android:layout_toLeftOf/toRightOf</td>
            <td>组件位于某组件左/右侧</td>
        </tr>
        <tr>
            <td>android:layout_alignTop/Left/Right/Below</td>
            <td>组件与某组件对齐</td>
        </tr>
    </table>

</body>

</html>
<html>

<body>


    <h4>横跨两行的单元格：</h4>
    <table border="1">
        <tr>
            <th>类别</th>
            <th>属性</th>
            <th>功能描述</th>
        </tr>
        <tr>
            <th rowspan="8">根据父容器定位</th>
            <td>android:layout centerInParent</td>
            <td>组件位于父容器中央位置</td>
        </tr>
        <td>android:layout_centerHorizontal</td>
        <td>组件位于父容器水平中央位置</td>
        <tr>
            <td>android:layout_centerHorizontal</td>
            <td>组件位于父容器水平中央位置</td>
        </tr>
        <tr>
            <td>android:layout_centerVertical</td>
            <td>组件位于父容器垂直中央位置</td>
        </tr>
        <tr>
            <td>android:layout_alignParentTop</td>
            <td>组件与父容器顶部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentLeft</td>
            <td>组件与父容器左部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentRight</td>
            <td>组件与父容器右部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentBottom</td>
            <td>组件与父容器底部对齐</td>
        </tr>
        <tr>
            <th rowspan="7">根据兄弟组件定位</th>
            <td>android:layout_above</td>
            <td>组件位于某组件上部</td>
        </tr>
        <tr>
            <td>android:layout_below</td>
            <td>组件位于某组件下部</td>
        </tr>
        <tr>
            <td>android:layout_toLeftOf/toRightOf</td>
            <td>组件位于某组件左/右侧</td>
        </tr>
        <tr>
            <td>android:layout_alignTop/Left/Right/Below</td>
            <td>组件与某组件对齐</td>
        </tr>
    </table>

</body>

</html>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">安卓UI设计</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 14:43:46" itemprop="dateCreated datePublished" datetime="2022-07-29T14:43:46+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-06 18:09:08" itemprop="dateModified" datetime="2022-08-06T18:09:08+08:00">2022-08-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android-UI组件"><a href="#Android-UI组件" class="headerlink" title="Android UI组件"></a>Android UI组件</h2><p>User Interface，用户接口。包括输入框，文本，按钮，播放器，图片，列表等。常规的组件大多由android.widget包中提供，这些组件有通用的属性和方法，也有自己特定的属性和方法。比如所有组件都有id，height，width，margin等属性，而TextView有setText的方法。</p>
<h3 id="常规UI组件"><a href="#常规UI组件" class="headerlink" title="常规UI组件"></a>常规UI组件</h3><p>安卓组件以左上角为原点，向下向右为正方向。这也是组件的默认布置为止<br>带有layout的属性通常是组件相对于父容器的对齐方式，带有padding的则是子元素相对于容器的对齐方式</p>
<!-- ![qaq](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-14-48-30.png) -->
<p><img src="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-15-55-51.png" alt="组件属性"></p>
<h3 id="高级UI组件"><a href="#高级UI组件" class="headerlink" title="高级UI组件"></a>高级UI组件</h3><p>高级组件通常继承自ViewGroup，可以内含多个View组件，也可以继续嵌套ViewGroup</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局将ui组合成页面，主要控制<strong>大小、位置、层级</strong></p>
<h3 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h3><!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-15-35-54.png) -->

<table>
<thead>
<tr>
<th>属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:orientation</td>
<td>布局内组件的排列方向</td>
</tr>
<tr>
<td>android:layout_weight</td>
<td>布局内组件大小权重</td>
</tr>
<tr>
<td>android:divider</td>
<td>布局内组件间分割线</td>
</tr>
<tr>
<td>android:showDividers</td>
<td>布局内组件间分割线位置</td>
</tr>
<tr>
<td>android:dividerPadding</td>
<td>布局内分割线padding</td>
</tr>
</tbody></table>
<p>linearlayout的分割线功能可以很容易的画出有质感的ui</p>
<p>weight功能是指示分配剩余空间时的权重（剩余空间可正可负），各个组件<a target="_blank" rel="noopener" href="https://blog.csdn.net/ddiididi/article/details/80954084">按照权重加权平均</a>分配剩余的空间。</p>
<p>如果想要在linearlayout里做出垂直于orientation方向的效果，就要再嵌套一个另一方向的linearlayout</p>
<h3 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h3><p>相对布局提供了根据父容器和兄弟容器进行定位的方法</p>
<!-- ![ui](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-16-21-06.png) -->
<html>

<body>
    <h4></h4>
    <table border="1">
        <tr>
            <th>类别</th>
            <th>属性</th>
            <th>功能描述</th>
        </tr>
        <tr>
            <th rowspan="8">根据父容器定位</th>
            <td>android:layout centerInParent</td>
            <td>组件位于父容器中央位置</td>
        </tr>
        <td>android:layout_centerHorizontal</td>
        <td>组件位于父容器水平中央位置</td>
        <tr>
            <td>android:layout_centerHorizontal</td>
            <td>组件位于父容器水平中央位置</td>
        </tr>
        <tr>
            <td>android:layout_centerVertical</td>
            <td>组件位于父容器垂直中央位置</td>
        </tr>
        <tr>
            <td>android:layout_alignParentTop</td>
            <td>组件与父容器顶部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentLeft</td>
            <td>组件与父容器左部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentRight</td>
            <td>组件与父容器右部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentBottom</td>
            <td>组件与父容器底部对齐</td>
        </tr>
        <tr>
            <th rowspan="7">根据兄弟组件定位</th>
            <td>android:layout_above</td>
            <td>组件位于某组件上部</td>
        </tr>
        <tr>
            <td>android:layout_below</td>
            <td>组件位于某组件下部</td>
        </tr>
        <tr>
            <td>android:layout_toLeftOf/toRightOf</td>
            <td>组件位于某组件左/右侧</td>
        </tr>
        <tr>
            <td>android:layout_alignTop/Left/Right/Below</td>
            <td>组件与某组件对齐</td>
        </tr>
    </table>

</body>

</html>

<h3 id="层级布局FrameLayout"><a href="#层级布局FrameLayout" class="headerlink" title="层级布局FrameLayout"></a>层级布局FrameLayout</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:foreground</td>
<td>设置前景图像（永远位于最前）</td>
</tr>
<tr>
<td>android:foregroundGravity</td>
<td>设置前景图像Gravity</td>
</tr>
</tbody></table>
<p>各个组件从前到后依次在后方作为背景</p>
<h3 id="限制布局ConstraintLayout"><a href="#限制布局ConstraintLayout" class="headerlink" title="限制布局ConstraintLayout"></a>限制布局ConstraintLayout</h3><table>
<thead>
<tr>
<th>属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout_constraintLeft_toLeftOf</td>
<td>组件左部与某组件左部对齐</td>
</tr>
<tr>
<td>layout_constraintLeft_toRightOf</td>
<td>组件左部与某组件右部对齐</td>
</tr>
<tr>
<td>layout_constraintRight_toLefOf</td>
<td>组件右部与某组件左部对齐</td>
</tr>
<tr>
<td>layout_constraintRight_toRightOf</td>
<td>组件右部与某组件右部对齐</td>
</tr>
<tr>
<td>layout_constraintTop_toTopof</td>
<td>组件顶部与某组件顶部对齐</td>
</tr>
<tr>
<td>layout_constraintTop_toBottomOf</td>
<td>组件右顶与某组件底部对齐</td>
</tr>
<tr>
<td>layout_constraintBotom_toTopof</td>
<td>组件底部与某组件顶部对齐</td>
</tr>
<tr>
<td>layout_constraintBottom_toBottomOf</td>
<td>组件底部与某组件底部对齐</td>
</tr>
<tr>
<td>layout_constraintBascline_toBasclincO</td>
<td>组件基线与某组件基线对齐</td>
</tr>
<tr>
<td>laycut_constraintStart_toEndOf</td>
<td>组件首部与某组件尾部对齐</td>
</tr>
<tr>
<td>layout_constraintStart_toStartOf</td>
<td>组件首部与某组件首部对齐</td>
</tr>
<tr>
<td>layout_constraintEnd_toStartOf</td>
<td>组件尾部与某组件首部对齐</td>
</tr>
<tr>
<td>layout_constraintEnd_toEndOf</td>
<td>组件尾部与某组件尾部对齐</td>
</tr>
</tbody></table>
<p>如果限制信息确定了图片某几条边的位置，会覆盖height，width属性</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><img src="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-28-58.png" alt="总结"></p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>布局是用xml中声明，java中实现的。因此布局的渲染需要经过加载、解析和渲染的三个过程，</p>
<p>在activity的onCreate方法中调用setContentView时，它会创建DecorView，最终通过LayoutInflater加载了XML文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater.from(mContext).inflate(resId, contentParent)</span><br></pre></td></tr></table></figure>

<p>在这个加载器中，它会调用一个xml解析器，解析器根据tag生成View，组织ViewGroup并把他们添加到DecorView中…</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-43-39.png) -->

<p>此时屏幕还没有被绘制，在onResume()中会“借用”ViewRootImpl对象的requestLayout方法来触发配置。</p>
<!-- ![View绘制流程](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-46-13.png)
![页面绘制流程](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-47-16.png) -->
<p>在这之后，由VSync一帧为单位控制界面的刷新。00</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-49-59.png) -->

<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><h3 id="查找View"><a href="#查找View" class="headerlink" title="查找View"></a>查找View</h3><p>交互最基本的流程是先获取View实例，再添加相应的监听器（比如按钮的onClickListener()）</p>
<p>查找的过程中，activity调用DecorView的findViewById方法，每个ViewGroup都会迭代查找自己的孩子，方法是在ViewGroup和View中都实现findViewById，Group会判断自己的id并且调用所有孩子的findViewById。对于View而言，这个方法要么返回自己，要么返回NULL，对于Group而言，他将进行下一轮迭代。这样所有人都只需要知道自己的id，Group再额外记录自己有哪些孩子，就可以从DecorView开始查找到任何被解析过的View了。</p>
<h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>Android系统中常见的事件监听器有如下几种:</p>
<ol>
<li><p>单击事件(View.OnClickListener):当用户触碰到某个组件或者方向键被按下时产生该事件，该事件的处理方法是onClick（）.</p>
</li>
<li><p>焦点事件(View.OnFocusChangeListener):组件得到或者失去焦点时产生该事件，事件处理方法是onFocusChange（）。</p>
</li>
<li><p>按键事件(View.OnKey Listener):用户按下或者释放设备上的某个按键时产生，事件处理方法是 onKey（）。</p>
</li>
<li><p>触碰事件(View.OnTouchListener):设备具有触摸屏功能时，触碰屏幕产生该事件。事件处理方法是onTouch（）。</p>
</li>
<li><p>创建上下文菜单事件(View.OnCreateContextMenu Listener):创建上下文菜单时产生该事件，事件处理方法是 onCreateContextMenu（）。</p>
</li>
</ol>
<h3 id="屏幕触摸"><a href="#屏幕触摸" class="headerlink" title="屏幕触摸"></a>屏幕触摸</h3><p>所有事件都来自于屏幕触摸，交互事件是对屏幕点击的二次封装！触摸事件MotionEvent包含了触摸的时间、位置等，Activity和View都有onTouchEvent()用于处理触摸事件</p>
<!-- 
![触摸事件](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-03-07.png) -->

<p>接收到一个屏幕事件之后，具体要由哪个UI控件来响应，涉及到时事件的处理流程。触摸一个点很可能同时触摸了多个View，几个Layout还有至少一个Activity。在实践处理中，ViewGroup具有分发、拦截、响应的功能，Activity和View则不具有拦截的功能。<br><img src="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-11-07.png" alt="事件处理"><br>出处(<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904041487532045">https://juejin.cn/post/6844904041487532045</a>)</p>
<p>如何理解onLongClickListener，onClickLisener，onTouchEvent的关系呢？在onTouchEvent在ACTION_DOWN时判断是否达到长按延时，而在ACTION_UP的时候才执行短按延时，此时如果已经出发了了长按执行的监听器，就不再执行短按的监听器，所以说onClickListener是在抬起手指时才触发的，并且不能与onLongClickListener一同触发。</p>
<h3 id="交互总结"><a href="#交互总结" class="headerlink" title="交互总结"></a>交互总结</h3><p>从谁发出，经过了谁，到达哪个对象，有何种行为。</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-17-15.png) -->

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h3><p>核心原理就是一帧一帧的播放图片，优点是简单、方便，缺点是功能单一，并且消耗资源。相比于gif，帧动画更可控。</p>
<!-- ![帧动画](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-18-15.png) -->

<p>帧动画是通过animation-list声明的，有子标签item，item包含drawable和duration两个属性。</p>
<h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><!-- 
![补间动画](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-21-48.png) -->
<p>补间动画可以控制透明度，旋转，缩放，平移，由系统自动由插值器（Interpolator）</p>
<p>这两种动画都是属于View动画，只能处理View对象，并且无法修改View的属性。（会出现动画无法点击的情况）</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-24-32.png) -->

<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>属性动画可以作用于任何一个对象，并且真实的改变了对象的属性。</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-25-57.png) -->

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>真正的动画需要结合各个动画才能做出更好的效果。</p>
<h2 id="自定义UI"><a href="#自定义UI" class="headerlink" title="自定义UI"></a>自定义UI</h2><!-- github.com/zeweng/SwitchButton -->

<h3 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h3><p>写四个构造器，对应四种场景。按需复写各方法，并且用各个方法绘制出View，然后再onTouchEvent中处理UI的行为和动画</p>
<!-- ![自定义View](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/自定义View.png)
![处理View布局](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/处理View布局.png) -->
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/绘制View.png) -->
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/处理用户交互.png) -->
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/自定义小结.png) -->

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/整体总结.png) -->
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/28/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">Android学习笔记（三）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-28 00:48:49 / 修改时间：20:58:30" itemprop="dateCreated datePublished" datetime="2022-07-28T00:48:49+08:00">2022-07-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Intent的概念与使用"><a href="#Intent的概念与使用" class="headerlink" title="Intent的概念与使用"></a>Intent的概念与使用</h2><p>关于Intent，目前只用在启动activity上，通常启动一个activity时需要传递一个intent参数给指定的activity，同时也可以在这个Intent中夹带一些参数进行传递。</p>
<h3 id="用显示Intent启动Activity"><a href="#用显示Intent启动Activity" class="headerlink" title="用显示Intent启动Activity"></a>用显示Intent启动Activity</h3><p>显示intent就是指定了要启动的activity的类的intent，这种intent通常是用在app内activity之间的交互。接下来就来在一个项目里注册两个activity来看一看如何用intent启动。</p>
<p>如果不直接新建activity，就要新建一个java类，并令它继承Activity类，还要在res文件夹中新建layout文件定义其ui。之后在java文件中实现Activity的各个方法，通常在onCreate方法中进行layout与activity的绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.myaty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后为了使用这个activity中，我们还需要在AndroidManifest文件中进行注册,注意activity的name会与manifest的package组合起来作为Activity类的名称，所以在这里注册时可以使用简写，也可以在name中写全<code>包名.类名</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.study4intent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyAty&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--           name added to package as the name of an Activity object--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            use com.example.study4intent.MyAty instead--&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>到这里，我们就已经新建了一个activity，并且可以绑定它对应的java和res文件了。如果直接在AS中新建activity的话，ide会自动帮我们完成这些配置工作。</p>
<p>到这里，我们就可以试着用显示intent启动activity了，这里选择用一个按钮来触发新activity的启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.button).setOnClickListener(</span><br><span class="line">    <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Intent intent =</span><br><span class="line">                <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MyAty.class);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>java允许传new出来的参数，而new抽象类需要实现抽象方法，这种嵌套方式写出来的代码非常紧凑，不过通常我们会把findViewById的结果声明为private变量保存下来方便以后调用。</p>
<p>查看Intent构造器可知Intent可以用一个Context类型对象和一个class泛型来构造，这就是我们的显示Intent要传递的包名和类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Intent</span><span class="params">(Context packageContext, Class&lt;?&gt; cls)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>Intent除了用显式指定的包名和类名构造之外，也可以先通过一个标记构造，之后再寻找标记对应的类。最常见的方法是使用action，也就是一个字符串。如果用action构造了一个intent，那么就可以直接用这个字符串搜索到注册了这个action的类。（小疑惑，如果有两个一样的action会怎样呢？）</p>
<h3 id="注册action"><a href="#注册action" class="headerlink" title="注册action"></a>注册action</h3><p>在androidmanifest文件中，activity下加入intent-fliter标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;qaq&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，新版Android可能会报错，要求指定activity是否exported，直接用快速修复功能设置为true即可。下文会讲到。</p>
<p>category的name暂时选择default就可以，而action的name则要注册为对应的字符串，标准的action格式是<code>&lt;package_name&gt;.action.start.&lt;class_name&gt;</code>，不过这个格式实在过于复杂，我们也可以把action的名字放在要启动的类中，作为一个常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAty</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION = <span class="string">&quot;qaq&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在使用Intent时，就不需要直接输入长长的字符串，使用<code>MyAty.ACTION</code>就可以了</p>
<h3 id="用隐式Intent启动同一个app内的另一个Activity"><a href="#用隐式Intent启动同一个app内的另一个Activity" class="headerlink" title="用隐式Intent启动同一个app内的另一个Activity"></a>用隐式Intent启动同一个app内的另一个Activity</h3><p>基本的方法和之前都是相同的，区别就是构造intent时调用了另一种构造器：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.button).setOnClickListener(</span><br><span class="line">    new View.OnClickListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onClick(View view) &#123;</span><br><span class="line">            Intent intent =</span><br><span class="line"><span class="deletion">-                new Intent(MainActivity.this, MyAty.class);</span></span><br><span class="line"><span class="addition">+                new Intent(&quot;qaq&quot;);</span></span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Intent</span><span class="params">(String action)</span></span></span><br></pre></td></tr></table></figure>

<p>当然，隐式Intent最主要的作用并不是用来启动同一个应用内的activity，因为此时我们是可以直接获得这个activity的类的定义的。而在跨应用通讯时，隐式Intent就有用处了。</p>
<h3 id="用Intent跨应用启动activity"><a href="#用Intent跨应用启动activity" class="headerlink" title="用Intent跨应用启动activity"></a>用Intent跨应用启动activity</h3><p>还记得之前AS可能会要求我们添加的exported属性吗：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        &lt;activity android:name=&quot;.MyAty&quot;</span><br><span class="line"><span class="addition">+            android:exported=&quot;false&quot;&gt;</span></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;qaq&quot;/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<p>这是安卓权限管理引入的机制：只有设置为exported的activity对其他应用才是可见的，现在我们可以把它改为true，然后在project中新建一个package（app），并且在另一个app中启动这个app的activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btn_start_myaty).setOnClickListener(</span><br><span class="line">        <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(<span class="string">&quot;qaq&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;无法启动MyAty&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里使用了try结构来捕获可能的异常，如果前面没有正确的设置exported的话，就可能导致异常的出现。捕获到异常之后，用Toast组件打印一条提示信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/26/%E5%AE%89%E5%8D%93%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/%E5%AE%89%E5%8D%93%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">安卓四大组件</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 16:14:58" itemprop="dateCreated datePublished" datetime="2022-07-26T16:14:58+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="activity的使用"><a href="#activity的使用" class="headerlink" title="activity的使用"></a>activity的使用</h3><ol>
<li>在Android Menifest文件中注册</li>
<li>在xml文件中设定layout</li>
<li>在java文件中绑定activity</li>
</ol>
<p>GridView + Adaptor, GridView + Adaptor, ViewPager + Adaptor</p>
<h3 id="activity生命周期"><a href="#activity生命周期" class="headerlink" title="activity生命周期"></a>activity生命周期</h3><ol>
<li>onCreate<br>程序创建，进行文件的绑定</li>
<li>onStart<br>程序不可见，用户不可交互，进行一些</li>
<li>onResume<br>程序可见，用户可以交互</li>
<li>onPause<br>程序部分不可见，（比如被弹窗遮挡），在这里是最后一个比较靠谱的数据保存点（Android 5.0-）。<br>之后也可以在onStop中进行数据保存<br>如果之后恢复可见，会调用onResume</li>
<li>onStop<br>程序被完全遮挡，如果恢复，经由onRestart回到onStart</li>
<li>onDestroy<br>程序被销毁，注意，很多场景下可能不会走到这一步，而是在停止之后直接被系统回收</li>
</ol>
<p>配置变化（字体改变，屏幕旋转，键盘显示隐藏…）时的生命周期：先杀死再重建，杀死时在onPause之前调用onSaveInstanceState，<br>恢复时在onStart之后调用onRestoreInstanceState</p>
<p>如果不希望重建activity，可以在android_menifest文件中配置，在配置改变时调用onConfigurationChange，而不销毁。</p>
<blockquote>
<p>案例：接完电话之后，程序crush！</p>
</blockquote>
<ul>
<li><p>解释：页面被回收导致本地变量被清空</p>
</li>
<li><p>解决：添加判空逻辑避免空指针</p>
<ul>
<li>利用两个InstanceState保存和恢复现场！</li>
</ul>
</li>
</ul>
<h3 id="activity启动模式"><a href="#activity启动模式" class="headerlink" title="activity启动模式"></a>activity启动模式</h3><p>对于每个activity，都可以在android：launchMode中配置启动模式来达到消除重复activity的效果</p>
<ol>
<li>standard（默认）<br>每次启动页面都会在页面栈中添加一个新实例</li>
<li>singleTop<br>不允许栈顶有多个相同实例，试图创建新示例时会回调onNewInstance，然后无事发生</li>
<li>singleTask<br>不允许栈内有多个实例，如果试图创建新示例，将弹出页面之上的所有页面，然后回调onNewInstance</li>
<li>singleInstance<br>全局只能有一个实例，应用较少（银行登陆界面，通讯录黄页）</li>
</ol>
<blockquote>
<p>应用：返回首页的小按钮</p>
</blockquote>
<ul>
<li>实现：将主页activity设置为singleTask</li>
</ul>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>安卓设计fragment的初衷是为了解决页面碎片化的问题，不过平时开发中fragment经常用于提高速度（activity之间交互需要进行IPC），<br>以及进行组件的分离（在屏幕的各个区域用不同的fragment承载功能）</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol>
<li>创建布局文件</li>
<li>在java中加载布局文件</li>
<li>在activity中加载fragment<br>3.1 静态绑定-在布局文件中绑定<br>3.2 通过FragmentManager加载</li>
</ol>
<p>一般使用androidx.fragment，而不是android.app.fragment，以确保版本兼容</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li>onAttach<br> 使用activity资源时可以在此进行获取</li>
<li>onCreateView<br> 常用于初始化</li>
<li>onResume<br> 运行状态</li>
<li>onDestroyView<br> 资源回收</li>
</ol>
<p>此外也可以通过FragmentTranscation.maxLifeCycle设置可到达的最远生命周期</p>
<h3 id="与activity交互"><a href="#与activity交互" class="headerlink" title="与activity交互"></a>与activity交互</h3><p>组件获取</p>
<ul>
<li><code>getActivity.findViewById(R.id.xx)</code></li>
<li>getFragmentManager.findFragmentById()</li>
</ul>
<p>数据传递</p>
<ol>
<li>setArguments(Bundle bundle)</li>
<li>方法调用</li>
<li>viewmodel，handler，broadcast</li>
</ol>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>基本用法</p>
<ol>
<li>android_menifest注冊</li>
<li>java中实现类</li>
<li>加载：需要交互用bindService，不需要交互用startService</li>
</ol>
<h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><p>start， bind， destroy<br>&#x2F;&#x2F;TODO</p>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ol>
<li>定义Binder子类，实现getService方法，返回Service对象</li>
<li>实现Service类onBind方法，返回Binder对象</li>
<li>实例化ServiceConnection对象<br>&#x2F;&#x2F;TODO</li>
</ol>
<h2 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h2><p>静态广播：使用receiver，在java中实现BroadcastReceiver，用onRecieve接收，用Context.sendBroadcast发送<br>动态广播：</p>
<p>常用广播：网络&#x2F;电量变化，屏幕点亮&#x2F;熄灭，安装卸载升级软件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="辉夜"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">辉夜</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">辉夜</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
