<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huiyeruzhou.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="辉夜的博客">
<meta property="og:url" content="http://huiyeruzhou.github.io/page/2/index.html">
<meta property="og:site_name" content="辉夜的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="辉夜">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://huiyeruzhou.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>辉夜的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">辉夜的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">繁花似锦，辉夜如昼</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">网络通讯与数据存储</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-02 12:45:10" itemprop="dateCreated datePublished" datetime="2022-08-02T12:45:10+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-03 01:22:37" itemprop="dateModified" datetime="2022-08-03T01:22:37+08:00">2022-08-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络请求框架对比：</p>
<ul>
<li>HttpURLConnection</li>
<li>Volley<ul>
<li>停更</li>
<li>不适合上传下载文件</li>
</ul>
</li>
<li>OkHttp<ul>
<li>支持大文件上传下载</li>
<li>性能更好</li>
<li>一般需要二次封装</li>
</ul>
</li>
<li>Retrofit<ul>
<li>可以通过注解配置请求</li>
<li>可以搭配转换器解析数据，支持jackjson，pb等</li>
</ul>
</li>
</ul>
<h3 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h3><p>Retrofit其实是对OkHttp的一个封装，使用Retrofit库的基本流程包括引用、创建用于描述网络请求的接口、使用Retrofit实例发起网络请求。</p>
<blockquote>
<p>场景：客户端知道用户uid，要在服务端查询用户姓名，通过Retrofit实现</p>
</blockquote>
<ul>
<li>接口：<code>https://www.bytedane.com/&#123;uid&#125;/name</code></li>
<li>类型：GET请求</li>
<li>接口返回：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;data&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;1123&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;first_name&quot;</span>:<span class="string">&quot;张&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;last_name&quot;</span>:<span class="string">&quot;三丰&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.导入dependencies依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建用于描述网络请求的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUserInfoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;uid&#125;/name&quot;)</span></span><br><span class="line">  <span class="function">fun <span class="title">getUserName</span><span class="params">(<span class="meta">@Path(&quot;uid&quot;)</span> uid: Int)</span>: Call&lt;ResponseBody&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接口类名：和请求的含义相关</li>
<li>函数名：识别出该接口的作用，该Interface里可以增加多个不同的函数</li>
<li>@GET注解：指定该接口的相对路径，用get方法发起请求</li>
<li>@Path注解：需要外部调用时，用传入的uid替换注解里的{uid}</li>
<li>返回值Call&lt;ResponseBody&gt;：可以直接转换把Sring转换为Model，这里就转换为User</li>
<li>ResponseBody：根据返回内容定义的类，应当包含所有字段和一些输出方法，<code>response.body()</code>是该类的一个实例</li>
</ul>
<ol start="3">
<li>发起网络请求</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserName</span><span class="params">(View)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建Retrofit实例</span></span><br><span class="line">  <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">  .baseUrl(<span class="string">&quot;https://www.bytedance.com/&quot;</span>)<span class="comment">//请求Url地址</span></span><br><span class="line">  .build()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建 网络请求接口 的实例</span></span><br><span class="line">  <span class="keyword">val</span> iUserInterface = retrofit.create(IUserInfoService::<span class="keyword">class</span>.java)</span><br><span class="line">  <span class="keyword">val</span> call = iUserInterface.getUserName(<span class="number">1123</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入队异步请求</span></span><br><span class="line">  call.enqueue(<span class="keyword">object</span>: Callback&lt;ResponseBody&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;,response: <span class="type">Response</span>&lt;<span class="type">ResponseBody</span>&gt;)</span></span> &#123;</span><br><span class="line">      request_result_tv.text = <span class="string">&quot;请求成功：&quot;</span> + response.body()!!.string();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">      request_result_tv.text = <span class="string">&quot;请求失败&quot;</span> + e.message</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Retrofit注解"><a href="#Retrofit注解" class="headerlink" title="Retrofit注解"></a>Retrofit注解</h3><!-- ![注解](/2022/08/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2022-08-03-00-22-55.png) -->
<ul>
<li>注解简介<br>注解可以作用在类、方法、参数、成员变量上，并且可以在合适的时机读取注解并进行替换。<br>注解的处理一般有三个时机(Retention)：</li>
</ul>
<p>1.SOURCE: 只在源码有效<br>2.CLASS: 编译时用注解处理器处理<br>3.RUNTIME: 运行时处理</p>
<ul>
<li>注解定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(METHOD)</span><span class="comment">//作用对象</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//生命周期</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GET &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解使用</li>
</ul>
<p>可以利用Method类的接口来获取注解的内容。配合动态代理可以获取方法和参数的注解，构造Request对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClasslLoader loader, </span></span></span><br><span class="line"><span class="params"><span class="function">Class&lt;?&gt;[] interfaces, </span></span></span><br><span class="line"><span class="params"><span class="function">InvocationHandler h)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">  throw Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后可以通过<code>Method.getAnnotaion()</code>和<code>Method.getParameterAnnotation()</code>来获取方法和方法参数的注解内容。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>Retrofit的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.builder()</span><br><span class="line">      .baseUrl(<span class="string">&quot;http://www.bytedance.com/&quot;</span>)</span><br><span class="line">      .addConverterFactory(GsonConverterFactory.create())<span class="comment">//利用gson转换器解析json，需要添加gson依赖</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">IUserInfoService iUserInterface = retrofit.create(IUserInfoService.class);</span><br><span class="line"></span><br><span class="line">retrofit2.Call&lt;ResponseBody&gt; call = iUserInterface.getUserName(<span class="number">1123</span>);</span><br><span class="line"></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span> <span class="params">(Call&lt;ResponseBody&gt; call,</span></span></span><br><span class="line"><span class="params"><span class="function">      Response&lt;ResponseBody&gt; response)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call,  Throwable t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>OkHttp的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建OkHttpClient</span></span><br><span class="line">OkHttpClient OkHttpClient = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .get()</span><br><span class="line">    .url(<span class="string">&quot;https://www.bytedance.com/user/1123/name&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">OkHttp.Call call = okHttpClient.newCall(request);</span><br><span class="line"></span><br><span class="line">Call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span> <span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span> <span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 服务器响应结果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字节跳动网络库"><a href="#字节跳动网络库" class="headerlink" title="字节跳动网络库"></a>字节跳动网络库</h3><p>Cronet用C++实现，对OkHttp进行了特定优化。对其进行二次封装，设计一个高已用、功能全面的框架。最终决定基于Retrofit进行二次开发，将底层的OkHttp替换为Cronet，这就是TTNet。<br>核心点就是将OkHttpClient和OkHttpCall的生成替换为OkHttp和Cronet二选一。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/31/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/31/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">Android学习笔记（四）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-31 19:37:07" itemprop="dateCreated datePublished" datetime="2022-07-31T19:37:07+08:00">2022-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-03 22:56:14" itemprop="dateModified" datetime="2022-08-03T22:56:14+08:00">2022-08-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context是一个控制全局资源的抽象类，由Android系统负责具体实现。各个组件都需要利用Context才能访问res中的字符串，图片等资源。同时一些应用级功能也要通过Context实现</p>
<h3 id="正常设置UI时的Context"><a href="#正常设置UI时的Context" class="headerlink" title="正常设置UI时的Context"></a>正常设置UI时的Context</h3><p>正常设置UI是使用setContentView(R.layout.activity_main),这个函数会调用<code>getDelegate().setContentView(layoutResID);</code>递归地查找并且生成定义在xml中的各个View:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in AppCompatActivity.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    initViewTreeOwners();</span><br><span class="line">    <span class="comment">//调用了Activity的Delegate的同名方法，设置了mDelegate.mContext</span></span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegate.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    <span class="comment">/*这一句会触发后续的递归查找*/</span></span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中<code>AppCompactDelegat</code>类带有一个字段mContext，这个字段用在了解析xml度过程中。可以看到，调用getDelegate时会设置这个字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return The AppCompatDelegate being used by this Activity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppCompatDelegate <span class="title">getDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDelegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDelegate = AppCompatDelegate.create(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDelegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegate.java（抽象类）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppCompatDelegate <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> AppCompatCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImpl(activity, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegateImpl.java（实现）</span></span><br><span class="line">AppCompatDelegateImpl(Activity activity, AppCompatCallback callback) &#123;</span><br><span class="line">    <span class="comment">//调用另一个构造器</span></span><br><span class="line">    <span class="keyword">this</span>(activity, <span class="keyword">null</span>, callback, activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in AppCompatDelegateImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AppCompatDelegateImpl</span><span class="params">(Context context, Window window, AppCompatCallback callback,</span></span></span><br><span class="line"><span class="params"><span class="function">            Object host)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mAppCompatCallback = callback;</span><br><span class="line">    mHost = host;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现Activity本身就是mDelegate的context和callback。事实上Activity隔着漫长的继承链继承了Context类。<br>正是因为有了Context，这个解析过程在能够把id和xml中的内容联系起来。</p>
<h3 id="直接使用View"><a href="#直接使用View" class="headerlink" title="直接使用View"></a>直接使用View</h3><p>这里以imageview为例，通常我们都是在xml中定义的View组件，这样它们就会在上述的一系列过程中被加载出来，最后作为一整个activity呈现。<br>如果单独定义iv，就要显式指定Context，这里我们仍然用activity作为context，并通过他访问应用的启动图标，然后呈现在内容页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImageView iv = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">iv.setImageResource(R.mipmap.ic_launcher);</span><br><span class="line">setContentView(iv);</span><br></pre></td></tr></table></figure>

<p>在这里，同样是通过Context才能用R文件中的int常量直接找到图片。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/29/table/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/table/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-29 18:10:23 / 修改时间：18:27:28" itemprop="dateCreated datePublished" datetime="2022-07-29T18:10:23+08:00">2022-07-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>

<body>


    <h4>横跨两行的单元格：</h4>
    <table border="1">
        <tr>
            <th>类别</th>
            <th>属性</th>
            <th>功能描述</th>
        </tr>
        <tr>
            <th rowspan="8">根据父容器定位</th>
            <td>android:layout centerInParent</td>
            <td>组件位于父容器中央位置</td>
        </tr>
        <td>android:layout_centerHorizontal</td>
        <td>组件位于父容器水平中央位置</td>
        <tr>
            <td>android:layout_centerHorizontal</td>
            <td>组件位于父容器水平中央位置</td>
        </tr>
        <tr>
            <td>android:layout_centerVertical</td>
            <td>组件位于父容器垂直中央位置</td>
        </tr>
        <tr>
            <td>android:layout_alignParentTop</td>
            <td>组件与父容器顶部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentLeft</td>
            <td>组件与父容器左部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentRight</td>
            <td>组件与父容器右部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentBottom</td>
            <td>组件与父容器底部对齐</td>
        </tr>
        <tr>
            <th rowspan="7">根据兄弟组件定位</th>
            <td>android:layout_above</td>
            <td>组件位于某组件上部</td>
        </tr>
        <tr>
            <td>android:layout_below</td>
            <td>组件位于某组件下部</td>
        </tr>
        <tr>
            <td>android:layout_toLeftOf/toRightOf</td>
            <td>组件位于某组件左/右侧</td>
        </tr>
        <tr>
            <td>android:layout_alignTop/Left/Right/Below</td>
            <td>组件与某组件对齐</td>
        </tr>
    </table>

</body>

</html>
<html>

<body>


    <h4>横跨两行的单元格：</h4>
    <table border="1">
        <tr>
            <th>类别</th>
            <th>属性</th>
            <th>功能描述</th>
        </tr>
        <tr>
            <th rowspan="8">根据父容器定位</th>
            <td>android:layout centerInParent</td>
            <td>组件位于父容器中央位置</td>
        </tr>
        <td>android:layout_centerHorizontal</td>
        <td>组件位于父容器水平中央位置</td>
        <tr>
            <td>android:layout_centerHorizontal</td>
            <td>组件位于父容器水平中央位置</td>
        </tr>
        <tr>
            <td>android:layout_centerVertical</td>
            <td>组件位于父容器垂直中央位置</td>
        </tr>
        <tr>
            <td>android:layout_alignParentTop</td>
            <td>组件与父容器顶部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentLeft</td>
            <td>组件与父容器左部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentRight</td>
            <td>组件与父容器右部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentBottom</td>
            <td>组件与父容器底部对齐</td>
        </tr>
        <tr>
            <th rowspan="7">根据兄弟组件定位</th>
            <td>android:layout_above</td>
            <td>组件位于某组件上部</td>
        </tr>
        <tr>
            <td>android:layout_below</td>
            <td>组件位于某组件下部</td>
        </tr>
        <tr>
            <td>android:layout_toLeftOf/toRightOf</td>
            <td>组件位于某组件左/右侧</td>
        </tr>
        <tr>
            <td>android:layout_alignTop/Left/Right/Below</td>
            <td>组件与某组件对齐</td>
        </tr>
    </table>

</body>

</html>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">安卓UI设计</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 14:43:46" itemprop="dateCreated datePublished" datetime="2022-07-29T14:43:46+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-06 18:09:08" itemprop="dateModified" datetime="2022-08-06T18:09:08+08:00">2022-08-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android-UI组件"><a href="#Android-UI组件" class="headerlink" title="Android UI组件"></a>Android UI组件</h2><p>User Interface，用户接口。包括输入框，文本，按钮，播放器，图片，列表等。常规的组件大多由android.widget包中提供，这些组件有通用的属性和方法，也有自己特定的属性和方法。比如所有组件都有id，height，width，margin等属性，而TextView有setText的方法。</p>
<h3 id="常规UI组件"><a href="#常规UI组件" class="headerlink" title="常规UI组件"></a>常规UI组件</h3><p>安卓组件以左上角为原点，向下向右为正方向。这也是组件的默认布置为止<br>带有layout的属性通常是组件相对于父容器的对齐方式，带有padding的则是子元素相对于容器的对齐方式</p>
<!-- ![qaq](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-14-48-30.png) -->
<p><img src="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-15-55-51.png" alt="组件属性"></p>
<h3 id="高级UI组件"><a href="#高级UI组件" class="headerlink" title="高级UI组件"></a>高级UI组件</h3><p>高级组件通常继承自ViewGroup，可以内含多个View组件，也可以继续嵌套ViewGroup</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局将ui组合成页面，主要控制<strong>大小、位置、层级</strong></p>
<h3 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h3><!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-15-35-54.png) -->

<table>
<thead>
<tr>
<th>属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:orientation</td>
<td>布局内组件的排列方向</td>
</tr>
<tr>
<td>android:layout_weight</td>
<td>布局内组件大小权重</td>
</tr>
<tr>
<td>android:divider</td>
<td>布局内组件间分割线</td>
</tr>
<tr>
<td>android:showDividers</td>
<td>布局内组件间分割线位置</td>
</tr>
<tr>
<td>android:dividerPadding</td>
<td>布局内分割线padding</td>
</tr>
</tbody></table>
<p>linearlayout的分割线功能可以很容易的画出有质感的ui</p>
<p>weight功能是指示分配剩余空间时的权重（剩余空间可正可负），各个组件<a target="_blank" rel="noopener" href="https://blog.csdn.net/ddiididi/article/details/80954084">按照权重加权平均</a>分配剩余的空间。</p>
<p>如果想要在linearlayout里做出垂直于orientation方向的效果，就要再嵌套一个另一方向的linearlayout</p>
<h3 id="相对布局"><a href="#相对布局" class="headerlink" title="相对布局"></a>相对布局</h3><p>相对布局提供了根据父容器和兄弟容器进行定位的方法</p>
<!-- ![ui](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-16-21-06.png) -->
<html>

<body>
    <h4></h4>
    <table border="1">
        <tr>
            <th>类别</th>
            <th>属性</th>
            <th>功能描述</th>
        </tr>
        <tr>
            <th rowspan="8">根据父容器定位</th>
            <td>android:layout centerInParent</td>
            <td>组件位于父容器中央位置</td>
        </tr>
        <td>android:layout_centerHorizontal</td>
        <td>组件位于父容器水平中央位置</td>
        <tr>
            <td>android:layout_centerHorizontal</td>
            <td>组件位于父容器水平中央位置</td>
        </tr>
        <tr>
            <td>android:layout_centerVertical</td>
            <td>组件位于父容器垂直中央位置</td>
        </tr>
        <tr>
            <td>android:layout_alignParentTop</td>
            <td>组件与父容器顶部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentLeft</td>
            <td>组件与父容器左部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentRight</td>
            <td>组件与父容器右部对齐</td>
        </tr>
        <tr>
            <td>android:layout_alignParentBottom</td>
            <td>组件与父容器底部对齐</td>
        </tr>
        <tr>
            <th rowspan="7">根据兄弟组件定位</th>
            <td>android:layout_above</td>
            <td>组件位于某组件上部</td>
        </tr>
        <tr>
            <td>android:layout_below</td>
            <td>组件位于某组件下部</td>
        </tr>
        <tr>
            <td>android:layout_toLeftOf/toRightOf</td>
            <td>组件位于某组件左/右侧</td>
        </tr>
        <tr>
            <td>android:layout_alignTop/Left/Right/Below</td>
            <td>组件与某组件对齐</td>
        </tr>
    </table>

</body>

</html>

<h3 id="层级布局FrameLayout"><a href="#层级布局FrameLayout" class="headerlink" title="层级布局FrameLayout"></a>层级布局FrameLayout</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:foreground</td>
<td>设置前景图像（永远位于最前）</td>
</tr>
<tr>
<td>android:foregroundGravity</td>
<td>设置前景图像Gravity</td>
</tr>
</tbody></table>
<p>各个组件从前到后依次在后方作为背景</p>
<h3 id="限制布局ConstraintLayout"><a href="#限制布局ConstraintLayout" class="headerlink" title="限制布局ConstraintLayout"></a>限制布局ConstraintLayout</h3><table>
<thead>
<tr>
<th>属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout_constraintLeft_toLeftOf</td>
<td>组件左部与某组件左部对齐</td>
</tr>
<tr>
<td>layout_constraintLeft_toRightOf</td>
<td>组件左部与某组件右部对齐</td>
</tr>
<tr>
<td>layout_constraintRight_toLefOf</td>
<td>组件右部与某组件左部对齐</td>
</tr>
<tr>
<td>layout_constraintRight_toRightOf</td>
<td>组件右部与某组件右部对齐</td>
</tr>
<tr>
<td>layout_constraintTop_toTopof</td>
<td>组件顶部与某组件顶部对齐</td>
</tr>
<tr>
<td>layout_constraintTop_toBottomOf</td>
<td>组件右顶与某组件底部对齐</td>
</tr>
<tr>
<td>layout_constraintBotom_toTopof</td>
<td>组件底部与某组件顶部对齐</td>
</tr>
<tr>
<td>layout_constraintBottom_toBottomOf</td>
<td>组件底部与某组件底部对齐</td>
</tr>
<tr>
<td>layout_constraintBascline_toBasclincO</td>
<td>组件基线与某组件基线对齐</td>
</tr>
<tr>
<td>laycut_constraintStart_toEndOf</td>
<td>组件首部与某组件尾部对齐</td>
</tr>
<tr>
<td>layout_constraintStart_toStartOf</td>
<td>组件首部与某组件首部对齐</td>
</tr>
<tr>
<td>layout_constraintEnd_toStartOf</td>
<td>组件尾部与某组件首部对齐</td>
</tr>
<tr>
<td>layout_constraintEnd_toEndOf</td>
<td>组件尾部与某组件尾部对齐</td>
</tr>
</tbody></table>
<p>如果限制信息确定了图片某几条边的位置，会覆盖height，width属性</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><img src="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-28-58.png" alt="总结"></p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>布局是用xml中声明，java中实现的。因此布局的渲染需要经过加载、解析和渲染的三个过程，</p>
<p>在activity的onCreate方法中调用setContentView时，它会创建DecorView，最终通过LayoutInflater加载了XML文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater.from(mContext).inflate(resId, contentParent)</span><br></pre></td></tr></table></figure>

<p>在这个加载器中，它会调用一个xml解析器，解析器根据tag生成View，组织ViewGroup并把他们添加到DecorView中…</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-43-39.png) -->

<p>此时屏幕还没有被绘制，在onResume()中会“借用”ViewRootImpl对象的requestLayout方法来触发配置。</p>
<!-- ![View绘制流程](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-46-13.png)
![页面绘制流程](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-47-16.png) -->
<p>在这之后，由VSync一帧为单位控制界面的刷新。00</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-18-49-59.png) -->

<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><h3 id="查找View"><a href="#查找View" class="headerlink" title="查找View"></a>查找View</h3><p>交互最基本的流程是先获取View实例，再添加相应的监听器（比如按钮的onClickListener()）</p>
<p>查找的过程中，activity调用DecorView的findViewById方法，每个ViewGroup都会迭代查找自己的孩子，方法是在ViewGroup和View中都实现findViewById，Group会判断自己的id并且调用所有孩子的findViewById。对于View而言，这个方法要么返回自己，要么返回NULL，对于Group而言，他将进行下一轮迭代。这样所有人都只需要知道自己的id，Group再额外记录自己有哪些孩子，就可以从DecorView开始查找到任何被解析过的View了。</p>
<h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>Android系统中常见的事件监听器有如下几种:</p>
<ol>
<li><p>单击事件(View.OnClickListener):当用户触碰到某个组件或者方向键被按下时产生该事件，该事件的处理方法是onClick（）.</p>
</li>
<li><p>焦点事件(View.OnFocusChangeListener):组件得到或者失去焦点时产生该事件，事件处理方法是onFocusChange（）。</p>
</li>
<li><p>按键事件(View.OnKey Listener):用户按下或者释放设备上的某个按键时产生，事件处理方法是 onKey（）。</p>
</li>
<li><p>触碰事件(View.OnTouchListener):设备具有触摸屏功能时，触碰屏幕产生该事件。事件处理方法是onTouch（）。</p>
</li>
<li><p>创建上下文菜单事件(View.OnCreateContextMenu Listener):创建上下文菜单时产生该事件，事件处理方法是 onCreateContextMenu（）。</p>
</li>
</ol>
<h3 id="屏幕触摸"><a href="#屏幕触摸" class="headerlink" title="屏幕触摸"></a>屏幕触摸</h3><p>所有事件都来自于屏幕触摸，交互事件是对屏幕点击的二次封装！触摸事件MotionEvent包含了触摸的时间、位置等，Activity和View都有onTouchEvent()用于处理触摸事件</p>
<!-- 
![触摸事件](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-03-07.png) -->

<p>接收到一个屏幕事件之后，具体要由哪个UI控件来响应，涉及到时事件的处理流程。触摸一个点很可能同时触摸了多个View，几个Layout还有至少一个Activity。在实践处理中，ViewGroup具有分发、拦截、响应的功能，Activity和View则不具有拦截的功能。<br><img src="/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-11-07.png" alt="事件处理"><br>出处(<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904041487532045">https://juejin.cn/post/6844904041487532045</a>)</p>
<p>如何理解onLongClickListener，onClickLisener，onTouchEvent的关系呢？在onTouchEvent在ACTION_DOWN时判断是否达到长按延时，而在ACTION_UP的时候才执行短按延时，此时如果已经出发了了长按执行的监听器，就不再执行短按的监听器，所以说onClickListener是在抬起手指时才触发的，并且不能与onLongClickListener一同触发。</p>
<h3 id="交互总结"><a href="#交互总结" class="headerlink" title="交互总结"></a>交互总结</h3><p>从谁发出，经过了谁，到达哪个对象，有何种行为。</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-17-15.png) -->

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h3><p>核心原理就是一帧一帧的播放图片，优点是简单、方便，缺点是功能单一，并且消耗资源。相比于gif，帧动画更可控。</p>
<!-- ![帧动画](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-18-15.png) -->

<p>帧动画是通过animation-list声明的，有子标签item，item包含drawable和duration两个属性。</p>
<h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><!-- 
![补间动画](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-21-48.png) -->
<p>补间动画可以控制透明度，旋转，缩放，平移，由系统自动由插值器（Interpolator）</p>
<p>这两种动画都是属于View动画，只能处理View对象，并且无法修改View的属性。（会出现动画无法点击的情况）</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-24-32.png) -->

<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>属性动画可以作用于任何一个对象，并且真实的改变了对象的属性。</p>
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/2022-07-29-19-25-57.png) -->

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>真正的动画需要结合各个动画才能做出更好的效果。</p>
<h2 id="自定义UI"><a href="#自定义UI" class="headerlink" title="自定义UI"></a>自定义UI</h2><!-- github.com/zeweng/SwitchButton -->

<h3 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h3><p>写四个构造器，对应四种场景。按需复写各方法，并且用各个方法绘制出View，然后再onTouchEvent中处理UI的行为和动画</p>
<!-- ![自定义View](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/自定义View.png)
![处理View布局](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/处理View布局.png) -->
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/绘制View.png) -->
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/处理用户交互.png) -->
<!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/自定义小结.png) -->

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><!-- ![](/2022/07/29/%E5%AE%89%E5%8D%93UI%E8%AE%BE%E8%AE%A1/整体总结.png) -->
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/28/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">Android学习笔记（三）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-28 00:48:49 / 修改时间：20:58:30" itemprop="dateCreated datePublished" datetime="2022-07-28T00:48:49+08:00">2022-07-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Intent的概念与使用"><a href="#Intent的概念与使用" class="headerlink" title="Intent的概念与使用"></a>Intent的概念与使用</h2><p>关于Intent，目前只用在启动activity上，通常启动一个activity时需要传递一个intent参数给指定的activity，同时也可以在这个Intent中夹带一些参数进行传递。</p>
<h3 id="用显示Intent启动Activity"><a href="#用显示Intent启动Activity" class="headerlink" title="用显示Intent启动Activity"></a>用显示Intent启动Activity</h3><p>显示intent就是指定了要启动的activity的类的intent，这种intent通常是用在app内activity之间的交互。接下来就来在一个项目里注册两个activity来看一看如何用intent启动。</p>
<p>如果不直接新建activity，就要新建一个java类，并令它继承Activity类，还要在res文件夹中新建layout文件定义其ui。之后在java文件中实现Activity的各个方法，通常在onCreate方法中进行layout与activity的绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.myaty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后为了使用这个activity中，我们还需要在AndroidManifest文件中进行注册,注意activity的name会与manifest的package组合起来作为Activity类的名称，所以在这里注册时可以使用简写，也可以在name中写全<code>包名.类名</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.study4intent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyAty&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--           name added to package as the name of an Activity object--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            use com.example.study4intent.MyAty instead--&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>到这里，我们就已经新建了一个activity，并且可以绑定它对应的java和res文件了。如果直接在AS中新建activity的话，ide会自动帮我们完成这些配置工作。</p>
<p>到这里，我们就可以试着用显示intent启动activity了，这里选择用一个按钮来触发新activity的启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.button).setOnClickListener(</span><br><span class="line">    <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Intent intent =</span><br><span class="line">                <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MyAty.class);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>java允许传new出来的参数，而new抽象类需要实现抽象方法，这种嵌套方式写出来的代码非常紧凑，不过通常我们会把findViewById的结果声明为private变量保存下来方便以后调用。</p>
<p>查看Intent构造器可知Intent可以用一个Context类型对象和一个class泛型来构造，这就是我们的显示Intent要传递的包名和类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Intent</span><span class="params">(Context packageContext, Class&lt;?&gt; cls)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>Intent除了用显式指定的包名和类名构造之外，也可以先通过一个标记构造，之后再寻找标记对应的类。最常见的方法是使用action，也就是一个字符串。如果用action构造了一个intent，那么就可以直接用这个字符串搜索到注册了这个action的类。（小疑惑，如果有两个一样的action会怎样呢？）</p>
<h3 id="注册action"><a href="#注册action" class="headerlink" title="注册action"></a>注册action</h3><p>在androidmanifest文件中，activity下加入intent-fliter标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;qaq&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，新版Android可能会报错，要求指定activity是否exported，直接用快速修复功能设置为true即可。下文会讲到。</p>
<p>category的name暂时选择default就可以，而action的name则要注册为对应的字符串，标准的action格式是<code>&lt;package_name&gt;.action.start.&lt;class_name&gt;</code>，不过这个格式实在过于复杂，我们也可以把action的名字放在要启动的类中，作为一个常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAty</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION = <span class="string">&quot;qaq&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在使用Intent时，就不需要直接输入长长的字符串，使用<code>MyAty.ACTION</code>就可以了</p>
<h3 id="用隐式Intent启动同一个app内的另一个Activity"><a href="#用隐式Intent启动同一个app内的另一个Activity" class="headerlink" title="用隐式Intent启动同一个app内的另一个Activity"></a>用隐式Intent启动同一个app内的另一个Activity</h3><p>基本的方法和之前都是相同的，区别就是构造intent时调用了另一种构造器：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.button).setOnClickListener(</span><br><span class="line">    new View.OnClickListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onClick(View view) &#123;</span><br><span class="line">            Intent intent =</span><br><span class="line"><span class="deletion">-                new Intent(MainActivity.this, MyAty.class);</span></span><br><span class="line"><span class="addition">+                new Intent(&quot;qaq&quot;);</span></span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Intent</span><span class="params">(String action)</span></span></span><br></pre></td></tr></table></figure>

<p>当然，隐式Intent最主要的作用并不是用来启动同一个应用内的activity，因为此时我们是可以直接获得这个activity的类的定义的。而在跨应用通讯时，隐式Intent就有用处了。</p>
<h3 id="用Intent跨应用启动activity"><a href="#用Intent跨应用启动activity" class="headerlink" title="用Intent跨应用启动activity"></a>用Intent跨应用启动activity</h3><p>还记得之前AS可能会要求我们添加的exported属性吗：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        &lt;activity android:name=&quot;.MyAty&quot;</span><br><span class="line"><span class="addition">+            android:exported=&quot;false&quot;&gt;</span></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;qaq&quot;/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<p>这是安卓权限管理引入的机制：只有设置为exported的activity对其他应用才是可见的，现在我们可以把它改为true，然后在project中新建一个package（app），并且在另一个app中启动这个app的activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btn_start_myaty).setOnClickListener(</span><br><span class="line">        <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(<span class="string">&quot;qaq&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;无法启动MyAty&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里使用了try结构来捕获可能的异常，如果前面没有正确的设置exported的话，就可能导致异常的出现。捕获到异常之后，用Toast组件打印一条提示信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/26/%E5%AE%89%E5%8D%93%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/%E5%AE%89%E5%8D%93%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">安卓四大组件</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 16:14:58" itemprop="dateCreated datePublished" datetime="2022-07-26T16:14:58+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="activity的使用"><a href="#activity的使用" class="headerlink" title="activity的使用"></a>activity的使用</h3><ol>
<li>在Android Menifest文件中注册</li>
<li>在xml文件中设定layout</li>
<li>在java文件中绑定activity</li>
</ol>
<p>GridView + Adaptor, GridView + Adaptor, ViewPager + Adaptor</p>
<h3 id="activity生命周期"><a href="#activity生命周期" class="headerlink" title="activity生命周期"></a>activity生命周期</h3><ol>
<li>onCreate<br>程序创建，进行文件的绑定</li>
<li>onStart<br>程序不可见，用户不可交互，进行一些</li>
<li>onResume<br>程序可见，用户可以交互</li>
<li>onPause<br>程序部分不可见，（比如被弹窗遮挡），在这里是最后一个比较靠谱的数据保存点（Android 5.0-）。<br>之后也可以在onStop中进行数据保存<br>如果之后恢复可见，会调用onResume</li>
<li>onStop<br>程序被完全遮挡，如果恢复，经由onRestart回到onStart</li>
<li>onDestroy<br>程序被销毁，注意，很多场景下可能不会走到这一步，而是在停止之后直接被系统回收</li>
</ol>
<p>配置变化（字体改变，屏幕旋转，键盘显示隐藏…）时的生命周期：先杀死再重建，杀死时在onPause之前调用onSaveInstanceState，<br>恢复时在onStart之后调用onRestoreInstanceState</p>
<p>如果不希望重建activity，可以在android_menifest文件中配置，在配置改变时调用onConfigurationChange，而不销毁。</p>
<blockquote>
<p>案例：接完电话之后，程序crush！</p>
</blockquote>
<ul>
<li><p>解释：页面被回收导致本地变量被清空</p>
</li>
<li><p>解决：添加判空逻辑避免空指针</p>
<ul>
<li>利用两个InstanceState保存和恢复现场！</li>
</ul>
</li>
</ul>
<h3 id="activity启动模式"><a href="#activity启动模式" class="headerlink" title="activity启动模式"></a>activity启动模式</h3><p>对于每个activity，都可以在android：launchMode中配置启动模式来达到消除重复activity的效果</p>
<ol>
<li>standard（默认）<br>每次启动页面都会在页面栈中添加一个新实例</li>
<li>singleTop<br>不允许栈顶有多个相同实例，试图创建新示例时会回调onNewInstance，然后无事发生</li>
<li>singleTask<br>不允许栈内有多个实例，如果试图创建新示例，将弹出页面之上的所有页面，然后回调onNewInstance</li>
<li>singleInstance<br>全局只能有一个实例，应用较少（银行登陆界面，通讯录黄页）</li>
</ol>
<blockquote>
<p>应用：返回首页的小按钮</p>
</blockquote>
<ul>
<li>实现：将主页activity设置为singleTask</li>
</ul>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>安卓设计fragment的初衷是为了解决页面碎片化的问题，不过平时开发中fragment经常用于提高速度（activity之间交互需要进行IPC），<br>以及进行组件的分离（在屏幕的各个区域用不同的fragment承载功能）</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol>
<li>创建布局文件</li>
<li>在java中加载布局文件</li>
<li>在activity中加载fragment<br>3.1 静态绑定-在布局文件中绑定<br>3.2 通过FragmentManager加载</li>
</ol>
<p>一般使用androidx.fragment，而不是android.app.fragment，以确保版本兼容</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li>onAttach<br> 使用activity资源时可以在此进行获取</li>
<li>onCreateView<br> 常用于初始化</li>
<li>onResume<br> 运行状态</li>
<li>onDestroyView<br> 资源回收</li>
</ol>
<p>此外也可以通过FragmentTranscation.maxLifeCycle设置可到达的最远生命周期</p>
<h3 id="与activity交互"><a href="#与activity交互" class="headerlink" title="与activity交互"></a>与activity交互</h3><p>组件获取</p>
<ul>
<li><code>getActivity.findViewById(R.id.xx)</code></li>
<li>getFragmentManager.findFragmentById()</li>
</ul>
<p>数据传递</p>
<ol>
<li>setArguments(Bundle bundle)</li>
<li>方法调用</li>
<li>viewmodel，handler，broadcast</li>
</ol>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>基本用法</p>
<ol>
<li>android_menifest注冊</li>
<li>java中实现类</li>
<li>加载：需要交互用bindService，不需要交互用startService</li>
</ol>
<h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><p>start， bind， destroy<br>&#x2F;&#x2F;TODO</p>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ol>
<li>定义Binder子类，实现getService方法，返回Service对象</li>
<li>实现Service类onBind方法，返回Binder对象</li>
<li>实例化ServiceConnection对象<br>&#x2F;&#x2F;TODO</li>
</ol>
<h2 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h2><p>静态广播：使用receiver，在java中实现BroadcastReceiver，用onRecieve接收，用Context.sendBroadcast发送<br>动态广播：</p>
<p>常用广播：网络&#x2F;电量变化，屏幕点亮&#x2F;熄灭，安装卸载升级软件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/06/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0-2/" class="post-title-link" itemprop="url">精神分析笔记(2)</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-06 23:58:43" itemprop="dateCreated datePublished" datetime="2022-07-06T23:58:43+08:00">2022-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:41:39" itemprop="dateModified" datetime="2023-03-08T22:41:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BF%83%E7%90%86%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">心理学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接下来的几讲介绍修通，修通是精神分析疗法中的一个重要概念。同之前的课程一样，我们还是从大背景讲起。</p>
<h2 id="精神分析治疗的理论路线"><a href="#精神分析治疗的理论路线" class="headerlink" title="精神分析治疗的理论路线"></a>精神分析治疗的理论路线</h2><p>精神分析疗法的最终目的应该是让病人产生持久性的改变。弗洛伊德的精神分析讨论的是：压抑导致心理冲突。心理冲突是神经症的心理机制，那么就来解决冲突。心理冲突最尖锐的时候是三到五岁，神经症对应心理发展阶段3~5岁，此时的压抑最为强烈，主要是对性的压抑，这就是弗洛伊德的理论。</p>
<p>客体关系理论指出，三岁以前两岁以内的时期，孩子不具有自己反抗自己、自己管理自己的能力，压抑比较弱。两岁以内，不完全受本能的推动，而很可能是受人际关系这个动力的推动。<br>弗洛伊德注意到本能似乎是很正确的，但那时很少有人注意到人际关系的重要。客体关系理论强调孩子除了吃的本能之外，还对养育者有着建立关系的需要，这种需要直接推动心理的发展。</p>
<ul>
<li>实验：布猴与铁猴</li>
<li>小猴依偎在布猴妈妈身边蹭， 并不理会铁猴的奶水。</li>
</ul>
<p>人和妈妈建立感情的需求，推动人心理的形成，这就是重要的依恋理论。4~6个月开始，孩子就能区分妈妈和陌生人。而四个月之前的孩子有没有人际交往作为生活动力的可能呢？孩子被抱起来之后会转头做吸吮动作，这是否是纯粹的条件反射呢？</p>
<ul>
<li>实验：妈妈在喂奶之后给孩子做鬼脸，从出生之后开始每天重复</li>
<li>到9~12天，孩子一看看到妈妈看他，没等妈妈做鬼脸，孩子先做鬼脸</li>
</ul>
<p>可见，这个实验一下子拜托了本能决定论，人为了和妈妈交流，天然的有建立亲情的需要和动力。到四个月之后，安全、情感交流、亲密感的需要更明显的体现了出来。<br>在两岁之前，孩子都有对人际关系的需要，如果此时没有得到母爱，那么孩子的发展就会受到影响。四个月时，孩子面对陌生人的表现有以下几种：</p>
<ul>
<li>眼睛追踪陌生人，露出微笑</li>
<li>眼睛追踪陌生人，面无表情</li>
<li>眼睛并不转动，毫无反应</li>
</ul>
<p>这三种反应出依次降低的心理功能，因为孩子的反应就体现出妈妈的养育方式。这又会进一步影响孩子两岁以后各种心理功能的发展。</p>
<p>这就是客体关系理论的基本理念：两岁以内的母爱缺乏导致心理功能的缺损。可以说，弗洛伊德的学说是压抑的学说，客体关系理论是功能缺损的学说。<br>心理功能缺损有许多表现，最终都成为人格障碍。这都是因为两岁关系母婴关系出了问题。</p>
<p>弗洛伊德的学说就像是种子的概念，客体关系理论则像是土壤的学说，一个是本能决定论的角度，一个是环境（母婴关系）的学说。这两个学说同时正确，相互补充。我们现在做精神分析必须把两套理论结合起来才是完整的，全面的。</p>
<h3 id="精神分析治疗的工作"><a href="#精神分析治疗的工作" class="headerlink" title="精神分析治疗的工作"></a>精神分析治疗的工作</h3><p><code>把潜意识意识化</code>，这就是经典精神分析（弗洛伊德）的任务。而现代精神分析需要做的事还有<code>修补人格的功能缺损</code>。</p>
<ul>
<li>比喻：精神分析的治疗与修自行车<br> 先补气，再休整，再换零件。支持疗法、人格重整</li>
</ul>
<p>精神分析有这样那样的方法，甚至于不同流派也有各种各样的方法，不过最终最重要的是心理咨询师如何<strong>组装内心的知识结构</strong>，并且<strong>灵活的将其运用于治疗中</strong>。</p>
<h3 id="精神分析的技术路线"><a href="#精神分析的技术路线" class="headerlink" title="精神分析的技术路线"></a>精神分析的技术路线</h3><p>潜意识的催眠术：提出歇斯底里的机制，找到了<code>把潜意识意识化</code><br>自由联想：扩大适应症，疗效更持久。<br>梦的分析：<code>通过梦理解与解释潜意识</code><br>会谈-对峙、澄清、解释、修通 ：稳定而持久的效果</p>
<p>从经典精神分析挖创伤解决症结到修补心理功能的现代精神分析，心理治疗从治疗导向逐渐转变为发展导向。<strong>发展是心理治疗的最终目标</strong>（这句话并不容易真正做到）</p>
<ul>
<li>Tip：修通的地位<br>在会谈成为主要治疗技术时的一个重要手段。</li>
</ul>
<h3 id="治疗关系的发展"><a href="#治疗关系的发展" class="headerlink" title="治疗关系的发展"></a>治疗关系的发展</h3><p>治疗师作为：屏幕、解释者、容器、内化客体</p>
<h3 id="精神分析治疗手段"><a href="#精神分析治疗手段" class="headerlink" title="精神分析治疗手段"></a>精神分析治疗手段</h3><p>建立工作联盟，分析处理移情和阻抗（处理治疗关系），自由联想变形使用（倾听、沉默、打断），偶尔使用梦的分析，更多的则是理解、解释、？？、修通</p>
<p>我们对病人施加影响，根本上决定于病人。但治疗师也要对病人的心理施加影响，在施加影响的时候，精神分析又有何独到之处呢？<br>催眠、暗示、情感宣泄，这都属于非特异性的方法。而自由联想、梦的分析、语言干预中的对峙澄清解释修通则带有特异性。<br>人本主义等也用对峙澄清，而精神分析式的解释由于涉及到阻抗的处理，是精神分析干预中最独特的，也是精神分析干预中最重要的手段。</p>
<h2 id="理解与解释"><a href="#理解与解释" class="headerlink" title="理解与解释"></a>理解与解释</h2><h3 id="什么是理解与解释"><a href="#什么是理解与解释" class="headerlink" title="什么是理解与解释"></a>什么是理解与解释</h3><p>理解就是理解症状的含义，即<strong>症状和心理需要之间的关系</strong></p>
<ul>
<li>案例：失女的父亲<br>地震时，教学楼倒塌，女儿遇难。父亲拿着手机，不吃不睡，不开口。</li>
</ul>
<p>解释：</p>
<ul>
<li>应激反应，急性期的情感休克，麻木 —— 这是理解与解释吗？</li>
</ul>
<p>说明因果关系不是理解：这是站在旁观者的角度进行的理论上的因果阐释，而没有<strong>共情</strong></p>
<ul>
<li>你很<em>愤怒</em>，联系别的家长追查，想上诉，这是因为你<em>心疼</em>女儿。</li>
</ul>
<p>说到这里，闭上的双眼留出泪水。</p>
<ul>
<li>追查上诉，可能得到赔款，但你真正想要的是<strong>给女儿一个交代</strong></li>
</ul>
<p>说到这里，激动的来握手。这时候就可以建立治疗关系了。</p>
<p>可见，对“心疼”的<em>共情</em>是不够的，没有真正表达出他的愿望，<strong>理解他的心理需要</strong>。</p>
<ul>
<li>后续，引着他的动力解决当前的问题：先吃饭看病，做父亲的自己活得好才能给女儿一个交代等等。。。</li>
</ul>
<p>解释就意味着让<strong>潜意识的内容</strong>进入意识，或者说让<strong>精神创伤的原因</strong>进入到意识。透过谈话帮助病人自己也没有意识到的内容进入病人和医生的意识，这样的一个工作就是揭示。解释属于语言干预的范畴。</p>
<p>理解与解释，经常是阐述一些因果关系，弗洛伊德的潜意识决定论会解释精神症与潜意识的关系，揭示内在的需要和动机。许多精神症都是通过象征化的手段来表达心中的欲望，如果通过直接的方式满足了欲望，这个象征化的手段就不需要了。</p>
<ul>
<li><p>例：让男生帮自己拧水瓶盖，间接的表达欲望。</p>
</li>
<li><p>tip：神经症用变通、拐弯的方式表达了自己心理的欲望，而不能拐弯也无法表达的欲望的就成为人格障碍。</p>
</li>
</ul>
<h3 id="理解的功能与形式"><a href="#理解的功能与形式" class="headerlink" title="理解的功能与形式"></a>理解的功能与形式</h3><ol>
<li>与以往的经验保持一致，获得<strong>一致性</strong>的感受，是一种理解。</li>
</ol>
<p>把当前的认知与过往的经验联系起来，建立逻辑联系，这就是理解的形式之一（普通心理学）。一旦理解了，就获得前后一致的内在感受，一旦不理解，就出现经验和认知的矛盾，无法获得一致性的内在感受。<br>比如遇到违背常识的事情，很希望获得背后的原理解释，要不然就感觉很疑惑。</p>
<ol start="2">
<li>完成未完成的事情完成，这也是一种理解</li>
</ol>
<ul>
<li>例：没看完的鬼故事<br>  只有看完了才能获得心理上的一致感！</li>
</ul>
<ol start="3">
<li>把两个事情联系起来获得<strong>整体感</strong>，也是一种理解</li>
</ol>
<p>比如常见的谐音的“寓意”，常见的“兆头”，把自然现象和事物与平安、美好等期盼联系起来。首先给自己一个解释：吃了苹果可以得到好兆头，然后再去削苹果。两个无关的事物通过心理上的理解连接在一起，从而获得了一个整体感，这个整体的两个部分具有心里意义上的联系：吃苹果表达平安。</p>
<h3 id="理解的心理机制"><a href="#理解的心理机制" class="headerlink" title="理解的心理机制"></a>理解的心理机制</h3><p>借着这种连接，心里的愿望也得以实现。这种连接事实上是任意的。</p>
<ul>
<li>例：“预言梦”<br>做了一个梦，梦见一个人推铅球。二十年后看到一个人推铅球，说“我的梦有预言作用”</li>
</ul>
<p>不管“预言”在多久之后实现，都可以在心理上建立联系。梦的记忆和推铅球的认知在当事人的感受中联系起来，这就说出一句话“我的梦具有预言作用”。两个无关的事情一链接，就得到了新的东西。而这东西背后表达的情感是什么呢——获得自主感、自信心、特殊感。</p>
<p>链接的是认知的是记忆，推动链接的是背后的心理需要，让人<em>宁愿</em>把这两个事情做链接。</p>
<ul>
<li>例：孩子看世界<br>太阳升起，因为我起床。太阳落下，因为我睡觉<br>妈妈高兴，因为我乖。妈妈生气，因为我不乖<br>妈妈去世了？ 因为我把妈妈气死了<br>妈妈离开了？ 因为我把妈妈气走了</li>
<li>例：养猫不能留小猫<br>人们说：小猫把老猫气走了。人们大多真的这么认为。<br>其实是老猫宁愿离开家，把家留给小猫，老猫感情上还是想念女儿的，只是宁可离开这个家</li>
</ul>
<p>这也是一种心理意义上的理解，所以有亲人去世的时候，每个活着的人都会感到内疚，检阅自己的过错，恨意消失，想着那个人的好，变成自责。这其实都是心理内部加工过的东西，通过把无关的事情建立联系，借以表达内在的心理情感和心理需要。<br>理解的思维活动，和潜意识的愿望与需要的关系就是这样。我们必须说清楚这个阶段，才能理解病人为何存在着非理性的认知观念。</p>
<h3 id="理解的意义"><a href="#理解的意义" class="headerlink" title="理解的意义"></a>理解的意义</h3><p>非理性的认知观念重点在于<strong>非理性</strong>，重点并非他到底想的是<em>怎样的怀念头</em>，而是他<em>为什么</em>宁愿想坏的念头。认知疗法无法解决，只有精神分析才能回答这个问题：出于内在的需要。</p>
<ul>
<li>例：走不出的失恋<br>充满理想化的回忆，温习爱的痛苦，这才能保持自我的同一性，因此宁愿那么想。</li>
</ul>
<p>“理解”的心理机制可以帮助我们理解一些临床现象。</p>
<p>其次，理解还可以帮助我们在病人心理内部建立新的连接，表达原来无法表达的情感与愿望。<br>我们经常能够在悲剧作品中看到这样的表达，比如传统中国悲剧中总是有一个浪漫式的结尾，通过一种纯粹心理上的理解来获得故事的完整性，并且表达我们内心对于美好故事的愿望。</p>
<p>每个人的心中都会有未完成的故事情节，如同鲁迅写的《风筝》故事，（这里老师记错了结局）,鲁迅并没有释然，而是因为弟弟不冷不热的回应更深刻的感受到了未完成事件的痛苦。</p>
<p>对于未完成事件，如果能找到从前的那个情景，可以完成。如果不能找到，只能通过自己的想象去完成。</p>
<ul>
<li>例：交通事故之后的小伙<br>汽车时刹车不及下坡时撞车，女友惨死。<br>治疗过程中，要帮助他完成这个恋爱故事</li>
</ul>
<p>未完成的事件会导致心理发展的停滞。</p>
<ul>
<li>例：地震中的灾民<br>地震中一个尸体头滚落，卫生局长用砖头把头和尸体接起来，久久难以忘怀。</li>
</ul>
<p>要不要继续讲地震的故事呢？要的，如果不讲，那种惨状就一直停留在头脑里，停滞不前。这个时候就需要我们在内心帮助他完成这个故事。想象家人看到尸体的悲伤，想象家人对好心人的举动，想象你的回应。<br>慢慢的，回忆的内容从血肉模糊的变成家里人，最后淡化，没有了。<br>通过整体性的连接、理解之后，能够表达更多的情感，在心理治疗上具有积极的作用。人看到灾后的一系列事情，时间上进行了动态的发展。<br>在讲地震的这个完整故事的过程中，我们可能从“人的生命真脆弱”，来到看到救灾时的“人类的勇气与善良值得歌颂”，这种情况下，人的心理因为新的解释得到了发展。</p>
<ul>
<li>例：忘不掉的初恋<br>解释：人们总是以为第一次的体验就是正确的，就好比第一次爱人敲了一个窗户，其他人敲了另外的窗户，你就以为那些都不是爱人<br>问题：我只想等着那一类人来敲我的窗<br>解释2：爱人敲了一扇窗你以为是爱情，爱人敲了另一扇窗，你却不去听了<br>问题：没人来敲窗（守株待兔式的爱）<br>解释3：我们不再被动的等待一个爱人，而是主动的创造一个爱人。<br>问题：没人来敲窗总是感觉很寂寞？<br>解释4：主动走出去，去敲别人家的窗</li>
</ul>
<p>这是很好的例子！不同的解释要尽量的贴近内在的想法，建立和他内心的联系，才能一步步的把他带出来，<strong>用贴近内心的解释来推动行为</strong>。通过这种解释，内心多出了新的想法，以新的视角推动人去行动，改变了他行为的方式。</p>
<p>这就是对理解是什么的基本的认识。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>治疗师先对自己进行理解，然后<em>将心比心</em>的去理解病人，就叫做对病人的理解。看到别人流眼泪勾起了自己流眼泪时的感受，<em>投射</em>给病人，就是理解（认同性的投射）。<br>理解了而不表达，只是理解。<strong>把理解说给病人听，就是解释</strong>。将心比心地用自我理解理解病人，又把对病人的理解说给病人听，这样的临床操作就叫解释。解释的前提和基础就是理解，也就是理解对方的<strong>动机、需要、行动背后的心理含义</strong><br>病人借助我们的解释，最终不是要理解我们的说法，而是要<strong>加深对自我的理解</strong>。通过自我理解，病人内心的不一致、未完成得以解决，内心的愿望得以表达，也丰富了他内心的想法。自我理解整理散乱的记忆，接续未完成的事件，可以修补心理功能的缺损，让心理更有整体性，更符合现实发展的逻辑。丰富心理功能是解释的客观效果，而达成病人的愿望是解释的主观动力：借着自我理解，病人表达了自己压抑的东西——把潜意识的东西意识化。<br>自由联想回忆起内在的感受，而借助医生的解释，潜意识的愿望能够在意识层面得以觉察和表达，这是解释最重要的功能。<em><strong>精神分析的解释是精神分析治疗的眼珠子</strong></em>。移情和阻抗的处理都需要理解。</p>
<p>人总是希望“解释世界”，要赋予事物意义，要完成未完成的事件（例：没想通的压轴题）。对外界的认知和观念要想成为我们相信的内容，即加入了情感、信念的坚定认同，是需要有一个过程的。这句话为修通埋下伏笔。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/07/04/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/04/README/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-04 11:11:05" itemprop="dateCreated datePublished" datetime="2022-07-04T11:11:05+08:00">2022-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 20:37:25" itemprop="dateModified" datetime="2022-05-28T20:37:25+08:00">2022-05-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="grpc-Benchmarks"><a href="#grpc-Benchmarks" class="headerlink" title="grpc Benchmarks"></a>grpc Benchmarks</h1><h2 id="QPS-Benchmark"><a href="#QPS-Benchmark" class="headerlink" title="QPS Benchmark"></a>QPS Benchmark</h2><p>The “Queries Per Second Benchmark” allows you to get a quick overview of the throughput and latency characteristics of grpc.</p>
<p>To build the benchmark type</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew :grpc-benchmarks:installDist</span><br></pre></td></tr></table></figure>

<p>from the grpc-java directory.</p>
<p>You can now find the client and the server executables in <code>benchmarks/build/install/grpc-benchmarks/bin</code>.</p>
<p>The <code>C++</code> counterpart can be found at <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/tree/master/test/cpp/qps">https://github.com/grpc/grpc/tree/master/test/cpp/qps</a></p>
<p>The <a href="src/jmh/java/io/grpc/benchmarks/netty">netty benchmark</a> directory contains<br>the standard benchmarks used to assess the performance of GRPC. Since these<br>benchmarks run on localhost over loopback the performance of the underlying network is considerably<br>different to real networks and their behavior. To address this issue we recommend the use of<br>a network emulator to make loopback behave more like a real network. To this end the benchmark<br>code looks for a loopback interface with ‘benchmark’ in its name and attempts to use the address<br>bound to that interface when creating the client and server. If it cannot find such an interface it<br>will print a warning and continue with the default localhost address.</p>
<p>To attempt to standardize benchmark behavior across machines we attempt to emulate a 10gbit<br>ethernet interface with a packet delay of 0.1ms.</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>On Linux we can use <a target="_blank" rel="noopener" href="https://www.linuxfoundation.org/collaborate/workgroups/networking/netem">netem</a>  to shape the traffic appropriately.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Remove all traffic shaping from loopback</span></span><br><span class="line">sudo tc qdisc del dev lo root</span><br><span class="line"><span class="comment"># Add a priority traffic class to the root of loopback</span></span><br><span class="line">sudo tc qdisc add dev lo root handle 1: prio</span><br><span class="line"><span class="comment"># Add a qdisc under the new class with the appropriate shaping</span></span><br><span class="line">sudo tc qdisc add dev lo parent 1:1 handle 2: netem delay 0.1ms rate 10gbit</span><br><span class="line"><span class="comment"># Add a filter which selects the new qdisc class for traffic to 127.127.127.127</span></span><br><span class="line">sudo tc filter add dev lo parent 1:0 protocol ip prio 1 u32 match ip dst 127.127.127.127 flowid 2:1</span><br><span class="line"><span class="comment"># Create an interface alias call &#x27;lo:benchmark&#x27; that maps 127.127.127.127 to loopback</span></span><br><span class="line">sudo ip addr add dev lo 127.127.127.127/32 label lo:benchmark</span><br></pre></td></tr></table></figure>

<p>to remove this configuration</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tc qdisc del dev lo root</span><br><span class="line">sudo ip addr del dev lo 127.127.127.127/32 label lo:benchmark</span><br></pre></td></tr></table></figure>

<h3 id="Other-Platforms"><a href="#Other-Platforms" class="headerlink" title="Other Platforms"></a>Other Platforms</h3><p>Contributions are welcome!</p>
<h2 id="Visualizing-the-Latency-Distribution"><a href="#Visualizing-the-Latency-Distribution" class="headerlink" title="Visualizing the Latency Distribution"></a>Visualizing the Latency Distribution</h2><p>The QPS client comes with the option <code>--save_histogram=FILE</code>, if set it serializes the histogram to <code>FILE</code> which can then be used with a plotter to visualize the latency distribution. The histogram is stored in the file format of <a target="_blank" rel="noopener" href="https://hdrhistogram.org/">HdrHistogram</a>. That way it can be plotted very easily using a browser based tool like <a target="_blank" rel="noopener" href="https://hdrhistogram.github.io/HdrHistogram/plotFiles.html">https://hdrhistogram.github.io/HdrHistogram/plotFiles.html</a>. Simply upload the generated file and it will generate a beautiful graph for you. It also allows you to plot two or more histograms on the same surface in order two easily compare latency distributions.</p>
<h2 id="JVM-Options"><a href="#JVM-Options" class="headerlink" title="JVM Options"></a>JVM Options</h2><p>When running a benchmark it’s often useful to adjust some JVM options to improve performance and to gain some insights into what’s happening. Passing JVM options to the QPS server and client is as easy as setting the <code>JAVA_OPTS</code> environment variables. Below are some options that I find very useful:</p>
<ul>
<li><code>-Xms</code> gives a lower bound on the heap to allocate and <code>-Xmx</code> gives an upper bound. If your program uses more than what’s specified in <code>-Xmx</code> the JVM will exit with an <code>OutOfMemoryError</code>. When setting those always set <code>Xms</code> and <code>Xmx</code> to the same value. The reason for this is that the young and old generation are sized according to the total available heap space. So if the total heap gets resized, they will also have to be resized and this will then trigger a full GC.</li>
<li><code>-verbose:gc</code> prints some basic information about garbage collection. It will log to stdout whenever a GC happend and will tell you about the kind of GC, pause time and memory compaction.</li>
<li><code>-XX:+PrintGCDetails</code> prints out very detailed GC and heap usage information before the program terminates.</li>
<li><code>-XX:-HeapDumpOnOutOfMemoryError</code> and <code>-XX:HeapDumpPath=path</code> when you are pushing the JVM hard it sometimes happens that it will crash due to the lack of available heap space. This option will allow you to dive into the details of why it happened. The heap dump can be viewed with e.g. the <a target="_blank" rel="noopener" href="https://eclipse.org/mat/">Eclipse Memory Analyzer</a>.</li>
<li><code>-XX:+PrintCompilation</code> will give you a detailed overview of what gets compiled, when it gets compiled, by which HotSpot compiler it gets compiled and such. It’s a lot of output. I usually just redirect it to file and look at it with <code>less</code> and <code>grep</code>.</li>
<li><code>-XX:+PrintInlining</code> will give you a detailed overview of what gets inlined and why some methods didn’t get inlined. The output is very verbose and like <code>-XX:+PrintCompilation</code> and useful to look at after some major changes or when a drop in performance occurs.</li>
<li>It sometimes happens that a benchmark just doesn’t make any progress, that is no bytes are transferred over the network, there is hardly any CPU utilization and low memory usage but the benchmark is still running. In that case it’s useful to get a thread dump and see what’s going on. HotSpot ships with a tool called <code>jps</code> and <code>jstack</code>. <code>jps</code> tells you the process id of all running JVMs on the machine, which you can then pass to <code>jstack</code> and it will print a thread dump of this JVM.</li>
<li>Taking a heap dump of a running JVM is similarly straightforward. First get the process id with <code>jps</code> and then use <code>jmap</code> to take the heap dump. You will almost always want to run it with <code>-dump:live</code> in order to only dump live objects. If possible, try to size the heap of your JVM (<code>-Xmx</code>) as small as possible in order to also keep the heap dump small. Large heap dumps are very painful and slow to analyze.</li>
</ul>
<h2 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h2><p>Newer JVMs come with a built-in profiler called <code>Java Flight Recorder</code>. It’s an excellent profiler and it can be used to start a recording directly on the command line,  from within <code>Java Mission Control</code> or<br>with jcmd.</p>
<p>A good introduction on how it works and how to use it are <a target="_blank" rel="noopener" href="http://hirt.se/blog/?p=364">http://hirt.se/blog/?p=364</a> and <a target="_blank" rel="noopener" href="http://hirt.se/blog/?p=370">http://hirt.se/blog/?p=370</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/05/11/%E8%8B%B1%E8%AF%AD%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/11/%E8%8B%B1%E8%AF%AD%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">英语科技文献阅读</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-11 10:44:35 / 修改时间：10:51:52" itemprop="dateCreated datePublished" datetime="2022-05-11T10:44:35+08:00">2022-05-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Structure-of-RA"><a href="#Structure-of-RA" class="headerlink" title="Structure of RA"></a>Structure of RA</h2><ul>
<li>Title</li>
<li>Authors &amp; Affiliation(单位)</li>
<li><em>Abstract</em></li>
<li><strong>Introduction</strong></li>
<li><strong>Materials &amp; Methods</strong></li>
<li><strong>Results &amp; Discussion</strong></li>
<li>Conclusion</li>
<li>Acknowledgements(致谢)</li>
<li>Appendix</li>
<li>Reference(引用)</li>
<li>Bibliography(参考)</li>
</ul>
<h2 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h2><h3 id="Type-of-Title"><a href="#Type-of-Title" class="headerlink" title="Type of Title"></a>Type of Title</h3><ul>
<li><p>Declaration 声明性</p>
<p>  整句<strong>话</strong></p>
</li>
<li><p>Descriptive&#x2F;neutral 描述性&#x2F;中性标题</p>
<p>  名<strong>词</strong>短语+定语</p>
</li>
<li><p>Interrogative 疑问句式</p>
<p>  疑问<strong>句</strong></p>
</li>
<li><p>Compound 复合型标题</p>
<p>  由主副两部分构成（冒号或破折号分开）</p>
</li>
</ul>
<h3 id="How-to-read-title"><a href="#How-to-read-title" class="headerlink" title="How to read title"></a>How to read title</h3><p>devide the title into sense group</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strategies | to re-establish stable granulation | after filamentous outgrowth | : Insignts | from lab-scale</span><br></pre></td></tr></table></figure>

<ul>
<li>名词</li>
<li>动宾短语</li>
<li>介词短语</li>
<li>…</li>
</ul>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul>
<li>at the beginning (or the end) of a research article, miniature of a research work.</li>
<li>independent, self-contained, well-structured 独立完整&#x2F;自圆其说&#x2F;结构严谨</li>
<li>Consist of Five Move(话步,语步)<ul>
<li>background 是什么</li>
<li>problem 做了什么 (purpose&#x2F;hypotheses)</li>
<li>method 怎么做的</li>
<li>result 有何结果 (major finding&#x2F;important data)</li>
<li>conclusion 总结展望 (further study&#x2F;future directions)</li>
</ul>
</li>
</ul>
<h3 id="How-to-read-abstract"><a href="#How-to-read-abstract" class="headerlink" title="How to read abstract"></a>How to read abstract</h3><ul>
<li><p>focus on subject + verb</p>
</li>
<li><p>devide the abstract into five moves</p>
</li>
<li><p>focus on clue words:</p>
<ul>
<li>“such”, “recently”,”today” that indicates present time can be found in move 1.</li>
<li>“here”, “this paper” with past tense usually come with move 2 and 3</li>
<li>method will be described with verbs.</li>
<li>“showed”“revealed”“indicated” are used to discribe result and “find” for finding</li>
<li>present and future tenses with subjective mood are used in making conclusion, with words like “could””would”.</li>
</ul>
</li>
</ul>
<h2 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li><p>context : explains the rationale for undertaking the study and clearly describes the main purpose of conducing it.</p>
</li>
<li><p>purpose : to <strong>c</strong>reate <strong>a</strong> <strong>r</strong>esearch <strong>s</strong>pace(CARS)</p>
</li>
<li><p>moves</p>
<ol>
<li>Establishing a territory<br>现状描述词</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Increasing interest has grown on ...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Reviewing previous related research<br> 文献综述词</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Several Studies have ...</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Establishing a niche(壁炉)<br>转折否定词</li>
</ol>
<pre><code>- However/while/but...
- failed to 
- ignored/neglected to
</code></pre>
<ol start="4">
<li>Occupying the niche</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://huiyeruzhou.github.io/2022/04/21/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="辉夜">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="辉夜的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/21/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Android学习笔记（二）</a>
        </h2>

        <div class="post-meta">
          
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-21 14:42:38" itemprop="dateCreated datePublished" datetime="2022-04-21T14:42:38+08:00">2022-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 22:40:39" itemprop="dateModified" datetime="2023-03-08T22:40:39+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="在Activity间传递参数"><a href="#在Activity间传递参数" class="headerlink" title="在Activity间传递参数"></a>在Activity间传递参数</h2><p>写了个小脚本解决虚拟机频繁锁死的问题:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">del</span> C:\Users\huiyeruzhou\.android\*.lock</span><br></pre></td></tr></table></figure>

<p>这下一键开锁了(<br>在Activity间传递参数的方法很简单,在Intnet里把参数压进去就可以了（此时还没有详细讲解什么是Intent）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    Intent i = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TheAty.class);</span><br><span class="line">    i.putExtra(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;qaq!QAQ__&quot;</span>);</span><br><span class="line">    startActivity(i);&#125;</span><br></pre></td></tr></table></figure>

<p>intent传递参数的方式是键值对，值可以传很多类型，包括基本类型、数组、字符串等。<br>接收的方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent i =getIntent();</span><br><span class="line">tv = findViewById(R.id.viewview);</span><br><span class="line">tv.setText(i.getStringExtra(<span class="string">&quot;data&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这里的”data”就是之前数据的名称。通过名称可以找到字符串，并且通过setText方法显示在文本框里。</p>
<h3 id="使用Bundle传递多个参数"><a href="#使用Bundle传递多个参数" class="headerlink" title="使用Bundle传递多个参数"></a>使用Bundle传递多个参数</h3><p>Bundle的使用方法和基本类型是类似的，先新建一个Bundle对象，然后调用对象的<code>put&lt;DataType&gt;</code>方法<br>再调用Intent对象的<code>putExtras</code>方法传递Bundle即可，接收的方法也是类似的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent i = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TheAty.class);</span><br><span class="line">               Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">               b.putString(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;qaq?QAQ&gt;_&lt;&quot;</span>);</span><br><span class="line">               b.putInt(<span class="string">&quot;emm&quot;</span>,<span class="number">611</span>);</span><br><span class="line">               i.putExtras(b);</span><br><span class="line">               startActivity(i);</span><br></pre></td></tr></table></figure>

<p>接收Bundle的数据时，可能会存在某个键无法在Bundle中找到对应值得情况，这种情况下Bundle类提供了<br><code>get&lt;DataType&gt;</code>的重载方法以指定默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tv.setText(String.format(<span class="string">&quot;%s,%d,%s&quot;</span>,</span><br><span class="line">                b.getString(<span class="string">&quot;data&quot;</span>),b.getInt(<span class="string">&quot;emm&quot;</span>),</span><br><span class="line">                b.getString(<span class="string">&quot;ne!&quot;</span>,<span class="string">&quot;abab&quot;</span>)));<span class="comment">//&quot;ne!&quot;对应的值不存在，显示为默认值&quot;abab&quot;</span></span><br></pre></td></tr></table></figure>

<p>此外，Bundle也可以直接通过putExtra方法进行传递，这种情况可能适用于有多个Bundle的情况，此时<br>接受时也要使用getBundleExtra方法来进行查找。</p>
<h3 id="传递值对象"><a href="#传递值对象" class="headerlink" title="传递值对象"></a>传递值对象</h3><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><p>首先来看标准启动模式，也是默认的启动模式。我们来新建一个项目来演示不同的启动模式。首先为MainActivity添加一个TextView，两个Button<br>新建一个活动，叫做AnotherActivity，复制MainActivity的布局文件</p>
<p>java代码中设置TextView要显示的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tv.setText(format(<span class="string">&quot;Task ID:%d\nCurrent Instance id:%s&quot;</span>,getTaskId(),<span class="keyword">this</span>.toString()));</span><br></pre></td></tr></table></figure>

<p>Task ID是任务栈id，而当前示例ID则是当前对象的地址，可以用来区分activity的示例。</p>
<p>接下来设置两个按钮，一个启动MainActivity一个启动AnotherActivity，复制上述代码到AnotherActivity.java，注意修改intent中package context为<code>AnotherActivity.this</code>，效果如图</p>
<div align="center">
 <img src="Android学习笔记（二）/2022-04-22-22-35-18.png" width="50%">
</div>

<p>接下来可以点按钮试试，可以观察到TaskId都是一样的，而实例的id是不同的，这就意味着点击按钮会创建新的示例，而且所有的示例都位于一个任务栈中。</p>
<p>在标准的启动模式中，我们启动一个Activity就会压栈一个新的实例，点击返回键就会弹栈。多次点击app的创建示例按钮，再按返回键，可以观察到他们依次被销毁的过程。</p>
<p>可以在AndroidManifest.xml文件中的Activity标签下添加Android:launchMode条目来指定启动模式，如果没有这个条目，则默认为Standard。</p>
<h3 id="SingleTop启动模式"><a href="#SingleTop启动模式" class="headerlink" title="SingleTop启动模式"></a>SingleTop启动模式</h3><p>SingleTop，顾名思义，如果该活动的一个实例位于栈顶，就不能继续创建该活动的新实例。只有当栈顶实例不为该活动时，才能创建该活动的新实例。<br>下面在AndroidManifest.xml文件中配置MainActivity的启动模式为SingleTop.</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;activity</span><br><span class="line">            android:name=&quot;.MainActivity&quot;</span><br><span class="line">            android:exported=&quot;true&quot;</span><br><span class="line"><span class="addition">+            android:launchMode=&quot;singleTop&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动程序，首先点击启动A活动按钮，应用没有反应。此时如果点击返回键会直接退出。<br>如果启动程序后先点击启动B活动按钮，再点击启动A活动按钮，可以发现这次成功的创建了A的新实例。这是因为创建了B活动之后，A活动的上一个实例已经不在栈顶，因此可以创建新的实例。</p>
<h3 id="SingleTask模式"><a href="#SingleTask模式" class="headerlink" title="SingleTask模式"></a>SingleTask模式</h3><p>在这种情况下，一个任务栈中只能有一个该任务的实例，如果试图创建新实例，将会<strong>弹出</strong>所有位于该实例上的活动实例。<br>修改AndroidManifest文件，将启动模式修改为<code>singleTask</code>,启动应用程序。<br>点击启动A活动按钮，没有反应。点击启动B活动按钮，再点击启动A活动按钮，可以看到B活动退出，而显示的A活动正是第一个示例，如果此时再点击返回键，应用直接退出，说明所有B活动的示例都因为其位于A活动上方而被弹出了。</p>
<h3 id="SingleInstance模式"><a href="#SingleInstance模式" class="headerlink" title="SingleInstance模式"></a>SingleInstance模式</h3><p>在这种情况下，全局只有该活动的一个实例，第一次创建该活动时会创建一个新的任务栈，并且一个任务栈中只有这一个activity，而其他活动的实例会位于新的任务栈中。这种情况下，试图启动该活动的新实例时，会切换到保存该活动实例的任务栈。其他的任务栈不受影响。</p>
<h3 id="SingleInstancePerTask"><a href="#SingleInstancePerTask" class="headerlink" title="SingleInstancePerTask"></a>SingleInstancePerTask</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="辉夜"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">辉夜</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">辉夜</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
